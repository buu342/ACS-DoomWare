/*===========================================================================================================================================
    Welcome to DoomWare's ACS Code! This is where all the magic happens.
    After Beta 1.8, I went ahead and rewrote the entire core of the gamemode from scratch in an attempt to both make the code
    more stable, but more importantly to make it easier to read and modify. This has allowed me to add all sorts of new features
    really easily, as I didn't have to keep writing exceptions/rewriting entire blocks of code to implement new stuff.

    Typically, I call scripts that have an activator a CLIENT script, and scripts that don't a SERVER script. This also helps
    differentiate between code that handles the game itself (Server) and code that doesn't (Client). That doesn't mean that the
    client isn't important! Both need to be in balance to work perfectly!
    Client scripts also require ExecuteAlways (as each client runs a version of the script), Server scripts do not.

    To add a new minigame, simply increment the value of NUMBEROFGAMES, and create a Client and Server script with the number
    of your minigame. The Serverside script will dictate the duration of the minigame. The Client script should loop for
    as long as the minigame is occuring (while(game_status == STATUS_MINIGAME)). If you're a bit confused, just copy code from
    other minigames.

    The same applies to tie breakers. TieBreaker is for 1v1 games and TiebreakerM is for Non-1v1 games.

    When a game starts, players are put inside the player_midround array. Players win if they are inside player_wonround array,
    or if they are in the player_midround array WHILE round_winifmid == true. To ensure you don't forget to remove players from the
    midround array when you make them win/lose, please use Player_Lose() or Player_Win().

    I recommend reading through the list of global variables so you can familiarize yourself with a minigame's customizability,
    as well as check the Client and Server code of a minigame I've already implemented that is similar to the one you want to make.

    Extra miscallaneous notes:
    - All players have a TID of 1337 plus their PlayerNumber
    - Objects tagged with TID 7337 are usually marked for deletion at the end of each round.
    - Unless your minigame has a very specific scripted sequence from start to finish, I recommend that you don't use delays to wait
      until a game is over serverside, use DoomWare_Server_GameWait() instead, as it will end a game early if all the players have
      died/won the round (to prevent people from waiting until a long game is over (you can force this to not happen using
      round_noforceend)), and because it also automatically places a timer on the screen.
    - To move players to an area, use the script DoomWare_Server_TeleportPlayers(int destination_tid, int telesector) and then use the script
      DoomWare_Server_ReturnPlayers(int move_if_lost) to move them back. You can teleport them to individual map spots (telesector = 0) or
      Teleport them into an area the same size as the main hub with only a single map spot (telesector = 1).
      Alterntatively, use the script DoomWare_Server_TeleportSingle(int plynum, int dest) to teleport a single player.
    - To freeze players via PROP_TOTALLYFROZEN, please use Player_FreezeTotally(int who) and Player_UnFreezeTotally(int who) to prevent
      incompatibilities with the fact that the menu also freezes player movement (to allow for the cursor to move)
    - To add observers to your minigame, place a camera, give it a TID, and then in the beginning of your Server Minigame code, do
      Add_Observer(TID). This will automatically set minigame_canobserve to true, and the observer array will be automatically cleared
      after your script has ended so there is no need to call Clear_Observers.

    Have fun!

    - Buu342
===========================================================================================================================================*/

#include "zcommon.acs"


/*===================================================================================================
										   Definitions
===================================================================================================*/

// Don't Touch
#define SECOND 35   // Doom's internal tickrate
#define SAFETY ""   // To prevent "BEGINNERS LUCK" from being the default text due to it being the first #define'd string


// Game selection

#define NUMBEROFGAMES 89		// Number Of minigames
#define NUMBEROFTIEBREAKERS 3 	// Number Of 1v1 Tie Breakers
#define NUMBEROFTIEBREAKERSM 3  // Number Of Non-1v1 Tie Breakers
#define NUMBEROFHINTS 82        // Number of hints


// Debugging single minigames (-1 to not debug, provide a different number to force that minigame number to play)

#define DEBUG_GAME  -1
#define DEBUG_TIEB  -1
#define DEBUG_TIEBM -1


// Game settings

#define MAXPLAYERS  16	// All minigames were designed with 16 players in mind! Change if you know what you're doing!
#define MAXROUNDS   25  // How many rounds per game (Default 25)


// Game Speedups

#define MAXSPEEDUPS 4   // How many times should the game speedup (if increased from 4, edit the switches in Server_GameLogic!!!)

#define SPEEDUP1 6	    // default 6
#define SPEEDUP2 11	    // default 11
#define SPEEDUP3 16	    // default 16
#define SPEEDUP4 20     // default 20


// Game Status

#define STATUS_NOTSTARTED 0 // Waiting for players
#define STATUS_STARTING   1 // Game Initializing
#define STATUS_WAITING    2 // Waiting between minigames
#define STATUS_SPEEDUP    3 // The game is speeding up
#define STATUS_WINLOSE    4 // Announce the winners and losers
#define STATUS_MINIGAME   5 // We are playing a minigame
#define STATUS_GAMEOVER   6 // The game has ended
#define STATUS_TIEDETECT  7 // A tie has been detected
#define STATUS_TIEBREAK   8 // We are playing a tie breaker (1v1)
#define STATUS_TIEBREAKM  9 // We are playing a tie breaker (more than 1v1)


// Message ID's

#define MELEMENTS       48  // Number of reserved slots for menu elements

#define MSGID_CONSOLE   -1                      // Console only messages
#define MSGID_HSPLAYR   1                       // Highscore background
#define MSGID_HSBACK    2+MAXPLAYERS            // Highscore table player name (occupies MAXPLAYERS numbers)
#define MSGID_CURSOR    3+MAXPLAYERS            // Menu Cursor
#define MSGID_MELEM     4+MAXPLAYERS            // Menu element (occopies 64 slots)
#define MSGID_MENU      5+MAXPLAYERS+MELEMENTS  // Menu background
#define MSGID_CENTER    6+MAXPLAYERS+MELEMENTS  // Centered messages (eg You Win!)
#define MSGID_CENTER2   7+MAXPLAYERS+MELEMENTS  // Centered messages below above (eg speedup hints)
#define MSGID_SCORE     8+MAXPLAYERS+MELEMENTS  // HUD Score background
#define MSGID_ROUND     9+MAXPLAYERS+MELEMENTS  // HUD Round background
#define MSGID_ROUND2    10+MAXPLAYERS+MELEMENTS // HUD Round counter
#define MSGID_LEADER    11+MAXPLAYERS+MELEMENTS // HUD Leader background
#define MSGID_SPREAD    12+MAXPLAYERS+MELEMENTS // HUD Spread
#define MSGID_LEADER2   13+MAXPLAYERS+MELEMENTS // HUD Leader name
#define MSGID_SCORE2    14+MAXPLAYERS+MELEMENTS // HUD score counter
#define MSGID_SCORE3    15+MAXPLAYERS+MELEMENTS // HUD score text
#define MSGID_ROUND3    16+MAXPLAYERS+MELEMENTS // HUD Round text
#define MSGID_VIEWHS    17+MAXPLAYERS+MELEMENTS // HUD Highscore reminder
#define MSGID_STFACE    18+MAXPLAYERS+MELEMENTS // STATUSBAR Face
#define MSGID_STBAR     19+MAXPLAYERS+MELEMENTS // STATUSBAR Extra
#define MSGID_TIMER     20+MAXPLAYERS+MELEMENTS // Timer on the HUD
#define MSGID_TIMER2    21+MAXPLAYERS+MELEMENTS // Timer on the HUD background
#define MSGID_CENTER3   22+MAXPLAYERS+MELEMENTS // Centered messages below CENTER2
#define MSGID_OBSERVE   23+MAXPLAYERS+MELEMENTS // Press # to observe this minigame
#define MSGID_MENUBIND  24+MAXPLAYERS+MELEMENTS // Press # to open the menu
#define MSGID_VIEWSP    25+MAXPLAYERS+MELEMENTS // View sprite
#define MSGID_ACHIEVEM  26+MAXPLAYERS+MELEMENTS // Achievement notifications
#define MSGID_WARNING   27+MAXPLAYERS+MELEMENTS // Warnings


// Special TID's

#define TID_PLAYER    1337  // TID given to players (Occupies MAXPLAYERS amount of TID's)
#define TID_HATGAME   3337  // TID given to leader/winner hat (Occupies 2 TID's)
#define TID_EXTRA     4337  // TID given to extra objects during minigames (Occupies MAXPLAYERS amount of TID's)
#define TID_HATROLE   5337  // TID given to players with roles (Occupies MAXPLAYERS amount of TID's)
#define TID_AVOID     6337  // TID given to the AVOID object
#define TID_REMOVE    7337  // TID given to objects to be removed after a minigame ended


// Game Over Reasons

#define OVER_NONE       -1  // Game is not over
#define OVER_WINNER     0   // Because someone won
#define OVER_PLAYER     1   // Because of a lack of players
#define OVER_FORCED     2   // Because it was forced to end
#define OVER_JOIN       3   // Because someone joined during a solo game
#define OVER_WINNERSOLO 4   // Someone won during a solo game


// Player Roles

#define ROLE_UNLOGGED   -1  // Player is not logged in
#define ROLE_NONE       0   // No role
#define ROLE_REGULAR    1   // Someone who played this game wayyyyy too much
#define ROLE_BETA       2   // Someone special <3
#define ROLE_BUU342     3   // The god himself
#define ROLE_ACHIEVER   4   // Someone who has unlocked all the achievements


// Music Durations (only change if you changed the sounds)

#define MUSICDUR_WAIT1 (SECOND*4)
#define MUSICDUR_WAIT2 (SECOND*3 + 25)
#define MUSICDUR_WAIT3 (SECOND*3 + 10)
#define MUSICDUR_WAIT4 (SECOND*2 + 30)
#define MUSICDUR_WAIT5 (SECOND*2 + 20)

#define MUSICDUR_SPEEDUP1 (SECOND*7 + 10)
#define MUSICDUR_SPEEDUP2 (SECOND*6 + 25)
#define MUSICDUR_SPEEDUP3 (SECOND*6)
#define MUSICDUR_SPEEDUP4 (SECOND*5 + 15)

#define MUSICDUR_WINLOSE (SECOND + 32)

#define MUSICDUR_GAMEOVER (SECOND*7)
#define MUSICDUR_TIEBREAK (SECOND*4 + 9)


// Achievements

#define ACHIEVE_ID_1WIN        0
#define ACHIEVE_ID_10WIN       1
#define ACHIEVE_ID_100WIN      2
#define ACHIEVE_ID_25POINTS    3
#define ACHIEVE_ID_1v1WIN      4
#define ACHIEVE_ID_MVMWIN      5
#define ACHIEVE_ID_501UPS      6
#define ACHIEVE_ID_100DEATH    7
#define ACHIEVE_ID_300POINTS   8
#define ACHIEVE_ID_WRONGDOOR   9
#define ACHIEVE_ID_LONGJUMP    10
#define ACHIEVE_ID_3FRAGS      11
#define ACHIEVE_ID_BULLETHELL  12
#define ACHIEVE_ID_KARTWIN     13
#define ACHIEVE_ID_ATST        14
#define ACHIEVE_ID_RUNNER      15
#define ACHIEVE_ID_BADAIM      16
#define ACHIEVE_ID_FULLSERVER  17

#define ACHIEVE_NAME_1WIN        "Beginners Luck"
#define ACHIEVE_NAME_10WIN       "Just getting warmed up!"
#define ACHIEVE_NAME_100WIN      "Bingo Bango Bongo Bish Bash Bosh"
#define ACHIEVE_NAME_25POINTS    "Hoarder"
#define ACHIEVE_NAME_1v1WIN      "Fastest Gun in the West"
#define ACHIEVE_NAME_MVMWIN      "Darwinism"
#define ACHIEVE_NAME_501UPS      "Poor Kids in Africa Could Have Eaten Those"
#define ACHIEVE_NAME_100DEATH    "The Final Frontier"
#define ACHIEVE_NAME_300POINTS   "DoomWare veteran"
#define ACHIEVE_NAME_WRONGDOOR   "Colorblind"
#define ACHIEVE_NAME_LONGJUMP    "Mike Powell"
#define ACHIEVE_NAME_3FRAGS      "Point Man"
#define ACHIEVE_NAME_BULLETHELL  "Mushihimesama"
#define ACHIEVE_NAME_KARTWIN     "Tokyo Drifter"
#define ACHIEVE_NAME_ATST        "Dash Rendar"
#define ACHIEVE_NAME_RUNNER      "Runner's High"
#define ACHIEVE_NAME_BADAIM      "Bad Aim"
#define ACHIEVE_NAME_FULLSERVER  "House party"

#define ACHIEVE_DESC_1WIN        "Win a single game"
#define ACHIEVE_DESC_10WIN       "Win 10 games"
#define ACHIEVE_DESC_100WIN      "Win 100 games"
#define ACHIEVE_DESC_25POINTS    "Finish a game with 25 points or more"
#define ACHIEVE_DESC_1v1WIN      "Win a 1v1 tiebreaker match"
#define ACHIEVE_DESC_MVMWIN      "Be the sole survivor of a non-1v1 tiebreaker match"
#define ACHIEVE_DESC_501UPS      "Collect 50 1-ups"
#define ACHIEVE_DESC_100DEATH    "Die 100 times"
#define ACHIEVE_DESC_300POINTS   "Earn a total of 300 points"
#define ACHIEVE_DESC_WRONGDOOR   "Enter the wrong door"
#define ACHIEVE_DESC_LONGJUMP    "Get the 1-Up in the sonic minigame"
#define ACHIEVE_DESC_3FRAGS      "Frag 3 players in a deathmatch minigame"
#define ACHIEVE_DESC_BULLETHELL  "Survive the bullet hell minigame"
#define ACHIEVE_DESC_KARTWIN     "Finish first in a kart race"
#define ACHIEVE_DESC_ATST        "Destroy an AT-ST"
#define ACHIEVE_DESC_RUNNER      "Reach the end of the runner minigame"
#define ACHIEVE_DESC_BADAIM      "Hurt the imp in the apple minigame"
#define ACHIEVE_DESC_FULLSERVER  "Play on a full server"


// Miscellaneous

#define NUMOBSERVERS    8   // Size of the observers array. Increase if you need more.
#define TIMER_OFF       -1  // Not using the timer
#define TIMER_EARLY     -2  // Timer ended early


// Game changelog

#define CHANGES "\
Version Beta 1.95\n\
What's new in the Beta?\n\n\
Reached a total of 90 minigames\n\
Cleaned up some internal code\n\
Fixed a few bugs\n\
Removed obsolete 'Reach the End' Star Wars level\n\
Added toggleable Halloween theme\n\
Improved some music quality and length\n\
Added Confetti effect for achievements\n\
"

// Menu Text

#define WELCOME "\
Welcome to DoomWare, a fast paced competitive minigame wad. Every few seconds you are\n\
thrown into a new minigame with variying different goals. The longer you play, the\n\
faster and harder the game gets...\n\n\
Before you get started, make sure you have mouselook and jump bound, as you're going\n\
to need them. Also, make sure you have DoomWare specific binds setup as well (you\n\
should see them at the bottom of 'Options->Customize Controls' in your ESC menu). You\n\
can alternatively bind them manually via 'puke 257' (highscore), 'puke 998' (observation)\n\
and 'puke 999' (this menu).\n\n\
You can navigate this menu either using your movement keys or mouse, and you can select\n\
buttons via your USE or ATTACK key. You can close this menu via your menu button.\n\n\
If you are having trouble reading this or any other text due to a large resolution, you\n\
can force HUD scaling in the options tab of this menu, or via the console command\n\
doomware_hudscale.\n\n\
Good luck, and have fun!\
"

// Login Menu Text

#define LOGIN "\
You must have an account at www.auth.zandronum.com, and then login by opening the\n\
console and typing in 'login username password'. If you do not login, your stats and\n\
achievemnts will not be tracked.\
"


/*===================================================================================================
                                        Global Variables
===================================================================================================*/

bool player_wonround[MAXPLAYERS];       // Players put here have won the round (usually denoted by the green particle effect)
bool player_lostround[MAXPLAYERS];      // Players in here have lost the round (usually denoted by the red particle effect)
bool player_midround[MAXPLAYERS];       // All players are put in here at the start of each round.
bool player_viewingscore[MAXPLAYERS];   // List of players looking at the highscore
bool player_viewingmenu[MAXPLAYERS];    // List of players looking at their menu
bool player_musicwaiting[MAXPLAYERS];   // List of whether players are hearing the waiting/speedup music
bool player_musicwinlose[MAXPLAYERS];   // List of whether players are hearing the win/lose music
bool player_musicgameover[MAXPLAYERS];  // List of whether players are hearing the game over music
int  player_observe[MAXPLAYERS];        // List of what players are observing
bool player_frozen[MAXPLAYERS];         // List of what players have APROP_TOTALLYFROZEN
str  player_achievement[MAXPLAYERS];    // Notification of achievements
int  player_position[MAXPLAYERS][3];    // List player's XYZ pos before a minigame starts
int  player_teleporter[MAXPLAYERS];     // Array to keep track of randomized player spawns
int  player_frags[MAXPLAYERS];          // List player's frags
int  player_viewsprite[MAXPLAYERS];     // List of player's view sprite (like in the clean your weapon minigame)
int  player_answer1[MAXPLAYERS];        // Variables for minigame stuff (like keeping track of laps in Kart races)
int  player_answer2[MAXPLAYERS][4];     // Variables for minigame stuff (like keeping track of cacodemon answers)

int  game_score[MAXPLAYERS];        // The score of each PlayerNumber()
int  game_highscores[MAXPLAYERS];   // The global highscore table sorted by winner first
int  game_highnames[MAXPLAYERS];    // The global highscore table of player names sorted by winner first
int  game_roundnum;                 // A number containing the current round.
int  game_status;                   // A number containing the status of the gamemode's logic.
int  game_speed;                    // How fast is the game going
int  game_over;                     // The reason the game ended
bool game_solo;                     // Is someone playing alone?

int  round_current[MAXROUNDS];      // An array containing a list of all minigames to be played/that have been played
str  round_hints[MAXSPEEDUPS];      // An array containing a list of all hints to display
bool round_winifmid;                // Allow a player to win if he is in the midround array (like in games where you don't do anything to win)
bool round_winifsuicide;            // Pass the player if he killed himself
int  round_noforceend;              // Prevent the game from ending prematurely (unless everyone lost). Useful so people can collect 1ups.
int  round_tiebreaker;              // Which tiebreaker round are we playing
int  round_observers[NUMOBSERVERS]; // An array containing all the possible observer TID's
bool round_forceobservers; 		    // Does this round need observers to work? Only used for game_solo.

int  minigame_wincondition1;            // A generic global variable for minigames
int  minigame_wincondition2;            // A generic global variable for minigames
int  minigame_wincondition3;            // A generic global variable for minigames
int  minigame_timer;                    // A timer that is displayed during the minigame
bool minigame_canmove;                  // Used to signal players can play in tiebreaker rounds
bool minigame_canobserve;               // Can this minigame be observed?
bool minigame_fragpoints;               // Can you get points for frags?
str  minigame_instruction1[MAXPLAYERS]; // Center text during minigame
str  minigame_instruction2[MAXPLAYERS]; // Center text below center text during minigame
str  minigame_instruction3[MAXPLAYERS]; // Center text below center text below center text during minigame

int data_points[MAXPLAYERS];    // List of points each player has received in total
int data_wins[MAXPLAYERS];      // List of wins each player has achieved in total
int data_deaths[MAXPLAYERS];    // List of deaths each player suffered in total
int data_1ups[MAXPLAYERS];      // List of 1Ups each player got in total
int data_role[MAXPLAYERS];      // List of each player's role
int data_achieve[MAXPLAYERS];   // List of each player's achievements


/*===================================================================================================
										   Server Start
===================================================================================================*/

script "DoomWare_Server_Boot" OPEN
{
    // Initialize some global variables
    game_status = STATUS_NOTSTARTED;
    game_solo = false;

    // Some nice elevator music
	if (!strcmp(GetCVarString("doomware_mode"), "halloween"))
		SetMusic("D_WAIT2");
	else
		SetMusic("D_WAIT");

    // Create a "thread" that continually updates the hats and handles the database
    ACS_NamedExecute("DoomWare_Server_Hats", 0);

    // Clean up all the globals
    ACS_NamedExecute("DoomWare_Server_InitGlobals", 0);

    // Create a "thread" to syncronize global variables for CLIENTSIDE scripts
    ACS_NamedExecute("DoomWare_Server_SyncGlobals", 0);

	// Initialize the map
    ACS_NamedExecute("DoomWare_Server_InitMap", 0);

	// Wait until we have enough players
    while (PlayerCount() < 2 && !game_solo)
        Delay(1);

    // Stop the music and mark the game's start
    game_status = STATUS_STARTING;
    SetMusic("");

    // Initialize the game's serverside logic
    ACS_NamedExecute("DoomWare_Server_Initialize", 0);
}


/*===================================================================================================
										   Client Enter
===================================================================================================*/

script "DoomWare_Client_Join" ENTER
{
    // Initialize the player's variables
    ACS_NamedExecuteAlways("DoomWare_Client_Initialize", 0);

    // Notify about what's new
    HUDMessage(s:CHANGES; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 10.0, 10.0, 0.1);

    // Start the HUD "thread"
    ACS_NamedExecuteAlways("DoomWare_Client_DrawHUD", 0);
    ACS_NamedExecuteAlways("DoomWare_Client_DrawMenu", 0);

    // Wait until we have enough players
    while (game_status == STATUS_NOTSTARTED || game_status == STATUS_STARTING)
        delay(1);

    // Start the main clientside logic "thread"
    ACS_NamedExecuteAlways("DoomWare_Client_GameLogic", 0);
}


/*===================================================================================================
                                DoomWare Server Logic Initialization
===================================================================================================*/

Script "DoomWare_Server_Initialize" (void)
{
    // Initialize the hints
    ACS_NamedExecute("DoomWare_Server_InitHints", 0);

    // Select which games will be played from the collection
    ACS_NamedExecute("DoomWare_Server_InitRounds", 0);

    // Initialize the highscore table
    ACS_NamedExecute("DoomWare_Server_InitHighscores", 0);

    // Wipe the Observers array
    ACS_NamedExecute("DoomWare_Server_ClearObservers", 0);

    // Wait a bit so everyone knows the game is starting
    delay(SECOND*3);

    // Create a "thread" that continually updates the highscores
    ACS_NamedExecute("DoomWare_Server_CalcHighscore", 0);

    // Create a "thread" that controls the game logic
    ACS_NamedExecute("DoomWare_Server_GameLogic", 0);
}

Script "DoomWare_Server_InitMap" (void)
{
	Sector_SetCurrent(160, 300, 192, false);

	CreateTranslation(1, 168:191=112:127, 32:47=120:127, 16:31=112:119, 160:167=112:120);
	CreateTranslation(2, 168:191=96:111, 32:47=107:111, 16:31=102:106, 160:167=107:107);
	CreateTranslation(3, 168:191=192:207, 32:47=202:207, 16:31=198:203, 160:167=201:203);
	CreateTranslation(4, 168:191=80:95, 32:47=90:95, 16:31=86:92, 160:167=90:90);
	CreateTranslation(5, 168:191=208:223, 32:47=64:79, 16:31=48:63, 160:167=67:69);
	CreateTranslation(6, 96:111=112:127);
	CreateTranslation(10, 96:111=112:127);

	CreateTranslation(11, 112:127=80:95);
	CreateTranslation(12, 112:127=64:79);
	CreateTranslation(13, 112:127=199:207);
	CreateTranslation(14, 112:127=5:8);
	CreateTranslation(15, 112:127=176:191);

	Sector_SetFade(150, 255, 106, 0);
	Sector_SetFade(151, 255, 106, 0);
	Sector_SetFade(152, 255, 106, 0);
	Sector_SetFade(153, 255, 106, 0);
	Sector_SetFade(154, 255, 106, 0);
	Sector_SetFade(155, 255, 106, 0);
	Sector_SetFade(156, 255, 106, 0);
	Sector_SetFade(157, 255, 106, 0);
	Sector_SetFade(158, 255, 106, 0);

	Sector_SetFade(148, 255, 128, 0);
	Sector_SetFade(149, 255, 128, 0);
	Sector_SetFade(253, 255, 128, 0);

	Thing_SetTranslation(326, 1);
	Thing_SetTranslation(327, 2);
	Thing_SetTranslation(329, 3);
	Thing_SetTranslation(330, 4);
	Thing_SetTranslation(331, 5);
	Thing_SetTranslation (108, 10);

	Ceiling_Waggle(109, 32, 64, 0, 0);
	Floor_Waggle(133, 32, 64, 0, 0);
	Floor_Waggle(254, 256, 16, 0, 0);

	Scroll_Floor(3, 300, 2, 240);
	Scroll_Ceiling(3, 300, 2, 90);
	Scroll_Ceiling(202, 100, 2, 90);
	Sector_SetColor(4, 255, 105, 0, 0);
	Sector_SetColor(5, 0, 0, 255, 0);
	Sector_SetColor(29, 0, 255, 0, 0);
	Sector_SetColor(43, 36, 146, 219, 0);
	Sector_SetDamage(29, 99999, MOD_SLIME);
	Sector_SetDamage(4, 99999, mod_lava);
	Sector_SetDamage(41, 99999, MOD_FALLING);
	Sector_SetFriction(11, 30);
	Sector_SetGravity(18, 0, 50);
	Sector_SetGravity(206, 0, 75);
	Ceiling_CrushAndRaise(179, 64, 100, 1);

	for (int i=0; i<30; i++)
		Sector_SetGravity(222+i, 10, 0);

	SpawnSpotForced("Target", 688, 0, 0);

	Scroll_Floor(140, -64, 0, 2);
	Scroll_Floor(141, -55, -32, 2);
	Scroll_Floor(142, -32, -55, 2);
	Scroll_Floor(143, 0, -64, 2);
	Scroll_Floor(144, 32, -55, 2);
	Scroll_Floor(145, 55, -32, 2);
	Scroll_Floor(187, 64, 0, 2);
	Scroll_Floor(188, 55, 32, 2);
	Scroll_Floor(189, 32, 55, 2);
	Scroll_Floor(190, 0, 64, 2);
	Scroll_Floor(191, -32, 55, 2);
	Scroll_Floor(192, -55, 32, 2);

	thing_activate(22);
	thing_activate(37);
	thing_activate(67);
	SetActorState(577, "Deactivated");

    // Delay for the rotating spikes in event 119
    delay(SECOND/2);
	thing_activate(69);

    // Delay for the crushers in event 116
	Ceiling_CrushAndRaise(180, 64, 100, 1);
	delay(4);
	Ceiling_CrushAndRaise(181, 64, 100, 1);
	delay(4);
	Ceiling_CrushAndRaise(182, 64, 100, 1);
	
	// Other
	SpawnSpotForced("RedPoint", 88, TID_REMOVE, 0.0);
	Thing_remove(88);
	Thing_ChangeTID(TID_REMOVE, 88);
	
	if (!strcmp(GetCVarString("doomware_mode"), "halloween"))
	{
		SpawnSpotForced("OrangeTorch", 838, 0, 0);
		Thing_remove(838);
		SpawnSpotForced("OrangePoint", 147, TID_REMOVE, 0.0);
		Thing_remove(147);
		Thing_ChangeTID(TID_REMOVE, 147);
		ChangeSky("STSKY21", "");
		ChangeFloor(253, "WFLAVA1");
		ChangeFloor(256, "WFLAVA1");
		ChangeFloor(839, "FLATHLWN");
		ChangeFloor(856, "FLATHLWN");
		ChangeFloor(22, "TLITE6_8");
		SetLineTexture(89, SIDE_BACK, TEXTURE_BOTTOM , "N_BRGR16");
		ACS_NamedExecute("DoomWare_DoLightning", 0);
	}
	else
	{
		SpawnSpotForced("BluePoint", 147, TID_REMOVE, 0.0);
		Thing_remove(147);
		Thing_ChangeTID(TID_REMOVE, 147);
	}
}

str temp_hint[NUMBEROFHINTS];
Script "DoomWare_Server_InitHints" (void)
{
    temp_hint[0]  = "This WAD was created by \cqB\csU\cdU\cq3\cs4\cd2\c-, he has a skull over his head.";
	temp_hint[1]  = "Sunglasses are an important accessory for reducing damage from the Sun.";
	temp_hint[2]  = "Can't access the scoreboard? Change the bind in the options (at the very bottom) or bind +dwscores.";
	temp_hint[3]  = "OpenGL > Software";
    temp_hint[4]  = "If this is your first time playing DoomWare, I am so sorry for you.";
	temp_hint[5]  = "Some of these hints are useless.";
	temp_hint[6]  = "This WAD has over 9000 lines of ACS Code, and 4000 of Decorate.";
	temp_hint[7]  = "There is a 1UP mushroom hidden in many minigames.";
	temp_hint[8]  = "1UP Mushrooms give you an extra point.";
	temp_hint[9]  = "I've included the ZDaemon source code in this WAD.";
    temp_hint[10] = "The throwback minigames have anatomically correct HUDs made with ACS.";
	temp_hint[11] = "Dash Rendar > Han Solo";
	temp_hint[12] = "The creator of this WAD is Mastery 7 with old Urgot and Garen.";
	temp_hint[13] = "Anyone who recognizes most of the music is super cool.";
	temp_hint[14] = "This WAD was inspired by WarioWare, duh.";
	temp_hint[15] = "I think it's time to blow this scene, get everybody and the stuff together.";
	temp_hint[16] = "I don't remember hurting any priest... lately... that much...";
	temp_hint[17] = "This WAD is a celebration of my video games and everything I love, including other Doom WADs.";
	temp_hint[18] = "If I were a vegetable, I would be a couch potato.";
	temp_hint[19] = "Fast reactions and adaptability are the only way of surviving this next round.";
	temp_hint[20] = "There are currently 90 minigames in this WAD.";
	temp_hint[21] = "I am extremely thankful to some people for coming and testing this WAD so often. Love you guys <3";
	temp_hint[22] = "I tend to make spelling mistaeks.";
	temp_hint[23] = "Diddy Kong Racing's final boss is literally impossible.";
	temp_hint[24] = "This WAD has free custom skins that you can change in the options.";
	temp_hint[25] = "Chasecam should be enabled in the server. Use it!";
	temp_hint[26] = "If at first you don't succeed, try and try a gun.";
	temp_hint[27] = "The only way to win is to be an asshole to the lead players.";
	temp_hint[28] = "Dumbledore kills Snape.";
	temp_hint[29] = "Spoiler, after round 25 the game says 'Game Over'.";
	temp_hint[30] = "Griffith did nothing wrong.";
	temp_hint[31] = "When the game speeds up it both gets faster and harder.";
	temp_hint[32] = "Wanna help me out with making this WAD? Get in touch!";
	temp_hint[33] = "Comming Soon: Complex DoomWare vs Ghouls vs Megaman vs Unholy bosses - Push + Jumpmaze edition.";
	temp_hint[34] = "This WAD encourages and rewards suicide.";
	temp_hint[35] = "This WAD contains memes older than the average internet user.";
	temp_hint[36] = "Hissy Hogging was an inside job.";
	temp_hint[37] = "Press your jump button to jump.";
	temp_hint[38] = "I bet you can't spell Diarrhea.";
	temp_hint[39] = "If you can't read the scoreboard, stop playing Doom on an iPod. No one uses 320x200.";
	temp_hint[40] = "Watch those wrist rockets.";
	temp_hint[41] = "Boo!";
	temp_hint[42] = "Please don't sue me for using some music. You wouldn't hurt a pregnant man.";
	temp_hint[43] = "The Falador Massacre is a myth.";
	temp_hint[44] = "'0/5, bad map' - Anonymous @ doomworld.com/idgames";
	temp_hint[45] = "Fat people aren't real.";
	temp_hint[46] = "The racist jokes in this WAD are not racist.";
	temp_hint[47] = "Buying Girlfriend for 10k.";
	temp_hint[48] = "Need buddy to finish Shield of Arrav quest :(";
	temp_hint[49] = "Your ad here.";
	temp_hint[50] = "You lost the game.";
	temp_hint[51] = "Hey can I have a quote in your Doom thingy? - CougarMagnum";
	temp_hint[52] = "This WAD is ad free because no one likes headaches, just like Nurofen, eliminating them with ease!";
	temp_hint[53] = "A group of baboons is called a council.";
	temp_hint[54] = "Please stop asking me for feet pics, Jennifer.";
	temp_hint[55] = "This WAD may be sold to Korean gangsters.";
	temp_hint[56] = "Doom 3 is fun.";
	temp_hint[57] = "Did I ever tell you the definition of Insanity?";
	temp_hint[58] = "I finished Super Sonic Doom with a score of 2,282,450.";
	temp_hint[59] = "I beat Dark Souls 1 and 2.";
	temp_hint[60] = "Keikaku means plan.";
	temp_hint[61] = "*insert movie reference here*";
	temp_hint[62] = "Achievement Get!";
	temp_hint[63] = "ALL THESE SQUARES MAKE A CIRCLE.";
	temp_hint[64] = "I am hilarious and you will quote everything I say.";
	temp_hint[65] = "Some games have custom taunts. Use them!";
	temp_hint[66] = "Holding strafe and forward at the same time makes you move faster than just pressing forward.";
	temp_hint[67] = "Linguica is a Portuguese word so his keyboard is in Portuguese. Shut up and deal with it.";
	temp_hint[68] = "I am never detailing a keyboard ever again...";
	temp_hint[69] = "If you see this message, press F10 and Enter for a free point.";
	temp_hint[70] = "Alderaan shot first.";
	temp_hint[71] = "The 'reach the end' Shadows of the Empire minigame uses 32 polyobjects.";
	temp_hint[72] = "It only took me 8 years to finish Spacechem.";
	temp_hint[73] = "The player in first place has a rainbow icon above him. Go ruin his day.";
	temp_hint[74] = "So what do you think of Chubbs's man-boobies?";
	temp_hint[75] = "Died during a round? Press O to observe others playing, or bind +dwobserve.";
	temp_hint[76] = "One of my favorite shapes is the Great disnub dirhombidodecahedron.";
    temp_hint[77] = "Featuring Dante from the Devil May Cry series.";
    temp_hint[78] = "Players wearing Party Hats are wonderful beta testers :>";
    temp_hint[79] = "Players with a pink heart over their heads have played too much Doomware.";
    temp_hint[79] = "Players with a blue heart over their heads Unlocked all achievements. Wow!";
	temp_hint[80] = "You can scale the HUD using the DoomWare Menu, or the console command doomware_hudscale.";
	temp_hint[81] = "This WAD contains Berserk references.";

    // Shuffle the array of hints
    int i, j, k;
    for (i=0; i<NUMBEROFHINTS; i++)
	{
        j = random(i, NUMBEROFHINTS-1);
        k = temp_hint[i];
        temp_hint[i] = temp_hint[j];
        temp_hint[j] = k;
    }

    // Pick the first few hints
    for (i=0; i<MAXSPEEDUPS; i++)
        round_hints[i] = temp_hint[i];
}

int temp_allrounds[NUMBEROFGAMES];
Script "DoomWare_Server_InitRounds" (void)
{
    int i, j, k;
    game_roundnum = 1;
    game_speed = 0;
    game_over = OVER_NONE;

    // If we have enough rounds to not have repeats
    if (NUMBEROFGAMES >= MAXROUNDS)
    {
        // Create a temporary array with all the rounds
        for (i=0; i<NUMBEROFGAMES; i++)
            temp_allrounds[i] = i+1;

        // Shuffle the temp array
        for (i=0; i<NUMBEROFGAMES; i++)
        {
            j = random(i, NUMBEROFGAMES-1);
            k = temp_allrounds[i];
            temp_allrounds[i] = temp_allrounds[j];
            temp_allrounds[j] = k;
        }

        // Now copy the first MAXROUNDS elements onto our rounds array
        for (i=0; i<MAXROUNDS; i++)
            round_current[i] = temp_allrounds[i];
    }
    else // Otherwise just pick a bunch of games at random
    {
        for (i=0; i<MAXROUNDS; i++)
            round_current[i] = random(1, NUMBEROFGAMES);
    }
}

Script "DoomWare_Server_InitHighscores" (void)
{
	int i;
	for (i=0; i<MAXPLAYERS; i++)
    {
        game_highscores[i] = -1;
        game_highnames[i] = -1;
        game_score[i] = 0;
        player_achievement[i] = "";
    }
}


/*===================================================================================================
                                DoomWare Client Logic Initialization
===================================================================================================*/

Script "DoomWare_Client_Initialize" (void)
{
    // Wipe the player's Inventory and score
    clearinventory();
    game_score[PlayerNumber()] = 0;

    // Assign each player a TID, starting at 1337
	Thing_ChangeTID(0, TID_PLAYER+PlayerNumber());

    // Clean up the database and variables for this player
    data_deaths[PlayerNumber()] = 0;
    data_1ups[PlayerNumber()] = 0;
    player_achievement[PlayerNumber()] = "";
    player_wonround[PlayerNumber()] = false;
    minigame_instruction1[PlayerNumber()] = "";
    minigame_instruction2[PlayerNumber()] = "";
    minigame_instruction3[PlayerNumber()] = "";
    player_viewsprite[PlayerNumber()] = "";
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
    {
        player_wonround[PlayerNumber()] = false;
        player_midround[PlayerNumber()] = false;
        player_lostround[PlayerNumber()] = true;
    }
    else
    {
        player_midround[PlayerNumber()] = true;
        player_lostround[PlayerNumber()] = false;
    }

    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_ACHIEVEM, CR_CYAN, 0, 0, 1.0);


    // Check the player's role or warn if they're not logged in
    if (playerIsLoggedIn(PlayerNumber()))
        Load_PlayerDB(PlayerNumber());
    else
        data_role[PlayerNumber()] = ROLE_UNLOGGED;

    // If the server is full, give the achievement
    if (PlayerCount() == MAXPLAYERS)
        for (int i=0; i<MAXPLAYERS; i++)
            Give_Achievement(i, ACHIEVE_ID_FULLSERVER);

    // Fail the player for this round if they joined late
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
        Player_Lose(PlayerNumber(), true);
}


/*===================================================================================================
                                  DoomWare Server Main Logic
===================================================================================================*/

// Return true/false if we are speeding up
function bool Should_Speedup(void)
{
    switch (game_roundnum)
    {
        case SPEEDUP1: break;
        case SPEEDUP2: break;
        case SPEEDUP3: break;
        case SPEEDUP4: break;
        default: return false; break;
    }
    return true;
}

// Return true/false if we are playing a 1v1 tiebreaker
function bool Is_1v1_TieBreaker(void)
{
    return (game_highscores[0] == game_highscores[1] && game_highscores[0] != game_highscores[2]);
}

Script "DoomWare_Server_GameLogic" (void)
{
    // Initialize some global variables
	int i;
    round_winifmid = false;
    round_winifsuicide = false;
    round_noforceend = false;
	round_forceobservers = false;
    minigame_wincondition1 = 0;
    minigame_wincondition2 = 0;
    minigame_wincondition3 = 0;
    minigame_fragpoints = false;
    minigame_timer = TIMER_OFF;
    for (i=0; i<MAXPLAYERS; i++)
    {
        player_midround[i] = PlayerInGame(i);
        player_wonround[i] = false;
        player_lostround[i] = false;
    }

    // Stop the game if a solo match has more than one person
    if (game_solo && PlayerCount() > 1)
        game_over = OVER_JOIN;

	// Stop the game if a non solo match has only one person
	if (PlayerCount() < 2 && !game_solo)
		game_over = OVER_PLAYER;

    // Check if the game's over
    if (game_roundnum > MAXROUNDS || game_over != OVER_NONE)
    {
        game_speed = 0;

        // Check for ties
        if (game_highscores[0] == game_highscores[1] && !game_solo && game_over != OVER_FORCED)
        {
            game_status = STATUS_TIEDETECT;
            HUDMessage(s:"Tie!"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
			delay(MUSICDUR_TIEBREAK);
            game_status = STATUS_WAITING;
        }
        else
        {
            if (game_over == OVER_NONE)
            {
                if (!game_solo)
                    game_over = OVER_WINNER;
                else
                    game_over = OVER_WINNERSOLO;
            }

            game_status = STATUS_GAMEOVER;
            HUDMessage(s:"Game Over"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
			str printscore = "Final score tally:";
			for (i=0; i<MAXPLAYERS; i++)
				if (PlayerInGame(i))
					printscore = StrParam(s:printscore, s:"\n", d:game_highscores[i], s:" - ", n:game_highnames[i]+1);
			HUDMessage(s:printscore; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);

			delay(MUSICDUR_GAMEOVER);
            ACS_NamedExecute("DoomWare_Server_UpdateDB", 0);
            NamedScriptWait("DoomWare_Server_UpdateDB");
			ChangeLevel("map01", 0, 0, 0);
        }
    }

    // Wait a bit to play the round starting music (or warn that the game is speeding up)
    if (Should_Speedup() == true && game_roundnum <= MAXROUNDS)
    {
        game_speed++;
        game_status = STATUS_SPEEDUP;
        switch (game_roundnum)
        {
            case SPEEDUP1: delay(MUSICDUR_SPEEDUP1); break;
            case SPEEDUP2: delay(MUSICDUR_SPEEDUP2); break;
            case SPEEDUP3: delay(MUSICDUR_SPEEDUP3); break;
            case SPEEDUP4: delay(MUSICDUR_SPEEDUP4); break;
        }
    }
    else
    {
        game_status = STATUS_WAITING;

        // Calculate a tiebreaker beforehand to help lagging players
        if (Is_1v1_TieBreaker())
        {
            if (DEBUG_TIEB > 0)
                round_tiebreaker = DEBUG_TIEB;
            else
                round_tiebreaker = random(1, NUMBEROFTIEBREAKERS);
        }
        else
        {
            if (DEBUG_TIEBM > 0)
                round_tiebreaker = DEBUG_TIEBM;
            else
                round_tiebreaker = random(1, NUMBEROFTIEBREAKERSM);
        }

        // Wait until the music is done playing
        switch (game_speed)
        {
            case 0: delay(MUSICDUR_WAIT1); break;
            case 1: delay(MUSICDUR_WAIT2); break;
            case 2: delay(MUSICDUR_WAIT3); break;
            case 3: delay(MUSICDUR_WAIT4); break;
            case 4: delay(MUSICDUR_WAIT5); break;
        }
    }

    // If not a tiebreaker
    str gametoplay;
    if (game_roundnum <= MAXROUNDS)
    {
        // Select the minigame to play
        game_status = STATUS_MINIGAME;
        if (DEBUG_GAME > 0)
            round_current[game_roundnum-1] = DEBUG_GAME;
        gametoplay = StrParam(s:"DoomWare_Server_Minigame", d:round_current[game_roundnum-1]);
    }
    else
    {
        minigame_canmove = false;

        if (Is_1v1_TieBreaker())
        {
            game_status = STATUS_TIEBREAK;
            gametoplay = StrParam(s:"DoomWare_Server_TieBreaker", d:round_tiebreaker);
        }
        else
        {
            game_status = STATUS_TIEBREAKM;
            gametoplay = StrParam(s:"DoomWare_Server_TieBreakerM", d:round_tiebreaker);
        }
    }
    ACS_NamedExecute(gametoplay, 0);

    // Wait until the minigame is over
    NamedScriptWait(gametoplay);

    // Stop any music
    SetMusic("");

    // Cleanup entities marked for death and clear the observers array
    ACS_NamedExecute("DoomWare_Entity_Cleanup", 0);
    ACS_NamedExecute("DoomWare_Server_ClearObservers", 0);

    // Announce the winners
    game_status = STATUS_WINLOSE;
    delay(MUSICDUR_WINLOSE-(7*game_speed));
    game_roundnum++;

    // Restart this script
    restart;
}

function bool No_MidRound_Array(void) // Return whether everyone has passed/failed
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (player_midround[i] != false && PlayerInGame(i))
            return false;
    return true;
}

function void Player_Win(int plynum) // Make a player win
{
    if (player_midround[plynum] == true)
    {
        SetActivator(TID_PLAYER+plynum);
        LocalAmbientSound("DoomWare/Check", 127);
        SpawnSpotForced("WonRoundEffect", TID_PLAYER+plynum, 0, 0);
        player_wonround[plynum] = true;
        player_midround[plynum] = false;
    }
}

function void Player_Lose(int plynum, bool silent) // Make a player lose
{
    if (player_midround[plynum] == true)
    {
        // Make the sound + effects
        if (!silent)
        {
            SetActivator(TID_PLAYER+plynum);
            LocalAmbientSound("DoomWare/Failure", 127);
            SpawnSpotForced("FailedRoundEffect", TID_PLAYER+plynum, 0, 0);
        }
        player_lostround[plynum] = true;
        player_midround[plynum] = false;

        // If in a 1v1 tiebreaker, make the other player win
        if (game_status == STATUS_TIEBREAK)
        {
            if (plynum == game_highnames[0])
            {
                Player_Win(game_highnames[1]);
                Give_Achievement(game_highnames[1], ACHIEVE_ID_1v1WIN);
            }
            else if (plynum == game_highnames[1])
            {
                Player_Win(game_highnames[0]);
                Give_Achievement(game_highnames[0], ACHIEVE_ID_1v1WIN);
            }
        }
    }
}

Script "DoomWare_Server_GameWait" (int time)
{
    int time_passed;
    minigame_timer = time;
    while (time_passed < time)
    {
        delay(1);
        time_passed++;
        minigame_timer--;

        // Stop if everyone has already passed/died
        if (No_MidRound_Array() && !round_noforceend)
        {
            if (time - time_passed < SECOND)
                delay(time - time_passed);
            else
            {
                minigame_timer = TIMER_EARLY;
                delay(SECOND);
            }
            break;
        }
    }
    minigame_timer = TIMER_OFF;
}

Script "DoomWare_Server_SavePlayerPositions" (void)
{
    for (int i=0; i<MAXPLAYERS; i++)
    {
        // Don't bother if the player doesn't exist
        if (!PlayerInGame(i))
            continue;

        // Get all player positions
        player_position[i][0] = GetActorX(TID_PLAYER+i);
        player_position[i][1] = GetActorY(TID_PLAYER+i);
        player_position[i][2] = GetActorZ(TID_PLAYER+i);
    }
}

Script "DoomWare_Server_TeleportPlayers" (int tid, int telesector, int fog)
{
	int i;
	
	// Randomize the destinations if we're not using telesector
	if (telesector == 0)
	{
		for (i=0; i<MAXPLAYERS; i++)
			player_teleporter[i] = tid+i;

		int j, k;
		for (i=0; i<MAXPLAYERS; i++)
		{
			j = random(i, MAXPLAYERS-1);
			k = player_teleporter[i];
			player_teleporter[i] = player_teleporter[j];
			player_teleporter[j] = k;
		}
	}

	// Teleport everyone
    for (i=0; i<MAXPLAYERS; i++)
    {
        // Don't bother if the player doesn't exist
        if (!PlayerInGame(i))
            continue;

        // Get all player positions
        player_position[i][0] = GetActorX(TID_PLAYER+i);
        player_position[i][1] = GetActorY(TID_PLAYER+i);
        player_position[i][2] = GetActorZ(TID_PLAYER+i);

        if (!telesector)
        {
            Thing_Move(TID_PLAYER+i, player_teleporter[i], !fog); // Move to an individual TID
        }
        else
        {
            TeleportInSector(2, 1, tid, fog, TID_PLAYER+i);  // Move them using a single TID
			TeleportInSector(17, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(19, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(20, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(21, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(22, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(23, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(24, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(25, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(39, 1, tid, fog, TID_PLAYER+i);
			TeleportInSector(44, 1, tid, fog, TID_PLAYER+i);
        }
    }

	// Reduce everyone's speed and fix their angles
	delay(1);
	if (fog)
	{
		for (i=0; i<MAXPLAYERS; i++)
		{
			// Don't bother if the player doesn't exist
			if (!PlayerInGame(i))
				continue;

			SetActorPitch(TID_PLAYER+i, 0.0);
			if (telesector)
				SetActorAngle(TID_PLAYER+i, GetActorAngle(tid));
			else
				SetActorAngle(TID_PLAYER+i, GetActorAngle(player_teleporter[i]));
			SetActorVelocity(TID_PLAYER+i, 0.0, 0.0, 0.0, false, false);
		}
	}

	// Retry for anyone who was not teleported due to telefragging prevention
	for (i=0; i<MAXPLAYERS; i++)
    {
		// Don't bother if the player doesn't exist
		if (!PlayerInGame(i))
			continue;

		while (Distance(TID_PLAYER+i, 1) < 512)
		{
			if (!telesector)
			{
				Thing_Move(TID_PLAYER+i, player_teleporter[i], !fog); // Move to an individual TID
			}
			else
			{
				TeleportInSector(2, 1, tid, fog, TID_PLAYER+i);  // Move them using a single TID
				TeleportInSector(17, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(19, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(20, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(21, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(22, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(23, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(24, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(25, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(39, 1, tid, fog, TID_PLAYER+i);
				TeleportInSector(44, 1, tid, fog, TID_PLAYER+i);
			}
			delay(1);

			if (fog)
			{
				SetActorPitch(TID_PLAYER+i, 0.0);
				if (telesector)
					SetActorAngle(TID_PLAYER+i, GetActorAngle(tid));
				else
					SetActorAngle(TID_PLAYER+i, GetActorAngle(player_teleporter[i]));
				SetActorVelocity(TID_PLAYER+i, 0.0, 0.0, 0.0, false, false);
			}
		}
	}
}

Script "DoomWare_Server_TeleportSingle" (int plynum, int dest)
{
    player_position[plynum][0] = GetActorX(TID_PLAYER+plynum);
    player_position[plynum][1] = GetActorY(TID_PLAYER+plynum);
    player_position[plynum][2] = GetActorZ(TID_PLAYER+plynum);
    Thing_Move(TID_PLAYER+plynum, dest, false);
	SetActorPitch(TID_PLAYER+plynum, 0.0);
    SetActorAngle(TID_PLAYER+plynum, GetActorAngle(dest));
}

Script "DoomWare_Server_ReturnPlayers" (int move_if_lost, int fog)
{
    for (int i=0; i<MAXPLAYERS; i++)
	{
		if (!PlayerInGame(i))
			continue;

		// Move the player back to their original spot
        if ((!move_if_lost && !player_lostround[i]) || move_if_lost)
            SetActorPosition(TID_PLAYER+i, player_position[i][0], player_position[i][1], player_position[i][2], fog);

		// If for some reason they're not at the spawn, force them back to the center
		while (Distance(TID_PLAYER+i, 1) > 512)
		{
			SetActorPosition(TID_PLAYER+i, GetActorX(1), GetActorY(1), GetActorZ(1), fog);
			delay(1);
		}
	}
}

function void Check_LMS(void)
{
    int alivecount = 0;
    int winid = -1;
    for (int i=0; i<MAXPLAYERS; i++)
    {
        if (player_midround[i])
        {
            winid = i;
            alivecount++;
        }
    }

    // If only one person is alive, make them win and give them the achievement
    if (alivecount == 1)
        Player_Win(winid);
}

function void Check_LMS_MVMTie(void)
{
    int alivecount = 0;
    int winid = -1;
    for (int i=0; i<MAXPLAYERS; i++)
    {
        if (player_midround[i])
        {
            winid = i;
            alivecount++;
        }
    }

    // If only one person is alive, make them win and give them the achievement
    if (alivecount == 1)
    {
        Player_Win(winid);
        Give_Achievement(winid, ACHIEVE_ID_MVMWIN);
    }
}

Script "DoomWare_Server_UpdateDB" (void)
{
    int i;

    // Don't update if it was a solo game
    if (game_solo)
        terminate;

    // Check for people who have played too much DoomWare
    for (i=0; i<MAXPLAYERS; i++)
        if (playerIsLoggedIn(i) && playerInGame(i) && data_role[i] == ROLE_NONE)
            if (GetDBEntry("Points", getPlayerAccountName(i)) + game_score[i] >= 300)
                data_role[i] = ROLE_REGULAR;

    // Begin the Database Transaction
    BeginDBTransaction();

    for (i=0; i<MAXPLAYERS; i++)
        if (playerIsLoggedIn(i) && playerInGame(i))
        {
            // Log the wins
            SetDBEntry("Wins", getPlayerAccountName(i), data_wins[i]);

            // Log the total points
            incrementDBEntry("Points", getPlayerAccountName(i), game_score[i]);

            // Log the number of deaths
            SetDBEntry("Deaths", getPlayerAccountName(i), data_deaths[i]);

            // Log the number of 1ups caught
            SetDBEntry("1Ups", getPlayerAccountName(i), data_1ups[i]);

            // Log the achievements
            SetDBEntry("Achievements", getPlayerAccountName(i), data_achieve[i]);

            // Log the player's roles
            SetDBEntry("Role", getPlayerAccountName(i), data_role[i]);
        }

    // Update the Database
    EndDBTransaction();
    delay(1);
}

Script "DoomWare_Server_InitGlobals" (void)
{
    for (int i=0; i< MAXPLAYERS; i++)
    {
        game_score[i] = 0;
        data_points[i] = 0;
        data_wins[i] = 0;
        data_deaths[i] = 0;
        data_1ups[i] = 0;
        data_role[i] = 0;
        data_achieve[i] = 0;
        player_lostround[i] = 0;
        player_viewingmenu[i] = 0;
        minigame_instruction1[i] = "";
        minigame_instruction2[i] = "";
        minigame_instruction3[i] = "";
        player_viewsprite[i] = "";
        player_wonround[i] = false;
        player_midround[i] = false;
        player_lostround[i] = false;
    }

    SetCVar("__clientsync_round", 0);
    SetCVar("__clientsync_gamestatus", 0);
    SetCVar("__clientsync_gameover", 0);
    SetCVar("__clientsync_minigametimer", 0);
    SetCVar("__clientsync_highscore1", 0);
    SetCVar("__clientsync_highscore2", 0);
    SetCVar("__clientsync_canobserve", 0);
    SetCVar("__clientsync_canmove", 0);
    SetCVar("__clientsync_gamesolo", 0);
    SetCVar("__clientsync_wincondition1", 0);
    SetCVar("__clientsync_roundcurrent", 0);
    SetCVarString("__clientsync_highname", "");
    SetCVarString("__clientsync_speeduphint", "");

    SetCVarString("__clientsync_player_score", "");
    SetCVarString("__clientsync_player_loggedin", "");
    SetCVarString("__clientsync_player_datascore", "");
    SetCVarString("__clientsync_player_datawins", "");
    SetCVarString("__clientsync_player_datadeaths", "");
    SetCVarString("__clientsync_player_data1ups", "");
    SetCVarString("__clientsync_player_dataroles", "");
    SetCVarString("__clientsync_player_dataachieve", "");
    SetCVarString("__clientsync_player_checklost", "");
    SetCVarString("__clientsync_player_lostround", "");
    SetCVarString("__clientsync_player_viewingmenu", "");
    SetCVarString("__clientsync_player_instruction1", "");
    SetCVarString("__clientsync_player_instruction2", "");
    SetCVarString("__clientsync_player_instruction3", "");
    SetCVarString("__clientsync_player_viewsprite", "");
}

Script "DoomWare_Server_SyncGlobals" (void)
{
    /*
        Why on earth are global variables not synced between the server and
        CLIENTSIDE scripts??? Pretty much every single game engine I've worked on
        At least gives me the option of marking a variable as "Syncable" to the
        client...
    */
    str leadname = StrParam(n:(game_highnames[0]+1));
    Player_SetCVar("__clientsync_round", game_roundnum);
    Player_SetCVar("__clientsync_gamestatus", game_status);
    Player_SetCVar("__clientsync_gameover", game_over);
    Player_SetCVar("__clientsync_minigametimer", minigame_timer);
    Player_SetCVar("__clientsync_wincondition1", minigame_wincondition1);
    Player_SetCVar("__clientsync_highscore1", game_highscores[0]);
    Player_SetCVar("__clientsync_highscore2", game_highscores[1]);
    Player_SetCVarString("__clientsync_highname", leadname);
    Player_SetCVarString("__clientsync_speeduphint", round_hints[game_speed-1]);
    Player_SetCVar("__clientsync_canobserve", minigame_canobserve);
    Player_SetCVar("__clientsync_canmove", minigame_canmove);
    Player_SetCVar("__clientsync_gamesolo", game_solo);
    Player_SetCVar("__clientsync_roundcurrent", round_current[game_roundnum-1]);

    Pack_Global_Array("__clientsync_player_score");
    Pack_Global_Array("__clientsync_player_loggedin");
    Pack_Global_Array("__clientsync_player_datascore");
    Pack_Global_Array("__clientsync_player_datawins");
    Pack_Global_Array("__clientsync_player_datadeaths");
    Pack_Global_Array("__clientsync_player_data1ups");
    Pack_Global_Array("__clientsync_player_dataroles");
    Pack_Global_Array("__clientsync_player_dataachieve");
    Pack_Global_Array("__clientsync_player_checklost");
    Pack_Global_Array("__clientsync_player_lostround");
    Pack_Global_Array("__clientsync_player_viewingmenu");
    Pack_Global_Array("__clientsync_player_instruction1");
    Pack_Global_Array("__clientsync_player_instruction2");
    Pack_Global_Array("__clientsync_player_instruction3");
    Pack_Global_Array("__clientsync_player_viewsprite");

    delay(1);
    restart;
}

function void Player_SetCVar(str cvar, int value) // Efficient SetCVar function
{
    if (GetCVar(cvar) != value)
        SetCVar(cvar, value);
}

function void Player_SetCVarString(str cvar, str value) // Efficient SetCVarString function
{
    if (GetCVarString(cvar) != value)
        SetCVarString(cvar, value);
}

function void Player_SetCVarStringPacked(str cvar, str value) // Efficient SetCVarString function
{
    if (GetCVarString(cvar) != value)
        SetCVarString(cvar, value);
}

function void Pack_Global_Array(str cvar) // Replacement for Get/SetUserCVar
{
    /*
        Since GetUserCVar is broken on Zandornum, instead I fill everyone's data into a single
        string and make it a server cvar. A new line represents a different player, so the data
        in line 3 of the string corresponds to the data of PlayerNumber() == 3
    */
    int i;
    str final = "";

         if (!StrCmp(cvar, "__clientsync_player_score"))        for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:game_score[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_loggedin"))     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:PlayerIsLoggedIn(i), s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_datascore"))    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_points[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_datawins"))     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_wins[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_datadeaths"))   for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_deaths[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_data1ups"))     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_1ups[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_dataroles"))    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_role[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_dataachieve"))  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_achieve[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_checklost"))    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:Check_Player_Lost(i), s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_lostround"))    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:player_lostround[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_viewingmenu"))  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:player_viewingmenu[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_instruction1")) for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction1[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_instruction2")) for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction2[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_instruction3")) for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction3[i], s:"\n");
    else if (!StrCmp(cvar, "__clientsync_player_viewsprite"))   for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:player_viewsprite[i], s:"\n");

    if (GetCVarString(cvar) != final)
        SetCVarString(cvar, final);
}

function int Unpack_CVar_Array(str cvar) // Retrieve the value of a Pack_Global_Array CVar and convert it to int.
{
    str data = GetCVarString(cvar);
    int datalen = StrLen(data);

    int start = 0;
    int linecount = 0;

    for (int i=0; i<datalen; i++)
    {
        if (GetChar(data, i) == '\n')
        {
            if (linecount == ConsolePlayerNumber())
            {
                data = StrMid(data, start, i-start);
                break;
            }
            else
            {
                start = i+1;
                linecount++;
            }

        }
    }
    return AToI(data);
}

function str Unpack_CVar_Array_String(str cvar) // Retrieve the value of a Pack_Global_Array CVar and convert it to string.
{
    str data = GetCVarString(cvar);
    int datalen = StrLen(data);

    int start = 0;
    int linecount = 0;

    for (int i=0; i<datalen; i++)
    {
        if (GetChar(data, i) == '\n')
        {
            if (linecount == ConsolePlayerNumber())
            {
                data = StrMid(data, start, i-start);
                break;
            }
            else
            {
                start = i+1;
                linecount++;
            }

        }
    }
    return data;
}


/*===================================================================================================
                                  DoomWare Client Main Logic
===================================================================================================*/

Script "DoomWare_Client_Death" DEATH
{
    if ((game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM))
    {
        if (!round_winifsuicide)
        {
            Player_Lose(PlayerNumber(), false);
            data_deaths[PlayerNumber()]++;
            if (data_deaths[PlayerNumber()] == 100)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_100DEATH);
        }
        else
            Player_Win(PlayerNumber());
    }

	// Spawn a spoopy ghost
	if (!strcmp(GetCVarString("doomware_mode"), "halloween"))
		SpawnSpotForced("SpoopyGhost", TID_PLAYER+PlayerNumber(), TID_REMOVE, 0);

	// Remove the player's TID if they're dead (to prevent corpses from emitting effects)
	if (GetActorProperty(TID_PLAYER+PlayerNumber(), APROP_HEALTH) <= 0)
		Thing_ChangeTID(TID_PLAYER+PlayerNumber(), 0);
}

Script "DoomWare_Client_Disconnect" (int gone) DISCONNECT
{
    // Wipe all messages
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_SCORE, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_ROUND, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_LEADER, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_SPREAD, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWHS, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSBACK, CR_WHITE, 0.5, 0.3, 1);

    // Reset that player's score and data
    game_score[gone] = 0;
    data_points[gone] = 0;
    data_wins[gone] = 0;
    data_deaths[gone] = 0;
    data_1ups[gone] = 0;
    data_role[gone] = ROLE_UNLOGGED;
    data_achieve[gone] = 0;

	// Stop the game if there aren't enough players
	if (game_status != STATUS_NOTSTARTED)
	{
		// End the game if we ran out of players
		if (PlayerCount() < 2 && !game_solo)
			game_over = OVER_PLAYER;

		// Force change map if there are no players
		if (PlayerCount() == 0)
			ChangeLevel("map01", 0, 0, 0);
	}
}

Script "DoomWare_Client_Respawn" RESPAWN
{
	thing_changetid(0, TID_PLAYER+PlayerNumber());
    player_observe[PlayerNumber()] = 0;
    clearinventory();
}

Script "DoomWare_Client_GameLogic" (void)
{
	str extra = "";
	if (!strcmp(GetCVarString("doomware_mode"), "halloween"))
		extra = "Halloween/";
	
    // Announce Win/Lose
    if (game_status == STATUS_WINLOSE)
    {		
        // Reset the player
        SetActorProperty(TID_PLAYER+PlayerNumber(), APROP_Health, 100);
        player_answer1[PlayerNumber()] = 0;
        player_answer2[PlayerNumber()][0] = 0;
        player_answer2[PlayerNumber()][1] = 0;
        player_answer2[PlayerNumber()][2] = 0;
        player_answer2[PlayerNumber()][3] = 0;
        player_viewsprite[PlayerNumber()] = "";
        ClearInventory();
        setplayerproperty(1, 0, prop_invulnerability);
        setplayerproperty(1, 0, prop_frozen);
        setplayerproperty(1, 0, PROP_FLY);

        // Check if player lost
        if (Check_Player_Lost(PlayerNumber()))
        {
            // Play music depending on the speed
            if (player_musicwinlose[PlayerNumber()] == false && GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_speed)
                {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Fail"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Fail", d:game_speed+1), 127); break;
                }
                player_musicwinlose[PlayerNumber()] = true;
            }
        }
        else
        {
            // Play music depending on the speed
            if (player_musicwinlose[PlayerNumber()] == false)
            {
                if (GetUserCVar(PlayerNumber(), "doomware_music"))
                {
                    switch (game_speed)
                    {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Win"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Win", d:game_speed+1), 127); break;
                    }
                }
                game_score[PlayerNumber()]++;
                player_musicwinlose[PlayerNumber()] = true;
                if (data_points[PlayerNumber()]+game_score[PlayerNumber()] >= 300)
                    Give_Achievement(PlayerNumber(), ACHIEVE_ID_300POINTS);
            }
        }
    }

    // Check if a tiebreaker has started
    if (game_status == STATUS_TIEDETECT && player_musicgameover[PlayerNumber()] == false && GetUserCVar(PlayerNumber(), "doomware_music"))
    {
        // Play the tie warning music
        LocalAmbientSound("DoomWare/TieBreaker", 127);
        player_musicgameover[PlayerNumber()] = true;
    }

    // Check if the game's over
    if (game_status == STATUS_GAMEOVER)
    {
        // Play the game over music
        if (player_musicgameover[PlayerNumber()] == false)
        {
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
                LocalAmbientSound("DoomWare/GameOver", 127);
            player_musicgameover[PlayerNumber()] = true;

            // Give the achievement if the player's score is 25 or more
            if (game_score[PlayerNumber()] >= 25)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_25POINTS);
        }

        // If the game ended normally
        if (game_over == OVER_WINNER)
        {
            // Award the winner with a BFG
            if (game_score[PlayerNumber()] == game_highscores[0] && !CheckInventory("BFG9000"))
            {
                GiveInventory("BFG9000", 1000);
                GiveInventory("Cell", 1000);
                SetWeapon("BFG9000");
                data_wins[PlayerNumber()]++;
                switch (data_wins[PlayerNumber()])
                {
                    case 1:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_1WIN);
                        break;
                    case 10:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_10WIN);
                        break;
                    case 100:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_100WIN);
                        break;
                }
            }
        }

    }

    // Play Waiting/Speedup music
    if (player_musicwaiting[PlayerNumber()] == false)
    {
        // Check if the game is speeding up
        if (game_status == STATUS_SPEEDUP)
        {
            // Play the speedup music, depending on the speed
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_roundnum)
                {
                    case SPEEDUP1: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup"), 127); break;
                    case SPEEDUP2: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup2"), 127); break;
                    case SPEEDUP3: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup3"), 127); break;
                    case SPEEDUP4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup4"), 127); break;
                }
            }
            player_musicwaiting[PlayerNumber()] = true;
            player_musicgameover[PlayerNumber()] = false;
        }
        else if (game_status == STATUS_WAITING)
        {
            // Play the waiting music
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_speed)
                {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Intro"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Intro", d:game_speed+1), 127); break;
                }
            }
            player_musicwaiting[PlayerNumber()] = true;
            player_musicgameover[PlayerNumber()] = false;
        }
    }

    // Play a minigame
    str gametoplay;
    if (game_status == STATUS_MINIGAME)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_Minigame", d:round_current[game_roundnum-1]);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Play a 1v1 Tiebreaker
    if (game_status == STATUS_TIEBREAK)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_TieBreaker", d:round_tiebreaker);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Play a non 1v1 Tiebreaker
    if (game_status == STATUS_TIEBREAKM)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_TieBreakerM", d:round_tiebreaker);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Wait until the round's over
    int fragsmade = 0;
    while (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
    {
        // Give a 1Up if we got a frag
        if (player_frags[PlayerNumber()] < PlayerFrags() && minigame_fragpoints)
        {
            GiveInventory("1up", 1);
            fragsmade++;
            player_frags[PlayerNumber()] = PlayerFrags();
            LocalAmbientSound("DoomWare/1up", 127);

            // Award an achievement if we got 3 frags
            if (fragsmade >= 3)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_3FRAGS);
        }

        // Give points if we ate a 1UP
        if (CheckInventory("1up") > 0)
        {
            game_score[PlayerNumber()]++;
            data_1ups[PlayerNumber()]++;
            TakeInventory("1up", 1000);
            SpawnSpotForced("1UPText", PlayerNumber()+TID_PLAYER, 0, 0);
            if (data_1ups[PlayerNumber()] == 50)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_501UPS);
        }
        delay(1);
    }

    // Clear out the minigame instructions
    minigame_instruction1[PlayerNumber()] = "";
    minigame_instruction2[PlayerNumber()] = "";
    minigame_instruction3[PlayerNumber()] = "";

    delay(1);
    if (PlayerInGame(PlayerNumber()) && !PlayerIsSpectator(PlayerNumber())) // Unless the player disconnected
        restart;
}

function bool Check_Player_Lost(int plynum)
{
    return (player_lostround[plynum] || (player_midround[plynum] && !round_winifmid));
}


/*===================================================================================================
                                            DoomWare HUD
===================================================================================================*/

Script "DoomWare_Client_DrawHUD" (void) CLIENTSIDE
{
    // Make sure only the person who called it actually sees the HUD
    if (ConsolePlayerNumber() != PlayerNumber())
        terminate;

    int plynum = ConsolePlayerNumber();
    SetActivator(TID_PLAYER+plynum);

    // Open the menu if this is the player's first time joining
    if (GetUserCVar(plynum, "__doomware_firstjoin") == true)
    {
        SetUserCVar(plynum, "__doomware_firstjoin", false);
        RequestScriptPuke(999);
    }

    // Initialize the hud
    int w = GetScreenWidth();
    int h = GetScreenHeight();
    str hudsprite;
    if (GetUserCVar(plynum, "doomware_hudscale"))
    {
        w = 800;
        h = 600;
    }
    SetHudSize(w, h, true);
    w = w << 16;
    h = h << 16;

    bool remind_login = true;
    int hud_toppos  = 0.0;
    int hud_botpos  = h+64.0;
    int hud_spindex = 0;
    int hud_time    = 0;
    int lasttimertime   = -1;
    if (GetCvar("__clientsync_gamestatus") <= STATUS_STARTING)
        hud_toppos = -95.0;

    while (1)
    {
        w = GetScreenWidth();
        h = GetScreenHeight();
        if (GetUserCVar(plynum, "doomware_hudscale"))
        {
            w = 800;
            h = 600;
        }
        SetHudSize(w, h, true);
        w = w << 16;
        h = h << 16;

        // Obtain the value of all global variables
        int syncdata_gamestatus = GetCvar("__clientsync_gamestatus");
        int syncdata_gameover = GetCvar("__clientsync_gameover");
        int syncdata_highscore1 = GetCvar("__clientsync_highscore1");
        int syncdata_highscore2 = GetCvar("__clientsync_highscore2");
        int syncdata_wincondition1 = GetCvar("__clientsync_wincondition1");
        str syncdata_highname = GetCVarString("__clientsync_highname");
        str syncdata_insctruction1 = Unpack_CVar_Array_String("__clientsync_player_instruction1");
        str syncdata_insctruction2 = Unpack_CVar_Array_String("__clientsync_player_instruction2");
        str syncdata_insctruction3 = Unpack_CVar_Array_String("__clientsync_player_instruction3");
        str syncdata_hint = GetCVarString("__clientsync_speeduphint");
        str syncdata_gamesolo = GetCvar("__clientsync_gamesolo");
        str syncdata_roundnum = GetCvar("__clientsync_round");
        str syncdata_canobserve = GetCvar("__clientsync_canobserve");
        str syncdata_timer = GetCvar("__clientsync_minigametimer");
        str syncdata_roundcurrent = GetCvar("__clientsync_roundcurrent");

        int syncdata_score = Unpack_CVar_Array("__clientsync_player_score");
        str syncdata_checklost = Unpack_CVar_Array("__clientsync_player_checklost");
        str syncdata_lostround = Unpack_CVar_Array("__clientsync_player_lostround");
        str syncdata_loggedin = Unpack_CVar_Array("__clientsync_player_loggedin");
        str syncdata_viewsprite = Unpack_CVar_Array_String("__clientsync_player_viewsprite");


        /*==============================
                 Center Text
        ==============================*/

        // Move the top of the HUD stuff downwards if game is ready
        if (syncdata_gamestatus >= STATUS_STARTING && hud_toppos < 0)
        {
            // Make some sounds
            if (hud_toppos == -92.0 && GetUserCVar(plynum, "doomware_huddynamic") && GetUserCVar(plynum, "doomware_hudsounds"))
                LocalAmbientSound("DoomWare/HUDMove", 127);

            // Move the hud
            if (GetUserCVar(plynum, "doomware_huddynamic"))
                hud_toppos += 1.0;
            else
                hud_toppos = 0;
        }

        SetFont("DW_FONT4");
        if (syncdata_gamestatus == STATUS_NOTSTARTED) // State that we're waiting for players
        {
            HUDMessage(s:"Waiting for Players"; HUDMSG_PLAIN, MSGID_CENTER, CR_PURPLE, w/2, FixedMul(h, 0.25), 1);
            SetFont("DW_FONT5");
            HUDMessage(s:"\n\nOr Press ", k:"+dwscores", s:" to start a game by yourself"; HUDMSG_PLAIN, MSGID_CENTER2, CR_PURPLE, w/2, FixedMul(h, 0.25) + 4.0, 1);
            HUDMessage(s:"\n\n\n\nWarning: Most Minigames are designed with 2+ players in mind and stats won't be tracked!"; HUDMSG_PLAIN, MSGID_CENTER3, CR_RED, w/2, FixedMul(h, 0.25) + 4.0, 1);
        }
        else if (syncdata_gamestatus == STATUS_STARTING) // We're ready to go
        {
            HUDMessage(s:"READY TO PLAY!"; HUDMSG_PLAIN, MSGID_CENTER, CR_PURPLE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
        }
        else if (syncdata_gamestatus == STATUS_SPEEDUP)
        {
            // Announce the speedup, and select a hint from the pile
            HUDMessage(s:"Speed Up"; HUDMSG_PLAIN, MSGID_CENTER, CR_BLUE, w/2, FixedMul(h, 0.25), 1);
            SetFont("DW_FONT5");
            HUDMessage(s:syncdata_hint; HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);

            // Do animation stuff for the HIUD
            hud_time += 1;
            if (hud_time > SECOND/4)
            {
                hud_time = 0;
                hud_spindex = (hud_spindex + 1)%2;
            }
        }
        else if (syncdata_gamestatus == STATUS_WINLOSE)
        {
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_GREEN, 0.5, 0.3, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);

            // Do animation stuff for the HIUD
            hud_time += 1;
            if (hud_time > SECOND/4)
            {
                hud_time = 0;
                hud_spindex = (hud_spindex + 1)%3;
            }

            // Check if player lost
            if (syncdata_checklost == 1)
                HUDMessage(s:"You Failed!"; HUDMSG_PLAIN, MSGID_CENTER, CR_RED, w/2, FixedMul(h, 0.25), 1);
            else
                HUDMessage(s:"You Won!"; HUDMSG_PLAIN, MSGID_CENTER, CR_GREEN, w/2, FixedMul(h, 0.25), 1);
        }
        else if (syncdata_gamestatus == STATUS_TIEDETECT)
        {
            HUDMessage(s:"Game Over"; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\nThere is a tie, intitializing Tie Breaker round."; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);
        }
        else if (syncdata_gamestatus == STATUS_GAMEOVER)
        {
            HUDMessage(s:"Game Over"; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_GREEN, 0.5, 0.3, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);

            // State why the game ended
            switch (syncdata_gameover)
            {
                case OVER_WINNER:
                    HUDMessage(s:"\n\nThe winner is ", s:syncdata_highname, s:" with ", d:syncdata_highscore1, s:" points"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERSOLO:
                    if (syncdata_score != 1)
                        HUDMessage(s:"\n\nYou scored ", d:syncdata_score, s:" points"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    else
                        HUDMessage(s:"\n\nYou scored 1 point"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_PLAYER:
                    HUDMessage(s:"\n\nThere are not enough players"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_FORCED:
                    HUDMessage(s:"\n\nThe game was forcefully ended"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_JOIN:
                    HUDMessage(s:"\n\nA new player has entered the game"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
            }
        }
        else if (syncdata_gamestatus == STATUS_MINIGAME || syncdata_gamestatus == STATUS_TIEBREAK || syncdata_gamestatus == STATUS_TIEBREAKM)
        {
            HUDMessage(s:syncdata_insctruction1; HUDMSG_PLAIN, MSGID_CENTER, CR_ORANGE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\n", s:syncdata_insctruction2; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\n\n\n", s:syncdata_insctruction3; HUDMSG_PLAIN, MSGID_CENTER3, CR_RED, w/2, FixedMul(h, 0.25), 1);
        }
        else
        {
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
        }


        /*==============================
                 HUD Animation
        ==============================*/

        if (syncdata_gamestatus == STATUS_WINLOSE && GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (syncdata_checklost == 0)
                hudsprite = StrParam(s:"WIN", d:(hud_spindex+1));
            else
                hudsprite = "FAIL";
        }
        else if (syncdata_gamestatus == STATUS_SPEEDUP && GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (hud_spindex == 0)
                hudsprite = "SPED";
            else
                hudsprite = "OFF";
        }
        else
            hudsprite = "OFF";


        /*==============================
               Leader and Spread
        ==============================*/

        if (syncdata_gamesolo == 0)
        {
            // Background
            SetFont(StrParam(s:"HUD2", s:hudsprite));
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_LEADER2, CR_PURPLE, w/2, hud_toppos + 0.1, 1);

            if (syncdata_gamestatus > STATUS_STARTING)
            {
                // Leader
                SetFont("DW_FONT1");
                if (syncdata_highscore1 == syncdata_highscore2)
                    HUDMessage(s:"There are multiple leaders"; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);
                else
                    HUDMessage(s:syncdata_highname; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);

                // Spread
                SetFont("DW_FONT3");
                if (syncdata_highscore2 < syncdata_score|| syncdata_highscore1 == syncdata_score)
                    HUDMessage(s:"+", d:(syncdata_score-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                else
                    HUDMessage(s:"-", d:(syncdata_highscore1-syncdata_score); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);

                // Remind people that they can view the highscore table
                if (GetUserCVar(plynum, "doomware_hudshowbinds"))
                    HUDMessage(s:"\n\n\nPress ", k:"+dwscores", s:" to view the Highscore table"; HUDMSG_PLAIN, MSGID_VIEWHS, CR_ORANGE, w/2, hud_toppos+64.0 + 0.1, 1);
                else
                    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWHS, CR_ORANGE, w/2, hud_toppos+64.0 + 0.1, 1);
            }
        }


        /*==============================
                     Score
        ==============================*/

        int x_start = 64.0;
        if (GetUserCVar(plynum, "doomware_hudscale") && GetUserCVar(plynum, "doomware_hudwide"))
            x_start = -48.0;
        SetFont(StrParam(s:"HUD1", s:hudsprite));
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_SCORE2, CR_PURPLE, x_start + 0.1, hud_toppos + 0.1, 1);
        SetFont("HUD1SCOR");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_SCORE3, CR_PURPLE, x_start+32.0 + 0.1, hud_toppos + 9.0 + 0.1, 1);
        if (syncdata_gamestatus > STATUS_STARTING)
        {
            SetFont("DW_FONT1");
            HUDMessage(d:syncdata_score; HUDMSG_PLAIN, MSGID_SCORE, CR_YELLOW, x_start+64.0, hud_toppos+46.0, 1);
            if (GetUserCVar(plynum, "doomware_hudshowbinds"))
            {
                SetFont("DW_FONT3");
                HUDMessage(s:"Press ", k:"+dwmenu", s:" to open the menu"; HUDMSG_PLAIN, MSGID_MENUBIND, CR_YELLOW, x_start+64.0 + 0.4, hud_toppos + 68.0 + 0.1, 1);
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MENUBIND, CR_YELLOW, 0.0, 0.0, 1);
        }


        /*==============================
                     Round
        ==============================*/

        SetFont(StrParam(s:"HUD1", s:hudsprite));
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_ROUND2, CR_PURPLE, w-x_start + 0.2, hud_toppos + 0.1, 1);
        SetFont("HUD1RND");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_ROUND3, CR_PURPLE, w-x_start-32.0 + 0.2, hud_toppos + 9.0 + 0.1, 1);
        if (GetUserCVar(plynum, "doomware_hudshowbinds") && syncdata_canobserve && syncdata_lostround)
        {
            SetFont("DW_FONT3");
            HUDMessage(s:"Press ", k:"+dwobserve", s:" to observe the game"; HUDMSG_PLAIN, MSGID_OBSERVE, CR_CYAN, w-x_start-64.0 + 0.4, hud_toppos + 68.0 + 0.1, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_OBSERVE, CR_CYAN, 0.0, 0.0, 1);
        SetFont("DW_FONT1");
        if (syncdata_gamestatus > STATUS_STARTING)
        {
            if (syncdata_roundnum <= MAXROUNDS)
                HUDMessage(d:syncdata_roundnum; HUDMSG_PLAIN, MSGID_ROUND, CR_GREEN, w-x_start-64.0, hud_toppos+46.0, 1);
            else
                HUDMessage(d:MAXROUNDS; HUDMSG_PLAIN, MSGID_ROUND, CR_GREEN, w-x_start-64.0, hud_toppos+46.0, 1);
        }


        /*==============================
                     Timer
        ==============================*/

        if (GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (syncdata_timer != TIMER_EARLY && syncdata_timer <= 0 && hud_botpos < h+64.0)
                hud_botpos += 4.0;
            else if (syncdata_timer > 0 && hud_botpos > h)
                hud_botpos -= 4.0;

            // In case people decide to resize the hud midway through the round
            if (hud_botpos < h)
                hud_botpos = h;
        }
        else
        {
            if (syncdata_timer > 0)
                hud_botpos = h;
            else
                hud_botpos = h+64.0;
        }

        SetHudSize(w>>16, h>>16, false);
        if (syncdata_timer == TIMER_EARLY)
            SetFont("HUDCLK2");
        else
            SetFont("HUDCLK1");

        if (hud_botpos != h+64.0)
            HUDMessage(s:"a"; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER2, CR_GREEN, w/2, hud_botpos + 0.2, 1);
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_TIMER2, CR_GREEN, 0.0, 0.0, 1);
        SetFont("DW_FONT2");
        int time = ((FixedDiv(syncdata_timer, SECOND)*100)&0xFFFF0000) >> 16;
        int oldtime = ((FixedDiv(lasttimertime, SECOND)*100)&0xFFFF0000) >> 16;
        int tens = time/1000;
        int ones = (time/100)%10;
        int oldones = (oldtime/100)%10;
        int tenths = (time/10)%10;
        int hundredths = time%10;
        if (syncdata_timer > 0)
        {
            HUDMessage(d:tens, d:ones, s:":", d:tenths, d:hundredths; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER, CR_RED, w/2, hud_botpos - 16.0 + 0.2, 1);

            // Play some ticking sounds when there's 3, 2, 1 seconds left
            if (GetUserCvar(plynum, "doomware_hudsounds") && tens == 0)
            {
                if (ones == 2 && oldones == 3)
                    LocalAmbientSound("DoomWare/Clock3", 127);
                if (ones == 1 && oldones == 2)
                    LocalAmbientSound("DoomWare/Clock2", 127);
                if (ones == 0 && oldones == 1)
                    LocalAmbientSound("DoomWare/Clock1", 127);
            }
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER, CR_RED, w/2, hud_botpos + 0.2, 1);


        /*==============================
                    Warnings
        ==============================*/

        SetFont("DW_FONT5");
        if (PlayerCount() > MAXPLAYERS)// Warn that we have too many players
            HUDMessage(s:"WARNING! TOO MANY PLAYERS! MAX: ", d:MAXPLAYERS; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2, h + 0.2, 1);
        else if (remind_login == true && GetUserCVar(plynum, "doomware_loginwarn")) // Remind players to login
        {
            HUDMessage(s:"You are not logged in, your stats will not be tracked!\nPress ", k:"+use", s:" to dismiss this message."; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2 + 0.4, h + 0.2, 1);

            // Allow players to dismiss that message
            if (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_USE || syncdata_loggedin)
                remind_login = false;
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2, h + 0.2, 1);


        /*==============================
            Extra Minigame Elements
        ==============================*/

        if (syncdata_gamestatus == STATUS_MINIGAME && GetCVar("screenblocks") < 11)
        {
            int status_w = 320;
            int status_h = 200;
            if (!GetCVar("st_scale"))
            {
                status_w = GetScreenWidth();
                status_h = GetScreenHeight();
            }
            SetHudSize(status_w, status_h, true);
            status_w = (status_w << 16)/2 + 0.4;
            status_h = (status_h << 16)-200.0 + 0.1;
            hud_time +=1;
            if (hud_time >= 20)
            {
                hud_spindex = random(1, 4);
                hud_time = 0;
            }
            switch(syncdata_roundcurrent)
            {
                case 7:
                    SetFont("SMBAR");
                    hudmessage(s:"a"; HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, status_w, status_h, 1);

                    if (hud_spindex == 1 || hud_spindex == 2)
                    {
                        SetFont(StrParam(s:"SMFACE", d:hud_spindex));
                        hudmessage(s:"A"; HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, status_w, status_h, 1);
                    }
                    else
                        hudmessage(s:""; HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, status_w, status_h, 1);
                    break;
            }
        }
        else
        {
            hudmessage(s:"";HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, 0.5, 0.5, 1);
            hudmessage(s:"";HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, 0.5, 0.5, 1);
        }

        // View sprite
        if (StrCmp(syncdata_viewsprite, "") != 0)
        {
            if (syncdata_wincondition1 == 1337)
                SetHudSize(320, 200, false);
            else if (syncdata_wincondition1 == 1338)
                SetHudSize(20, 18, false);
            else
                SetHudSize(640, 400, false);
            SetFont(syncdata_viewsprite);
            HUDMessage(s:"A"; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_VIEWSP, CR_WHITE, 0.5, 0.9, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWSP, CR_WHITE, 160.0, 120.0, 1);


        SetHudSize(w>>16, h>>16, true);

        lasttimertime = syncdata_timer;

        if (PlayerInGame(plynum))
            delay(1);
        else
            break;
    }
}


/*===================================================================================================
                                        Highscore table
===================================================================================================*/

// This is using a number rather than a named script to make binding the puke easier
Script 257 (void) NET
{
    // Start a solo match if the game hasn't started
    if (game_status == STATUS_NOTSTARTED && PlayerCount() == 1)
        game_solo = true;

    // Don't open the highscore table if it's a solo game or if not ready
    if (game_solo || game_status == STATUS_STARTING)
        terminate;

    // Toggle the scoreboard visibility
    if (player_viewingscore[PlayerNumber()] == false)
        player_viewingscore[PlayerNumber()] = true;
    else
        player_viewingscore[PlayerNumber()] = false;

    // Draw the scoreboard
    ACS_NamedExecuteAlways("DoomWare_Client_DrawHighscore", 0);
}

script "DoomWare_Server_CalcHighscore" (void)
{
	int i, j;

    // Fill the highscore list with the players that are ingame
	for (i=0; i<MAXPLAYERS; i++)
	{
		game_highscores[i] = game_score[i];
		game_highnames[i] = i;

		if (PlayerInGame(i) == false)
		{
			game_highscores[i] = -1;
			game_highnames[i] = -1;
		}
	}

    // Order the list based on who has the highest score
	for (i=0; i<MAXPLAYERS; i++)
	{
		for (j=1; j<MAXPLAYERS-i; j++)
		{
			int temp_value;
			if (game_highscores[j-1] < game_highscores[j])
			{
				temp_value = game_highscores[j-1];
				game_highscores[j-1] = game_highscores[j];
				game_highscores[j] = temp_value;

                temp_value = game_highnames[j-1];
				game_highnames[j-1] = game_highnames[j];
				game_highnames[j] = temp_value;
			}
		}
	}

	delay(1);
    restart;
}

Script "DoomWare_Client_DrawHighscore" (void)
{
    int i;
    if (player_viewingscore[PlayerNumber()] == true)
    {
        int hud_y_counter=0;

        // Initialize the GUI
        SetHudSize(800, 600, false);

        // Draw the background
        SetFont("SCRBRDB");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_HSBACK, CR_ORANGE, 400.0, 300.0, 1);


        // Draw each player's score
        SetFont("DW_FONT3");
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (game_highscores[i] != -1)
            {
                HUDMessage(d:game_highscores[i], s:" ", n:game_highnames[i]+1; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 216.0+hud_y_counter, 1);
                hud_y_counter +=13.0;
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 200.0+hud_y_counter, 1);
        }

        SetHudSize(0, 0, false);

        // Restart the script to keep drawing the scoreboard
        delay(1);
        if (PlayerInGame(PlayerNumber())) // Unless the player disconnected
            restart;
    }
    else
    {
        // Overwrite the scoreboard with blank if it's not being viewed anymore
        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSBACK, CR_ORANGE, 0.5, 0.5, 1);
        for (i=0; i<MAXPLAYERS; i++)
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 200.0+hud_y_counter, 1);
    }
}


/*===================================================================================================
                                        Observer System
===================================================================================================*/

function void Add_Observer(int TID)
{
    if (!game_solo || (game_solo && round_forceobservers))
    {
        minigame_canobserve = true;
        for (int i=0; i<NUMOBSERVERS; i++)
            if (round_observers[i] == -1)
            {
                round_observers[i] = TID;
                break;
            }
    }
}

function void Force_Observe(int plynum)
{
    player_observe[PlayerNumber()]++;
    ChangeCamera(round_observers[0], 0, 0);
}

Script "DoomWare_Server_ClearObservers" (void)
{
    int i;

    // Disable minigame observation
    for (i=0; i<NUMOBSERVERS; i++)
        round_observers[i] = -1;
    minigame_canobserve = false;

    // Remove everyone's observation
    for (i=0; i<MAXPLAYERS; i++)
        player_observe[i] = 0;
    ChangeCamera(0, 1, 0);
}

Script 988 (void) NET // Client - Observe
{
	if (game_status > STATUS_STARTING)
	{
		if (minigame_canobserve == true && player_lostround[PlayerNumber()])
		{
            if (round_observers[player_observe[PlayerNumber()]] != -1)
            {
                player_observe[PlayerNumber()]++;
                ChangeCamera(round_observers[player_observe[PlayerNumber()]-1], 0, 0);
            }
			else
            {
                ChangeCamera(0, 0, 0);
                player_observe[PlayerNumber()] = 0;
            }
		}
	}
}


/*===================================================================================================
                                        DoomWare Menu
===================================================================================================*/

Script 999 (void) NET // Client - Menu toggle
{
   // Toggle the scoreboard visibility
    if (player_viewingmenu[PlayerNumber()] == false)
    {
        player_viewingmenu[PlayerNumber()] = true;
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
    }
    else
    {
        player_viewingmenu[PlayerNumber()] = false;

        // Unfreeze the player (as long as the game lets them)
        if (!player_frozen[PlayerNumber()])
            SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
    }
}

Script "DoomWare_Client_DrawMenu" (void) CLIENTSIDE
{
    // Make sure only the person who called it actually opens the menu
    if (ConsolePlayerNumber() != PlayerNumber())
        terminate;

    SetActivator(TID_PLAYER+ConsolePlayerNumber());

    // Initialize a bunch of variables
    int i;
    int x = GetScreenWidth() / 2;
    int y = GetScreenHeight() / 2;
    int x_sensitivity = 1.0;
    int y_sensitivity = 1.0;
    int dx;
    int dy;
    int tab = 1;
    int plynum = ConsolePlayerNumber();
    bool menu_wasopen = false;

    // Start the menu drawing loop
    while (1)
    {
        int menuopen = Unpack_CVar_Array("__clientsync_player_viewingmenu");
        if (menuopen == 1)
        {
            menu_wasopen = true;
            bool changedtab = false;
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            bool moving_mouse = true;

            if (GetUserCVar(plynum, "doomware_hudscale"))
            {
                w = 800;
                h = 600;
            }
            SetHUDSize(w, h, true);

            w = w << 16;
            h = h << 16;

            // Get input
            dx = FixedMul(x_sensitivity, GetPlayerInput(-1, INPUT_YAW)) / 24;
            dy = FixedMul(y_sensitivity, GetPlayerInput(-1, INPUT_PITCH)) / 12;
            if (dy == 0)
            {
                dy = -GetPlayerInput(-1, INPUT_FORWARDMOVE) / 1200;
                moving_mouse = false;
            }

            // Move the mouse
            x -= dx;
            if (moving_mouse && !GetCVar("invertmouse"))
                y -= dy;
            else
                y += dy;

            // Prevent the mouse from escaping
            if (x < 0)
                x = 0;
            if (x > w>>16)
                x = w>>16;
            if (y < 0)
                y = 0;
            if (y > h>>16)
                y = h>>16;

            // Allow changing tabs
            if ((y <= (h/2-220.0)>>16 && y >= (h/2-240.0)>>16) && (x >= (w/2 - 318.00)>>16 && x <= (w/2 + 318.00)>>16))
            {
                int input = GetPlayerInput(-1, INPUT_BUTTONS);
                int oldinput = GetPlayerInput(-1, INPUT_OLDBUTTONS);
                if (!(oldinput & (BT_USE|BT_ATTACK)) && (input & (BT_USE|BT_ATTACK)))
                {
                    int oldtab = tab;
                    tab = 1+((x-(((w/2)-318.0)>>16))/106);
                    if (tab != oldtab)
                    {
                        changedtab = true;
                        if (GetUserCVar(plynum, "doomware_hudsounds"))
                            LocalAmbientSound("DoomWare/MenuTab", 127);
                    }

                    if (tab == 6)
                        RequestScriptPuke(999);
                }
            }

            // Draw the mouse
            SetFont("CURSOR");
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_CURSOR, CR_WHITE, (x<<16)+2.0+0.1, (y<<16)+2.0+0.1, 1);

            // Handle each tab
            switch(tab)
            {
                case 1:
                    SetFont("DW_FONT3");
                    HUDMessage(s:WELCOME; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2-312.0 + 0.1, h/2 + 28.0 + 0.1, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
                case 2:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"                                    ", s:CHANGES,
                        s:"\n\n\nCurrent number of minigames: ", d:NUMBEROFGAMES,
                        s:"\nCurrent number of tie breakers (1v1): ", d:NUMBEROFTIEBREAKERS,
                        s:"\nCurrent number of tie breakers (non 1v1): ", d:NUMBEROFTIEBREAKERSM;
                        HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2-312.0 + 0.1, h/2 - 200.0 + 0.1, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
                case 3:
                    SetFont("DW_FONT3");
                    int syncdata_loggedin = Unpack_CVar_Array("__clientsync_player_loggedin");
                    if (syncdata_loggedin >= 1)
                    {
                        int syncdata_score = Unpack_CVar_Array("__clientsync_player_score");
                        int syncdata_totalpoints = Unpack_CVar_Array("__clientsync_player_datascore");
                        int syncdata_wins = Unpack_CVar_Array("__clientsync_player_datawins");
                        int syncdata_deaths = Unpack_CVar_Array("__clientsync_player_datadeaths");
                        int syncdata_1ups = Unpack_CVar_Array("__clientsync_player_data1ups");
                        int syncdata_role = Unpack_CVar_Array("__clientsync_player_dataroles");
                        int syncdata_achieve = Unpack_CVar_Array("__clientsync_player_dataachieve");
                        str role;
                        switch (syncdata_role)
                        {
                            case ROLE_NONE:
                                role = "None";
                                break;
                            case ROLE_REGULAR:
                                role = "\cgVeteran\c-";
                                break;
                            case ROLE_ACHIEVER:
                                role = "\cnOver Achiever\c-";
                                break;
                            case ROLE_BETA:
                                role = "\cfBeta Tester\c-";
                                break;
                            case ROLE_BUU342:
                                role = "\cqG\csO\cdD";
                                break;
                            default: // Should never happen
                                role = "\caERROR\c-";
                                break;
                        }
                        HUDMessage(s:"Game wins\n", d:syncdata_wins,
                            s:"\n\nPoints received\n", d:(syncdata_score + syncdata_totalpoints),
                            s:"\n\n1-Ups Collected\n", d:syncdata_1ups,
                            s:"\n\nTotal deaths\n", d:syncdata_deaths,
                            s:"\n\nRank\n", s:role
                            ; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.4, h/2 - 200.0 + 0.1, 1);
                        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+1, CR_WHITE, 0.0, 0.0, 1);

                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_1WIN,       ACHIEVE_NAME_1WIN,       ACHIEVE_DESC_1WIN, "ACH_WINO", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_10WIN,      ACHIEVE_NAME_10WIN,      ACHIEVE_DESC_10WIN, "ACH_WINT", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_100WIN,     ACHIEVE_NAME_100WIN,     ACHIEVE_DESC_100WIN, "ACH_WINH", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_25POINTS,   ACHIEVE_NAME_25POINTS,   ACHIEVE_DESC_25POINTS, "ACH_25PN", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_1v1WIN,     ACHIEVE_NAME_1v1WIN,     ACHIEVE_DESC_1v1WIN, "ACH_1V1W", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_MVMWIN,     ACHIEVE_NAME_MVMWIN,     ACHIEVE_DESC_MVMWIN, "ACH_MVMW", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_501UPS,     ACHIEVE_NAME_501UPS,     ACHIEVE_DESC_501UPS, "ACH_1UPF", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_100DEATH,   ACHIEVE_NAME_100DEATH,   ACHIEVE_DESC_100DEATH, "ACH_DEDH", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_300POINTS,  ACHIEVE_NAME_300POINTS,  ACHIEVE_DESC_300POINTS, "ACH_300P", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_WRONGDOOR,  ACHIEVE_NAME_WRONGDOOR,  ACHIEVE_DESC_WRONGDOOR, "ACH_COLR", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_LONGJUMP,   ACHIEVE_NAME_LONGJUMP,   ACHIEVE_DESC_LONGJUMP, "ACH_1UPS", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_3FRAGS,     ACHIEVE_NAME_3FRAGS,     ACHIEVE_DESC_3FRAGS, "ACH_3FRG", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BULLETHELL, ACHIEVE_NAME_BULLETHELL, ACHIEVE_DESC_BULLETHELL, "ACH_BULL", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_KARTWIN,    ACHIEVE_NAME_KARTWIN,    ACHIEVE_DESC_KARTWIN, "ACH_KART", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_ATST,       ACHIEVE_NAME_ATST,       ACHIEVE_DESC_ATST, "ACH_ATST", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_RUNNER,     ACHIEVE_NAME_RUNNER,     ACHIEVE_DESC_RUNNER, "ACH_JUMP", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BADAIM,     ACHIEVE_NAME_BADAIM,     ACHIEVE_DESC_BADAIM, "ACH_AIMB", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_FULLSERVER, ACHIEVE_NAME_FULLSERVER, ACHIEVE_DESC_FULLSERVER, "ACH_FULL", plynum, x, y, w, h);
                    }
                    else
                    {
                        HUDMessage(s:"You are not logged in."; HUDMSG_PLAIN, MSGID_MELEM, CR_RED, w/2 + 0.0, h/2 - 200.0 + 0.1, 1);
                        HUDMessage(s:"\n\n", s:LOGIN; HUDMSG_PLAIN, MSGID_MELEM+1, CR_white, w/2-312.0 + 0.1, h/2 - 200.0 + 0.1, 1);

                        // Clear unused elements
                        if (changedtab)
                            for (i=1; i<MELEMENTS; i++)
                                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    }
                    break;
                case 4:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"Click the switch to toggle the console command"; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.0, h/2 - 200.0 + 0.1, 1);
                    Handle_Menu_Option(0, "doomware_hudscale", "Force large HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(1, "doomware_hudwide", "Widescreen large HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(2, "doomware_hudsounds", "Allow the HUD to emit sound effects", plynum, x, y, w, h);
                    Handle_Menu_Option(3, "doomware_huddynamic", "Allow the HUD to move dynamically", plynum, x, y, w, h);
                    Handle_Menu_Option(4, "doomware_hudshowbinds", "Show your binds on the game HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(5, "doomware_loginwarn", "Warn you that you're not logged in", plynum, x, y, w, h);
                    Handle_Menu_Option(6, "doomware_music", "Enable DoomWare music (such as winning/losing)", plynum, x, y, w, h);
                    Handle_Menu_Option(7, "doomware_invertfly", "Invert Y axis on flight controls", plynum, x, y, w, h);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);

                    //Handle_Menu_Option(6, "doomware_joinmenu", "Open this menu upon connecting to a game", PlayerNumber(), x, y, w, h);
                    break;
                case 5:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"\cgA wad by \cqB\csu\cdu\cq3\cs4\cd2\c-\n\n",
                        s:"Based on the Nintendo game series WarioWare, all rights reserved\n",
                        s:"Credit for all used assets are provided within the wad's data\n\n",
                        s:"\cvPlease report any bugs you encounter to:\n",
                        s:"\cvbuu342@hotmail.com\n",
                        s:"\cvAlternatively, bugs can be reported on the Doomworld or Zandronum\n",
                        s:"\cvDoomWare thread."; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.4, h/2 + 0.0, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
            }

            // Draw the background
            SetFont(StrParam(s:"MENU", d:tab));
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MENU, CR_WHITE, w/2+0.0, h/2+0.0, 1);
        }
        else
        {
            if (menu_wasopen)
            {
                for (i=0; i<MELEMENTS; i++)
                    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MENU, CR_WHITE, 0.0, 0.0, 0);
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CURSOR, CR_WHITE, 0.0, 0.0, 0);
                menu_wasopen = false;
				tab = 1;
            }
        }

        // Restart the script to keep drawing the menu
        delay(1);

        if (!PlayerInGame(plynum))
            terminate;
    }
}

function void Handle_Menu_Option(int number, str command, str desc, int plynum, int mouse_x, int mouse_y, int w, int h)
{
    int x = w/2-312.0 + 0.1;
    int y = h/2-180.0 + (number)*48.0 + 0.1;
    int oldbutton = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
    int button = GetPlayerInput(plynum, INPUT_BUTTONS);

    // Draw the button
    if (GetUserCVar(plynum, command))
        SetFont("SOTESCHY");
    else
        SetFont("SOTESCHN");
    HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MELEM+(number+1)*2, CR_WHITE, x, y, 1);
    SetFont("DW_FONT3");
    HUDMessage(s:command, s:"\n", s:desc; HUDMSG_PLAIN, MSGID_MELEM+1+(number+1)*2, CR_GOLD, x + 48.0, y + 5.0, 1);

    // Handle the button clicking
    if ((mouse_x >= x>>16 && mouse_x <= (x+32.0)>>16) && (mouse_y >= y>>16 && mouse_y <= (y+32.0)>>16)) // If the mouse is within the button's bounds
        if (!oldbutton & (BT_ATTACK|BT_USE) && button & (BT_ATTACK|BT_USE)) // If the player has pressed the button
        {
            // toggle the command
            SetUserCVar(plynum, command, !GetUserCVar(plynum, command));

            // Play a sound
            if (GetUserCVar(plynum, "doomware_hudsounds"))
                LocalAmbientSound("DoomWare/MenuSwitch", 127);
        }
}

function void Handle_Menu_Achievement(int achieve_data, int number, str name, str desc, str sprite, int plynum, int mouse_x, int mouse_y, int w, int h)
{
    int x = w/2-312.0 + (number%9)*70.0 + 0.1;
    int y = h/2+98.0 + (number/9)*70.0 + 0.1;
    int oldbutton = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
    int button = GetPlayerInput(plynum, INPUT_BUTTONS);
    int unlocked = achieve_data & (1<<(number));

    // Show the achievement sprite if unlocked
    if (unlocked)
        SetFont(sprite);
    else
        SetFont("ACH_NONE");
    HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MELEM+2+number*2, CR_WHITE, x, y, 1);
    SetFont("DW_FONT3");

    // Handle the button clicking
    if ((mouse_x >= x>>16 && mouse_x <= (x+64.0)>>16) && (mouse_y >= y>>16 && mouse_y <= (y+64.0)>>16)) // If the mouse is within the button's bounds
    {
        if (unlocked)
            HUDMessage(s:name, s:"\n", s:desc; HUDMSG_PLAIN, MSGID_MELEM+2+number*2+1, CR_GOLD, w/2 + 0.4, h/2+72.0, 1);
        else
            HUDMessage(s:"???", s:"\n", s:"This achievement is locked"; HUDMSG_PLAIN, MSGID_MELEM+2+number*2+1, CR_RED, w/2 + 0.4, h/2+72.0, 1);
    }
    else
    {
        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+2+number*2+1, CR_WHITE, w/2 + 0.0, h/2+64.0, 1);
    }
}

function void Give_Achievement(int plynum, int achievement)
{
    if (PlayerIsLoggedIn(plynum) && game_status != STATUS_NOTSTARTED && !game_solo && (data_achieve[plynum] & (1<<achievement)) == 0)
    {
        data_achieve[plynum] = data_achieve[plynum] | (1<<achievement);
        switch(achievement)
        {
            case ACHIEVE_ID_1WIN:       player_achievement[plynum] = ACHIEVE_NAME_1WIN; Break;
            case ACHIEVE_ID_100WIN:     player_achievement[plynum] = ACHIEVE_NAME_10WIN; Break;
            case ACHIEVE_ID_100WIN:     player_achievement[plynum] = ACHIEVE_NAME_100WIN; Break;
            case ACHIEVE_ID_25POINTS:   player_achievement[plynum] = ACHIEVE_NAME_25POINTS; Break;
            case ACHIEVE_ID_1V1WIN:     player_achievement[plynum] = ACHIEVE_NAME_1V1WIN; Break;
            case ACHIEVE_ID_MVMWIN:     player_achievement[plynum] = ACHIEVE_NAME_MVMWIN; Break;
            case ACHIEVE_ID_501UPS:     player_achievement[plynum] = ACHIEVE_NAME_501UPS; Break;
            case ACHIEVE_ID_100DEATH:   player_achievement[plynum] = ACHIEVE_NAME_100DEATH; Break;
            case ACHIEVE_ID_300POINTS:  player_achievement[plynum] = ACHIEVE_NAME_300POINTS; Break;
            case ACHIEVE_ID_WRONGDOOR:  player_achievement[plynum] = ACHIEVE_NAME_WRONGDOOR; Break;
            case ACHIEVE_ID_LONGJUMP:   player_achievement[plynum] = ACHIEVE_NAME_LONGJUMP; Break;
            case ACHIEVE_ID_3FRAGS:     player_achievement[plynum] = ACHIEVE_NAME_3FRAGS; Break;
            case ACHIEVE_ID_BULLETHELL: player_achievement[plynum] = ACHIEVE_NAME_BULLETHELL; Break;
            case ACHIEVE_ID_KARTWIN:    player_achievement[plynum] = ACHIEVE_NAME_KARTWIN; Break;
            case ACHIEVE_ID_ATST:       player_achievement[plynum] = ACHIEVE_NAME_ATST; Break;
            case ACHIEVE_ID_RUNNER:     player_achievement[plynum] = ACHIEVE_NAME_RUNNER; Break;
            case ACHIEVE_ID_BADAIM:     player_achievement[plynum] = ACHIEVE_NAME_BADAIM; Break;
            case ACHIEVE_ID_FULLSERVER: player_achievement[plynum] = ACHIEVE_NAME_FULLSERVER; Break;
            default: break;
        }
		Log(n:plynum+1, s:" obtained the achievement \cv", s:player_achievement[plynum]);

        // Notify the achievement got received
        SetActivator(TID_PLAYER+plynum);
		SpawnSpotForced("ConfettiEffect", TID_PLAYER+plynum, 0, 0);
        SetFont("DW_FONT1");
        if (game_status != STATUS_NOTSTARTED && player_achievement[PlayerNumber()] != "")
        {
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            str hudsprite;
            if (GetUserCVar(PlayerNumber(), "doomware_hudscale"))
            {
                w = 800;
                h = 600;
            }
            SetHudSize(w, h, true);
            w = w << 16;
            h = h << 16;
            HUDMessage(s:"Achievement Unlocked!\n", s:player_achievement[PlayerNumber()]; HUDMSG_FADEOUT, MSGID_ACHIEVEM, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.8) + 0.2, 1.0, 1.0);
            player_achievement[PlayerNumber()] = "";
            if (GetUserCvar(PlayerNumber(), "doomware_hudsounds"))
                LocalAmbientSound("DoomWare/Achievement", 127);
        }
    }
}


/*===================================================================================================
                                            Hats
===================================================================================================*/

#define BETATESTERSIZE 4
str BetaTesterList[BETATESTERSIZE];
function bool IsBetaTester(int plynum)
{
    BetaTesterList[0] = "[I] Asriel";
    BetaTesterList[1] = "Marcaek";
    BetaTesterList[2] = "Doomer9000";
    BetaTesterList[3] = "DeanYktRu";

    for (int i=0; i<BETATESTERSIZE; i++)
        if (!StrCmp(BetaTesterList[i], GetPlayerAccountName(i)))
            return true;
    return false;
}

Script "DoomWare_Server_Hats" (void)
{
    int z;

    // If not a solo game
    if (!game_solo)
    {
        // Leader hat (if there is a leader)
        if (game_highscores[0] > game_highscores[1] && game_status != STATUS_GAMEOVER && !(GetActorProperty(TID_PLAYER+0, APROP_Health) <= 0))
        {
            if (ThingCount(0, TID_HATGAME) == 0)
                SpawnSpotForced("LeaderHat", 1, TID_HATGAME, 0);

            z = 64.0;
            if (data_role[game_highnames[0]] > ROLE_NONE)
                z = 84.0;
            SetActorPosition(TID_HATGAME, GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0]), GetActorZ(TID_PLAYER+game_highnames[0])+z, 0);
            //SetActorVelocity(TID_HATGAME, FixedMul(GetActorVelX(TID_PLAYER+game_highnames[0]), 0.55), FixedMul(GetActorVelY(TID_PLAYER+game_highnames[0]), 0.55), GetActorVelZ(TID_PLAYER+game_highnames[0]), 0, 0);
            //SetActorAngle(TID_HATGAME, GetActorAngle(TID_PLAYER+game_highnames[0]));
        }
        else if (ThingCount(0, TID_HATGAME) > 0)
            Thing_Remove(TID_HATGAME);

        // Winner hat (at the end of the game)
        if (game_status == STATUS_GAMEOVER && game_over == OVER_WINNER)
        {
            if (ThingCount(0, TID_HATGAME+1) == 0)
                SpawnSpotForced("Crown", 1, TID_HATGAME+1, 0);

            z = 64.0;
            if (data_role[game_highnames[0]] > ROLE_NONE)
                z = 84.0;
            SetActorPosition(TID_HATGAME+1, GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0]), GetActorZ(TID_PLAYER+game_highnames[0])+z, 0);
            //SetActorVelocity(TID_HATGAME+1, FixedMul(GetActorVelX(TID_PLAYER+game_highnames[0]), 0.55), FixedMul(GetActorVelY(TID_PLAYER+game_highnames[0]), 0.55), GetActorVelZ(TID_PLAYER+game_highnames[0]), 0, 0);
            //SetActorAngle(TID_HATGAME+1, GetActorAngle(TID_PLAYER+game_highnames[0]));
        }
    }

    // Special Hats
    for (int i=0; i<MAXPLAYERS; i++)
    {
        // If the player left the game (or is dead), kill the hat
        if ((ThingCount(0, TID_HATROLE+i) > 0 && data_role[i] <= ROLE_NONE) || (GetActorProperty(TID_PLAYER+i, APROP_Health) <= 0) || (!PlayerInGame(i)))
            Thing_Remove(TID_HATROLE+i);

        // Check if the player logged in recently
        if (data_role[i] == ROLE_UNLOGGED && PlayerIsLoggedIn(i))
            Load_PlayerDB(i);

        // Give Buu342 his hat if he doesn't have one
        if (StrCmp(GetPlayerAccountName(i), "buu342") == 0)
            data_role[i] = ROLE_BUU342;

        // Give a beta tester a hat if they don't have one
        if (IsBetaTester(i))
            data_role[i] = ROLE_BETA;

        // If they don't have a worthy role (or are dead), ignore them
        if (data_role[i] <= ROLE_NONE || (GetActorProperty(TID_PLAYER+i, APROP_Health) <= 0))
            continue;

        switch (data_role[i])
        {
            case ROLE_BUU342:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("Buu342Hat", 1, TID_HATROLE+i, 0);
            case ROLE_BETA:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("BetaHat", 1, TID_HATROLE+i, 0);
            case ROLE_REGULAR:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("RegularHat", 1, TID_HATROLE+i, 0);
            case ROLE_ACHIEVER:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("AchieverHat", 1, TID_HATROLE+i, 0);

                SetActorPosition(TID_HATROLE+i, GetActorX(TID_PLAYER+i), GetActorY(TID_PLAYER+i), GetActorZ(TID_PLAYER+i)+64.0, 0);
				break;
        }
    }

    // Restart the script
    delay(1);
    restart;
}


/*===================================================================================================
                                    Minigames (Clientside)
===================================================================================================*/

Script "DoomWare_Client_Minigame1" (void) // The Floor Is Lava
{
    minigame_instruction1[PlayerNumber()] = "The Floor Is Lava";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame2" (void) // Survive (Cyberdemon)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame3" (void) // Survive (ghouls)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame4" (void) // Survive (Archviles)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame5" (void) // Stop Moving
{
    minigame_instruction1[PlayerNumber()] = "Stop Moving";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame6" (void) // Don't Stop Moving
{
    minigame_instruction1[PlayerNumber()] = "Don't Stop Moving";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame7" (void) // Kill Ned Flanders
{
    minigame_instruction1[PlayerNumber()] = "Kill Ned Flanders";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into Homer and give him a shotgun
	str class = "SimpsonsPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		GiveInventory("SimpsonsShotgun", 1);
		SetWeapon("SimpsonsShotgun");
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame8" (void) // Destroy a Barrel
{
    minigame_instruction1[PlayerNumber()] = "Destroy a Barrel";

    // Make the player invincible and give him a Mace
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("MaceWeapon", 1);
    SetWeapon("MaceWeapon");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame9" (void) // Shoot one of the targets
{
    minigame_instruction1[PlayerNumber()] = "Shoot one of the targets";

    // Make the player invincible and give him a Railgun
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame10" (void) // Evade the Kamikazi
{
    minigame_instruction1[PlayerNumber()] = "Evade the Kamikazi";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame11" (void) // Survive (super Shotgun)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give the player a super shotgun
    GiveInventory("SuperShotgun", 1);
    SetWeapon("SuperShotgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame12" (void) // Blow Your Brains Out
{
    minigame_instruction1[PlayerNumber()] = "Blow Your Brains Out";

    // Give the player a suicide pistol
    GiveInventory("Suicide", 1);
    SetWeapon("Suicide");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame13" (void) // Enter the door
{
    // Display the correct text based on which minigame we're playing
    if (minigame_wincondition1 == 0)
        minigame_instruction1[PlayerNumber()] = "Enter the No Key Door";
    else if (minigame_wincondition1 == 1)
        minigame_instruction1[PlayerNumber()] = "Enter the Blue Key Door";
    else if (minigame_wincondition1 == 2)
        minigame_instruction1[PlayerNumber()] = "Enter the Red Key Door";
    else if (minigame_wincondition1 == 3)
        minigame_instruction1[PlayerNumber()] = "Enter the Yellow Key Door";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame14" (void) // Meet The Worm
{
    minigame_instruction1[PlayerNumber()] = "Meet the Worm";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into massmouth and give him the Ray Gun
	str class = "MassMouthPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		GiveInventory("Raygun", 1);
		SetWeapon("Raygun");
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame15" (void) // Reach The End (Swapping Boxes)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    minigame_instruction2[PlayerNumber()] = "Boxes swap to the music";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame16" (void) // Touch the sky
{
    minigame_instruction1[PlayerNumber()] = "Touch the sky";
    minigame_instruction2[PlayerNumber()] = "Spam your jump button";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        // Let players jump more
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_JUMP) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_JUMP) )
			ThrustThingZ(0, 20, 0, 0);

        // Make them win if they hit the sky
        if (GetActorZ(0) > 195.0)
            Player_Win(PlayerNumber());

        // Continue the loop
        delay(1);
    }
}

Script "DoomWare_Client_Minigame17" (void) // Finish a lap (Ancient Lake DDKR)
{
    minigame_instruction1[PlayerNumber()] = "Finish a lap";
    minigame_instruction2[PlayerNumber()] = "Hold Shoot To Accelerate";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into a kart and freeze him
	str class = "KartPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_TOTALLYFROZEN);
		delay(1);
	}

    // Wait for the countdown
    LocalAmbientSound("DoomWare/KartStart", 127);
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame18" (void) // Equip Weapon
{
    str wep;
	str oldwep; // Needed to fix a bug where players would auto win for some reason

    // Give the player everything
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Chainsaw", 1);
    GiveInventory("Pistol", 1);
    GiveInventory("SuperShotgun", 1);
    GiveInventory("Chaingun", 1);
    GiveInventory("RocketLauncher", 1);
    GiveInventory("PlasmaRifle", 1);
    GiveInventory("BFG9000", 1);
    TakeInventory("Clip", 500);
    TakeInventory("Shell", 500);
    TakeInventory("Cell", 500);
    TakeInventory("RocketAmmo", 500);
	GiveInventory("Fist", 1);
	SetWeapon("Fist");

    Switch(minigame_wincondition1)
    {
    	case 1:
            minigame_instruction1[PlayerNumber()] = "Equip your Chainsaw";
            wep = "Chainsaw";
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = "Equip your Pistol";
            wep = "Pistol";
            break;
        case 3:
            minigame_instruction1[PlayerNumber()] = "Equip your Super Shotgun";
            wep = "SuperShotgun";
            break;
        case 4:
            minigame_instruction1[PlayerNumber()] = "Equip your Chaingun";
            wep = "Chaingun";
            break;
        case 5:
            minigame_instruction1[PlayerNumber()] = "Equip your Rocket Launcher";
            wep = "RocketLauncher";
            break;
        case 6:
            minigame_instruction1[PlayerNumber()] = "Equip your Plasma Gun";
            wep = "PlasmaRifle";
            break;
        case 7:
            minigame_instruction1[PlayerNumber()] = "Equip your BFG9000";
            wep = "BFG9000";
            break;
    }

    Delay(10);

    // Award points if they got the right weapon
	oldwep = GetWeapon();
    while (game_status == STATUS_MINIGAME)
    {
        if (StrIcmp(GetWeapon(), wep) == 0 && !StrIcmp(GetWeapon(), oldwep))
            Player_Win(PlayerNumber());
        delay(1);
		oldwep = GetWeapon();
    }
}

Script "DoomWare_Client_Minigame19" (void) // Swim Up
{
    minigame_instruction1[PlayerNumber()] = "Swim to the surface";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (GetActorZ(0) > 332.0)
			Player_Win(PlayerNumber());
        delay(1);
    }
}

Script "DoomWare_Client_Minigame20" (void) // Reach the end (Factory)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame21" (void) // Survive (Grenades)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame22" (void) // Collect 10 Rings
{
	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

	// Morph the player into massmouth and give him the Ray Gun
	str class = "SonicPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
		TeleportInSector(43, 436, 396, false);
        int num = CheckInventory("WonRoundItem");
        if (num < 10)
            minigame_instruction1[PlayerNumber()] = StrParam(s:"Collect ", d:(10-num), s:" Rings");
        else
            minigame_instruction1[PlayerNumber()] = "Finished!";
        delay(1);
    }

    // Set him back to normal
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame23" (void) // Stay Off The Ground
{
    minigame_instruction1[PlayerNumber()] = "Stay Off The Ground";

    // Make the players invincible and give them a rocket launcher
    GiveInventory("RocketLauncher", 2);
    SetWeapon("RocketLauncher");
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame24" (void) // Stay On The Ground
{
    minigame_instruction1[PlayerNumber()] = "Stay On The Ground";

    // Make the players invincible and give them a rocket launcher
    GiveInventory("RocketLauncher", 2);
    SetWeapon("RocketLauncher");
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame25" (void) // Shoot the target (popup)
{
    minigame_instruction1[PlayerNumber()] = "Shoot the target";

    // Make the player invincible and give him a Railgun
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame26" (void) // Survive (Boxing)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give the player a boxing glove
    GiveInventory("BoxingGlove", 1);
    SetWeapon("BoxingGlove");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame27" (void) // Survive (Terry)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame28" (void) // Finish a lap (E1M1)
{
    minigame_instruction1[PlayerNumber()] = "Finish a lap";
    minigame_instruction2[PlayerNumber()] = "Hold Shoot To Accelerate";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into a kart and freeze him
	str class = "KartPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_TOTALLYFROZEN);
		delay(1);
	}

    // Wait for the countdown
    LocalAmbientSound("DoomWare/KartStart", 127);
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame29" (void) // Duck Hunt
{
    minigame_instruction1[PlayerNumber()] = "Shoot A Duck";

    GiveInventory("NESZapper", 1);
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame30" (void) // Dive Into The Water
{
    minigame_instruction1[PlayerNumber()] = "Dive Into The Water";

    // Prevent winning during teleportation
    delay(2);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Check if the player managed to get in the water
    while (game_status == STATUS_MINIGAME)
    {
        if (GetActorZ(0) < 50.0 && ClassifyActor(0) & ACTOR_ALIVE)
            Player_Win(PlayerNumber());
        delay(1);
    }
}

Script "DoomWare_Client_Minigame31" (void) // Reach The End (Rocks)
{
    minigame_instruction1[PlayerNumber()] = "Reach The End";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame32" (void) // Reach The End (Ice)
{
    minigame_instruction1[PlayerNumber()] = "Reach The End";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame33" (void) // Survive (Romero)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame34" (void) // Survive (Hoth)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into a snow speeder and make him fly
	str class = "SnowSpeederPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_FLY );
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (!player_lostround[PlayerNumber()])
        {
            // Allow for air controls
            if (GetUserCVar(PlayerNumber(), "doomware_invertfly"))
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*2 , 0, 0);
            else
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*-2 , 0, 0);
        }
        delay(1);
    }

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    setplayerproperty(1, 0, PROP_FLY );
}

Script "DoomWare_Client_Minigame35" (void) // Climb the Colossus
{
    minigame_instruction1[PlayerNumber()] = "Climb the Colossus";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame36" (void) // Get On The Colored Circle
{
    minigame_instruction1[PlayerNumber()] = "Get On The Colored Circle";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Force the player to look at the screen
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame37" (void) // Swim Down
{
    minigame_instruction1[PlayerNumber()] = "Swim";
    minigame_instruction2[PlayerNumber()] = "Press your use key to dive deeper";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Turn the player into a submarine
	str class = "SubmarinePlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		delay(1);
    }
	delay(1);

    // Give players control
    while (game_status == STATUS_MINIGAME)
    {
        // Allow players to dive with their Use key
		if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_USE) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_USE) )
			ThrustThingZ(0, 8, 1, 1);
        delay(1);
    }

    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame38" (void) // Repeat the pattern
{
    minigame_instruction1[PlayerNumber()] = "Watch";

    // Freeze the player and make him invulnerable
	setplayerproperty(1, 1, PROP_FROZEN );
	setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the pattern is done showing
    while (minigame_canmove == false)
        delay(1);

    // Give the player a RailGun
	GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        str ans = "Your Answer = ";
        for (int i=0; i<4; i++)
            if (player_answer2[PlayerNumber()][i] != -1)
            {
                str color;
                switch (player_answer2[PlayerNumber()][i])
                {
                    case 0:
                        color = "\cd";
                        break;
                    case 1:
                        color = "\cm";
                        break;
                    case 2:
                        color = "\cg";
                        break;
                    case 3:
                        color = "\ch";
                        break;
                    case 4:
                        color = "\cj";
                        break;
                    case 5:
                        color = "\ci";
                        break;
                }
                ans = StrParam(s:ans, s:color, d:(i+1), s:"\c-");
            }
        minigame_instruction2[PlayerNumber()] = ans;
        delay(1);
    }
}

Script "DoomWare_Client_Minigame39" (void) // Storm the Beach
{
    minigame_instruction1[PlayerNumber()] = "Storm the beach";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame40" (void) // Survive (Dark Corridors)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give the player a shotgun
    GiveInventory("Shotgun", 1);
    SetWeapon("Shotgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame41" (void) // Go to the Light
{
    minigame_instruction1[PlayerNumber()] = "Go to the Light";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame42" (void) // Survive (Rockets)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a rocket launcher and make him invulnerable
    GiveInventory("RocketLauncher", 2);
    GiveInventory("RocketBox", 20);
    SetWeapon("RocketLauncher");
    delay(10); // To prevent losing invulnerability during teleportation
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame43" (void) // Don't Blow Your Brains Out
{
    minigame_instruction1[PlayerNumber()] = "Don't Blow Your Brains Out";

    // Give the player a suicide pistol
    GiveInventory("Suicide", 1);
    SetWeapon("Suicide");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame44" (void) // Don't Equip Weapon
{
    str wep;

    // Give the player everything
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Chainsaw", 1);
    GiveInventory("Pistol", 1);
    GiveInventory("SuperShotgun", 1);
    GiveInventory("Chaingun", 1);
    GiveInventory("RocketLauncher", 1);
    GiveInventory("PlasmaRifle", 1);
    GiveInventory("BFG9000", 1);
    TakeInventory("Clip", 500);
    TakeInventory("Shell", 500);
    TakeInventory("Cell", 500);
    TakeInventory("RocketAmmo", 500);
    GiveInventory("Fist", 1);
    SetWeapon("Fist");

    Switch(minigame_wincondition1)
    {
    	case 1:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your Chainsaw";
            wep = "Chainsaw";
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your Pistol";
            wep = "Pistol";
            break;
        case 3:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your Super Shotgun";
            wep = "SuperShotgun";
            break;
        case 4:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your Chaingun";
            wep = "Chaingun";
            break;
        case 5:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your Rocket Launcher";
            wep = "RocketLauncher";
            break;
        case 6:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your Plasma Gun";
            wep = "PlasmaRifle";
            break;
        case 7:
            minigame_instruction1[PlayerNumber()] = "Don't Equip your BFG9000";
            wep = "BFG9000";
            break;
    }

    Delay(10);

    // Fail them if they got the right weapon
    while (game_status == STATUS_MINIGAME)
    {
        if (StrIcmp(GetWeapon(), wep) == 0)
            Player_Lose(PlayerNumber(), false);
        delay(1);
    }
}

Script "DoomWare_Client_Minigame45" (void) // Finish a lap (Rainbow Road)
{
    minigame_instruction1[PlayerNumber()] = "Finish a lap";
    minigame_instruction2[PlayerNumber()] = "Hold Shoot To Accelerate";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into a kart and freeze him
	str class = "KartPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_TOTALLYFROZEN);
		delay(1);
	}

    // Wait for the countdown
    LocalAmbientSound("DoomWare/KartStart", 127);
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame46" (void) // Reach The End (Bigger Swapping Boxes)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    minigame_instruction2[PlayerNumber()] = "Boxes swap to the music";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame47" (void) // Survive (Banana)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame48" (void) // Survive (Spike)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame49" (void) // Math
{
    // Choose the game instructions based on wincondition3
    switch (minigame_wincondition3)
    {
        case 0:
            minigame_instruction1[PlayerNumber()] = StrParam(i:minigame_wincondition1, s:" + ", i:minigame_wincondition2);
            break;
        case 1:
            minigame_instruction1[PlayerNumber()] = StrParam(i:minigame_wincondition1, s:" - ", i:minigame_wincondition2);
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = StrParam(i:minigame_wincondition1, s:" x ", i:minigame_wincondition2);
            break;
    }

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Make the player frozen+invulnerable and give him a railgun
	setplayerproperty(1, 2, prop_invulnerability);
	setplayerproperty(1, 1, PROP_FROZEN );
	GiveInventory("Railgun", 1);
	SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        str ans = "Your Answer = ";
        for (int i=0; i<2; i++)
            if (player_answer2[PlayerNumber()][i] != -1)
                ans = StrParam(s:ans, d:player_answer2[PlayerNumber()][i]);
        minigame_instruction2[PlayerNumber()] = ans;
        delay(1);
    }
}

Script "DoomWare_Client_Minigame50" (void) // Survive (Bullet Hell)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    delay(1);
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame51" (void) // Clean your Weapon
{
    minigame_instruction1[PlayerNumber()] = "Clean your weapon";
    minigame_instruction2[PlayerNumber()] = "Spam Shoot";
    player_viewsprite[PlayerNumber()] = "PPISA0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            str sprite = "AFKLMNOPFFGHHJJJHHJJJHHFFFFQRSRSRSRSRSRSRSRSRSQFFFFFFHHJJJQRSRSRSQFFFKLMMNOPPFA";
            if (player_answer1[PlayerNumber()] < 78)
                player_answer1[PlayerNumber()]++;
            player_viewsprite[PlayerNumber()] = StrParam(s:"PPIS", c:GetChar(sprite, player_answer1[PlayerNumber()]), s:"0");
            Switch (player_answer1[PlayerNumber()])
            {
                case 4:
                case 71: LocalAmbientSound("DoomWare/CleanCock1", 127); break;
                case 5:
                case 73: LocalAmbientSound("DoomWare/CleanCock2", 127); break;
                case 6:
                case 74: LocalAmbientSound("DoomWare/CleanCock3", 127); break;
                case 7:
                case 75: LocalAmbientSound("DoomWare/CleanCock4", 127); break;
                case 13:
                case 18:
                case 55: LocalAmbientSound("DoomWare/CleanSpray", 127); break;
                case 28:
                case 30:
                case 32:
                case 34:
                case 36:
                case 38:
                case 40:
                case 42:
                case 44:
                case 59:
                case 61:
                case 63: LocalAmbientSound("DoomWare/CleanRub1", 127); break;
                case 29:
                case 31:
                case 33:
                case 35:
                case 37:
                case 39:
                case 41:
                case 43:
                case 45:
                case 60:
                case 62:
                case 64: LocalAmbientSound("DoomWare/CleanRub2", 127); break;
                case 78: Player_Win(PlayerNumber()); break;
            }
        }

        delay(1);
    }
}

Script "DoomWare_Client_Minigame52" (void) // The Air is Lava
{
    minigame_instruction1[PlayerNumber()] = "The Air is Lava";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if (minigame_wincondition1 == 1 && GetActorZ(0) > -54.0 && !player_lostround[PlayerNumber()])
			Thing_damage(0, 10000, MOD_LAVA);
        delay(1);
    }
}

Script "DoomWare_Client_Minigame53" (void) // Drink
{
    minigame_instruction1[PlayerNumber()] = "Drink";
    minigame_instruction2[PlayerNumber()] = "Spam shoot";
    player_viewsprite[PlayerNumber()] = "TNT2A0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            str sprite = "ABCDEFGHIJKLMNOOONMMMNOOONMMMNOOONMLKJIHGF";
            if (player_answer1[PlayerNumber()] < 41)
			{
				player_answer1[PlayerNumber()]++;
				Switch (player_answer1[PlayerNumber()])
				{
					case 16:
					case 24: LocalAmbientSound("DoomWare/Gulp", 127); break;
					case 32: LocalAmbientSound("DoomWare/Gulp", 127); Player_Win(PlayerNumber()); break;
					case 41: LocalAmbientSound("DoomWare/DrinkAh", 127); break;
				}
			}
            player_viewsprite[PlayerNumber()] = StrParam(s:"DRNK", c:GetChar(sprite, player_answer1[PlayerNumber()]), s:"0");
        }

        delay(1);
    }
}

Script "DoomWare_Client_Minigame54" (void) // Survive (Chilli)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame55" (void) // Hit the Real Barrel
{
    minigame_instruction1[PlayerNumber()] = "Hit the Real Barrel";

    // Make the player invincible and give him a Mace
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("MaceWeapon", 1);
    SetWeapon("MaceWeapon");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame56" (void) // Survive (Spike Circle)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame57" (void) // Eat The Chocolate
{
    minigame_instruction1[PlayerNumber()] = "Eat The Chocolate";
    minigame_instruction2[PlayerNumber()] = "Spam Shoot";
    player_viewsprite[PlayerNumber()] = "TNT2A0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            str sprite = "ABCDEFGHIJKLMNOPQRSTUV";
            if (player_answer1[PlayerNumber()] < 21)
                player_answer1[PlayerNumber()]++;
            player_viewsprite[PlayerNumber()] = StrParam(s:"CHOC", c:GetChar(sprite, player_answer1[PlayerNumber()]), s:"0");
            if (player_answer1[PlayerNumber()] == 14)
                Player_Win(PlayerNumber());
        }

        delay(1);
    }
}

Script "DoomWare_Client_Minigame58" (void) // Survive (Wind)
{
	int jumpz = GetActorProperty(0 ,APROP_JumpZ);
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Make the player unable to jump
	SetActorProperty(0 ,APROP_JumpZ, 0<<16);
	SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

	// Give the player a push staff so he can be a dick
	GiveInventory("PushStaff", 1);
	SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);

	// Let the player jump again
	SetActorProperty(0 ,APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame59" (void) // Get to Hissy
{
    minigame_instruction1[PlayerNumber()] = "Get to Hissy";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame60" (void) // Math
{
    minigame_instruction1[PlayerNumber()] = "Count The Lost Souls";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Make the player frozen+invulnerable
	setplayerproperty(1, 2, prop_invulnerability);
	setplayerproperty(1, 1, PROP_FROZEN );

    // Wait until the Lost Souls have stopped appearing
    while (minigame_wincondition1 == 0)
        delay(1);

    // Give the player a Railgun
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        str ans = "Your Answer = ";
        for (int i=0; i<2; i++)
            if (player_answer2[PlayerNumber()][i] != -1)
                ans = StrParam(s:ans, d:player_answer2[PlayerNumber()][i]);
        minigame_instruction2[PlayerNumber()] = ans;
        delay(1);
    }

    // Morph the player back
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame61" (void) // Reach the End (Hurdles)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Freeze the player for a min
    setplayerproperty(1, 1, PROP_TOTALLYFROZEN);

    // Wait for the countdown
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame62" (void) // Cross the Road
{
    minigame_instruction1[PlayerNumber()] = "Cross the Road";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Turn the player into a chicken
	str class = "ChickenPlayer2";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Morph the player back
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame63" (void) // Collect a Potion
{
    minigame_instruction1[PlayerNumber()] = "Collect a Potion";
    minigame_instruction2[PlayerNumber()] = "Attack a thief";

    // Make the player invulnerable and give him a sexy leg
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Boot", 1);
    SetWeapon("Boot");

    // Make the player win if he got a potion
    while (game_status == STATUS_MINIGAME)
    {
        if (GetActorProperty(0, APROP_Health) > 100 )
            Player_Win(PlayerNumber());
        delay(1);
    }

    // Morph the player back
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame64" (void) // Reach the End (Skyhook)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into the Outrider and make him fly
	str class = "OutriderPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_FLY );
		SetActorAngle(0, 0.25);
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (!player_lostround[PlayerNumber()])
        {
            // Allow for air controls
            if (GetUserCVar(PlayerNumber(), "doomware_invertfly"))
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*2 , 0, 0);
            else
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*-2 , 0, 0);
        }
        delay(1);
    }

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    setplayerproperty(1, 0, PROP_FLY );
}

Script "DoomWare_Client_Minigame65" (void) // Spam the Indicated Button
{
    while (game_status == STATUS_MINIGAME)
    {
		int curinput = GetPlayerInput(-1, INPUT_BUTTONS);
		int oldinput = GetPlayerInput(-1, INPUT_OLDBUTTONS);

        // Check the keys the player is pressing
        switch (minigame_wincondition2)
        {
            case 0:
                minigame_instruction1[PlayerNumber()] = "Spam Shoot";
                if( (curinput & BT_ATTACK) && !(oldinput & BT_ATTACK) )
                    player_answer1[PlayerNumber()]++;
                else if (((curinput & BT_JUMP) && !(oldinput & BT_JUMP)) || ((curinput & BT_USE) && !(oldinput & BT_USE)))
                    if (player_answer1[PlayerNumber()] != 29)
                        player_answer1[PlayerNumber()]--;
                break;
            case 1:
                minigame_instruction1[PlayerNumber()] = "Spam Use";
                if( (curinput & BT_USE) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_USE) )
                    player_answer1[PlayerNumber()]++;
                else if (((curinput & BT_JUMP) && !(oldinput & BT_JUMP)) || ((curinput & BT_ATTACK) && !(oldinput & BT_ATTACK)))
                    if (player_answer1[PlayerNumber()] != 29)
                        player_answer1[PlayerNumber()]--;
                break;
            case 2:
                minigame_instruction1[PlayerNumber()] = "Spam Jump";
                if( (curinput & BT_JUMP) && !(oldinput & BT_JUMP) )
                {
                    ThrustThingZ(0, 20, 0, 0);
                    player_answer1[PlayerNumber()]++;
                }
                else if (((curinput & BT_USE) && !(oldinput & BT_USE)) || ((curinput & BT_ATTACK) && !(oldinput & BT_ATTACK)))
                    if (player_answer1[PlayerNumber()] != 29)
                        player_answer1[PlayerNumber()]--;
                break;
        }

        // Check if the player won
        if (player_answer1[PlayerNumber()] >= 29)
        {
            player_answer1[PlayerNumber()] = 29;
            Player_Win(PlayerNumber());
        }

        if (player_answer1[PlayerNumber()] < 0)
            player_answer1[PlayerNumber()] = 0;

        // Set the view sprite
        if (player_answer1[PlayerNumber()] < 10)
            player_viewsprite[PlayerNumber()] = StrParam(s:"MASHOM0", d:player_answer1[PlayerNumber()]);
        else
            player_viewsprite[PlayerNumber()] = StrParam(s:"MASHOM", d:player_answer1[PlayerNumber()]);

        delay(1);
    }
}

Script "DoomWare_Client_Minigame66" (void) // Don't Get Wet
{
    minigame_instruction1[PlayerNumber()] = "Don't Get Wet!";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame67" (void) // Reach the End (Factory Line)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame68" (void) // Pick Up the Key
{
    minigame_instruction1[PlayerNumber()] = "Pick up the assigned key";
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Check if the player has the right key
    while (game_status == STATUS_MINIGAME)
    {
        if ((minigame_wincondition1 == 0 && CheckInventory("BlueCard") > 0) || (minigame_wincondition1 == 1  && CheckInventory("RedCard") > 0) || (minigame_wincondition1 == 2  && CheckInventory("YellowCard") > 0))
            Player_Win(PlayerNumber());
        delay(1);
    }
}

Script "DoomWare_Client_Minigame69" (void) // Survive (Hell Deathmatch)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Stop the player from moving to prevent falling in the lava at the start
    SetActorVelocity(TID_PLAYER+PlayerNumber(), 0.0, 0.0, 0.0, false, false);

    // Give the player a super shotgun
    GiveInventory("Shotgun", 1);
    SetWeapon("Shotgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame70" (void) // Eat
{
    if (minigame_wincondition1 == 0)
        minigame_instruction1[PlayerNumber()] = "Eat anything but Sushi";
    else
        minigame_instruction1[PlayerNumber()] = "Eat anything but Tea";

    // Check if the right food has been consumed
    while (game_status == STATUS_MINIGAME)
    {
        if ((CheckInventory("Food_EggRoll") > 0) || (CheckInventory("Food_SalmonRoll1") > 0) ||
             (CheckInventory("Food_SalmonRoll2") > 0) || (CheckInventory("Food_Shrimp") > 0) ||
             (CheckInventory("Food_Toro") > 0) || (CheckInventory("Food_Tea") > 0 && minigame_wincondition1 == 0 ) ||
            (CheckInventory("Food_Sushi1") > 0 && minigame_wincondition1 == 1) || (CheckInventory("Food_Sushi2") > 0 && minigame_wincondition1 == 1))
            Player_Win(PlayerNumber());

        if ((CheckInventory("Food_Tea") > 0 && minigame_wincondition1 == 1 ) ||
            (CheckInventory("Food_Sushi1") > 0 && minigame_wincondition1 == 0) || (CheckInventory("Food_Sushi2") > 0 && minigame_wincondition1 == 0))
            Player_Lose(PlayerNumber(), false);

        delay(1);
    }
}

Script "DoomWare_Client_Minigame71" (void) // Find a Pokemon
{
    int pkmn_num=0;
    minigame_instruction1[PlayerNumber()] = "Find a Pokemon";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into Ash
	str class = "AshPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		delay(1);
	}

    // Check if a Pokemon has been caught
    while (game_status == STATUS_MINIGAME)
    {
        if (CheckInventory("PokemonTrigger"))
        {
            switch (pkmn_num)
            {
                case 0:
                    Player_Win(PlayerNumber());
                    SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
                    SetActorVelocity(0, 0, 0, 0, false, false);
                    LocalSetMusic("d_pkmnen");
                    break;
                case 27:
                case 15:
                case 3:
                    fadeto(0, 0, 0, 1.0, 0.0857);
                    break;
                case 30:
                case 18:
                case 6:
                    fadeto(0, 0, 0, 0.0, 0.0857);
                    break;
                case 33:
                case 21:
                case 9:
                    fadeto(255, 255, 255, 1.0, 0.0857);
                    break;
                case 36:
                case 24:
                case 12:
                    fadeto(255, 255, 255, 0.0, 0.0857);
                    break;
                default:
                    if (pkmn_num >= 39)
                    {
                        int spr_num = pkmn_num - 38;
                        if (spr_num > 17)
                        {
                            spr_num = 17;
                            fadeto(0, 0, 0, 1.0, 0.001);
                        }
                        if (spr_num < 10)
                            player_viewsprite[PlayerNumber()] = StrParam(s:"PKMNBT0", d:spr_num);
                        else
                            player_viewsprite[PlayerNumber()] = StrParam(s:"PKMNBT", d:spr_num);
                    }
                    break;
            }
            pkmn_num++;
        }
        delay(1);
    }
    fadeto(0, 0, 0, 0.0, 0.01);
	delay(1);
	fadeto(0, 0, 0, 0.0, 0.01);
    LocalSetMusic("");
    SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame72" (void) // Survive (Disappearing Floor)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame73" (void) // Mine an Ore
{
    // Tell the player what to do
    delay(1);
    switch(minigame_wincondition1)
    {
        case 0:
            minigame_instruction1[PlayerNumber()] = "Mine \ccTin";
            break;
        case 1:
            minigame_instruction1[PlayerNumber()] = "Mine \csCopper";
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = "Mine \crIron";
            break;
    }

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into Bob and give him a Rune Pick
	str class = "RunescapePlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		GiveInventory("PickaxeWeapon",1);
		SetWeapon("PickaxeWeapon");
		delay(1);
	}

    // Check if the player mined the right element
    while (game_status == STATUS_MINIGAME)
    {
        if (minigame_wincondition1 == 0 && CheckInventory("TinOreItem"))
            Player_Win(PlayerNumber());
		else if (minigame_wincondition1 == 1 && CheckInventory("CopperOreItem"))
            Player_Win(PlayerNumber());
		else if (minigame_wincondition1 == 2 && CheckInventory("IronOreItem"))
            Player_Win(PlayerNumber());
        delay(1);
    }

    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame74" (void) // Reach the End (Eclipse)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame75" (void) // Hit the Target (Grenades)
{
    minigame_instruction1[PlayerNumber()] = "Hit the Target";

    // Make the player not solid and give him a grenade launcher
	str class = "NonSolidPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_FROZEN );
		setplayerproperty(1, 2, PROP_INVULNERABILITY );
		GiveInventory("GrenadeLauncher",1);
		GiveInventory("RocketAmmo",100);
		SetWeapon("GrenadeLauncher");
		delay(1);
	}

    // Check if the player hit the target
    while (game_status == STATUS_MINIGAME)
    {
        if (CheckInventory("WonRoundItem") > 0 )
            Player_Win(PlayerNumber());
        delay(1);
    }

	delay(1);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame76" (void) // Score a Basketball
{
    minigame_instruction1[PlayerNumber()] = "Score a Basketball";

    // Give the player a basketball
    GiveInventory("BBallLauncher",1);
    GiveInventory("RocketAmmo",100);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame77" (void) // Reach the End (Bit Trip)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Make the player only able to jump
	str class = "JumpPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		setplayerproperty(1, 1, PROP_FROZEN );
		SetActorAngle(0, 0.25);
		SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
		Force_Observe(709);
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame78" (void) // Shoot Apple Imp Head
{
    minigame_instruction1[PlayerNumber()] = "Shoot the Apple Off The Imp's Head";

    // Give the player a bow and arrow and make him invulnerable+frozen
    SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
    setplayerproperty(1, 1, PROP_FROZEN );
    GiveInventory("BowArrow",1);
    SetWeapon("BowArrow");
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame79" (void) // Shoot an Imp
{
    minigame_instruction1[PlayerNumber()] = "Shoot an Imp";

    // Make the player invincible and give him a Railgun
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame80" (void) // Survive (Pyoro)
{
	int jumpz = GetActorProperty(0 ,APROP_JumpZ);
	int speed = GetActorProperty(0, APROP_Speed);

    // Make the player unable to jump
    minigame_instruction1[PlayerNumber()] = "Survive";
	Force_Observe(813);

	// Invert the player's controls and make him unable to jump
	SetActorProperty(0, APROP_Speed, -GetActorProperty(0, APROP_Speed));
	SetActorProperty(0 ,APROP_JumpZ, 0<<16);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
	{
		// Make the player always look towards the camera
		SetActorAngle(0, 0.75);
        delay(1);
	}

	// Re-invert the player's controls and let him jump again
	SetActorProperty(0, APROP_Speed, speed);
	SetActorProperty(0, APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame81" (void) // Dodge the Car
{
	int jumpz = GetActorProperty(0 ,APROP_JumpZ);
	int speed = GetActorProperty(0, APROP_Speed);

    // Make the player unable to jump
    minigame_instruction1[PlayerNumber()] = "Dodge the Car";
	Force_Observe(815);

	// Make the player unable to move and make him jump much higher
	SetActorProperty(0, APROP_Speed, 0);
	SetActorProperty(0, APROP_JumpZ, FixedMul(jumpz, 1.5));

	SetActorVelocity(0, 0.0, 0.0, 0.0, false, false);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
	{
		// Make the player always look right
		SetActorAngle(0, 1.0);
        delay(1);
	}

	// Put the player back to normal
	SetActorProperty(0, APROP_Speed, speed);
	SetActorProperty(0, APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame82" (void) // Whack a Mole
{
    minigame_instruction1[PlayerNumber()] = "Whack a Mole";

    // Make the player invincible and give him a Mace
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("MaceWeapon", 1);
    SetWeapon("MaceWeapon");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame83" (void) // Charge your Lazor
{
    minigame_instruction1[PlayerNumber()] = "Charge your Laz0r";
    minigame_instruction2[PlayerNumber()] = "Spam shoot. 1 Point Per Frag";
    player_viewsprite[PlayerNumber()] = "TNT2A0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
		// If the player lost, don't let him be able to win
		if (player_lostround[PlayerNumber()])
		{
			player_viewsprite[PlayerNumber()] = "TNT2A0";
			delay(1);
			continue;
		}

		// If he reached a certain score, increment the animation automatically
		if (player_answer1[PlayerNumber()] >= 22 && player_answer1[PlayerNumber()] < 31)
			player_answer1[PlayerNumber()]++;

		// On pressing attack
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
			// Spawn the aura if it's the first click
			if (player_answer1[PlayerNumber()] == 0)
			{
				SpawnSpotForced("Aura", TID_PLAYER+PlayerNumber(), TID_EXTRA+PlayerNumber(), 0);
				Thing_Projectile(TID_PLAYER+PlayerNumber(), 252, (GetActorAngle(TID_PLAYER+PlayerNumber())>>8)+64, 24, 0);
				Thing_Projectile(TID_PLAYER+PlayerNumber(), 252, (GetActorAngle(TID_PLAYER+PlayerNumber())>>8)-64, 24, 0);
			}

			// Increment the view sprite
            if (player_answer1[PlayerNumber()] < 22)
                player_answer1[PlayerNumber()]++;

			// Fire the Laz0r when ready
			if (player_answer1[PlayerNumber()] == 22)
			{
				GiveInventory("Laz0r", 1);
				SetWeapon("Laz0r");

				Player_Win(PlayerNumber());
			}
        }

		// Select the viewsprite
		if (player_answer1[PlayerNumber()] == 31 || player_answer1[PlayerNumber()] == 0)
			player_viewsprite[PlayerNumber()] = "TNT2A0";
		else
			player_viewsprite[PlayerNumber()] = StrParam(s:"LAZR", d:player_answer1[PlayerNumber()]-1);

        delay(1);
    }
}

Script "DoomWare_Client_Minigame84" (void) // Stay on the Road
{
    minigame_instruction1[PlayerNumber()] = "Stay on the Road";
    minigame_instruction2[PlayerNumber()] = "Strafe to steer";

	// Prevent a bug where some player's won't teleport after morphing
	delay(1);

    // Morph the player into a kart and freeze him
	str class = "BusPlayer";
	while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
	{
		Player_Morph(PlayerNumber(), class);
		delay(1);
	}

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
	{
		SetActorPitch(TID_PLAYER+PlayerNumber(), 0.0);
		SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);
        delay(1);
	}

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame85" (void) // Survive (Time Freeze)
{
	int time = 0;
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

	// Give players a grenade launcher
	GiveInventory("GrenadeLauncher", 1);
	SetWeapon("GrenadeLauncher");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
	{
		time++;

		// If time's unfreezing, remove the grenade launcher so we don't get cheeky players
		if (time > SECOND*6)
			TakeInventory("GrenadeLauncher", 1);
        delay(1);
	}
}

Script "DoomWare_Client_Minigame86" (void) // Reach the end (Chasm)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");
	
    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame87" (void) // Be the highest player
{
    minigame_instruction1[PlayerNumber()] = "Be the highest player";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");
	
    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame88" (void) // Choose a side
{
	int jumpz = GetActorProperty(0 ,APROP_JumpZ);
	int speed = GetActorProperty(0, APROP_Speed);
	minigame_instruction1[PlayerNumber()] = "Choose a side";
	minigame_instruction2[PlayerNumber()] = "The heaviest side will fall";
	Force_Observe(898);

	// Invert the player's controls and make him unable to jump
	SetActorProperty(0, APROP_Speed, -GetActorProperty(0, APROP_Speed));
	SetActorProperty(0 ,APROP_JumpZ, 0<<16);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
	{
		// Make the player always look towards the camera
		SetActorAngle(0, 0.75);
        delay(1);
	}

	// Re-invert the player's controls and let him jump again
	SetActorProperty(0, APROP_Speed, speed);
	SetActorProperty(0, APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame89" (void) // Abandon Ship
{
	minigame_instruction1[PlayerNumber()] = "Abandon Ship";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}


/*===================================================================================================
                                 1v1 TieBreakers (Clientside)
===================================================================================================*/

Script "DoomWare_Client_TieBreaker1" (void) // Gun Duel
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Shoot the other player";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        setplayerproperty(1, 1, PROP_FROZEN);
        SetActorProperty(0, APROP_HEALTH, 1);
        GiveInventory("Pistol", 1);
        SetWeapon("Pistol");
    }
    else
        Force_Observe(PlayerNumber());

    // Kill the player if they shoot too soon (to prevent holding the shoot button)
    while (minigame_canmove == false)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAK)
        delay(1);

    // Unfreeze frozen players
    SetPlayerProperty(1, 0, PROP_FROZEN);
}

Script "DoomWare_Client_TieBreaker2" (void) // Rope Tug
{
    int plyx, plyy, plyz;

    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Press your Use key to repeatedly tug the rope";

    // Move the players
    if (PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        setplayerproperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Kill the player if they press use too soon
    while (minigame_canmove == false)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_USE) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_USE))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // Showtime!
    LocalAmbientSound("DoomWare/TieStart", 127);
    minigame_instruction1[PlayerNumber()] = "Go!";

    while (game_status == STATUS_TIEBREAK)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_USE) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_USE))
        {
            if (PlayerNumber() == game_highnames[0] && !player_lostround[game_highnames[0]] && GetActorY(TID_PLAYER+game_highnames[0]) < 1848.0)
            {
                Line_SetTextureOffset(27, +1.0, NO_CHANGE, SIDE_FRONT, 10);
                SetActorPosition(TID_PLAYER+game_highnames[1], GetActorX(TID_PLAYER+game_highnames[1]), GetActorY(TID_PLAYER+game_highnames[1])-1.0, GetActorZ(TID_PLAYER+game_highnames[1]), false);
                SetActorPosition(TID_PLAYER+game_highnames[0], GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0])-1.0, GetActorZ(TID_PLAYER+game_highnames[0]), false);
            }
            if (PlayerNumber() == game_highnames[1] && !player_lostround[game_highnames[1]] && GetActorY(TID_PLAYER+game_highnames[1]) > 1992.0)
            {
                Line_SetTextureOffset(27, -1.0, NO_CHANGE, SIDE_FRONT, 10);
                SetActorPosition(TID_PLAYER+game_highnames[0], GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0])+1.0, GetActorZ(TID_PLAYER+game_highnames[0]), false);
                SetActorPosition(TID_PLAYER+game_highnames[1], GetActorX(TID_PLAYER+game_highnames[1]), GetActorY(TID_PLAYER+game_highnames[1])+1.0, GetActorZ(TID_PLAYER+game_highnames[1]), false);
            }
        }
        delay(1);
    }
    setplayerproperty(1, 0, PROP_FROZEN);
    SetActorPosition(TID_PLAYER+PlayerNumber(), plyx, plyy, plyz, 0);
    SpawnSpotForced("TeleportFog", TID_PLAYER+PlayerNumber(), 0, 0);
}

Script "DoomWare_Client_TieBreaker3" (void) // Barrels
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Kill the other player";

    // Give the player a weapon if they're in the game, or force them to observe
    if (PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        setplayerproperty(1, 1, PROP_FROZEN);
        SetActorProperty(0, APROP_HEALTH, 1);
        GiveInventory("Pistol", 1);
        SetWeapon("Pistol");
    }
    else
        Force_Observe(PlayerNumber());

    // Kill the player if they shoot too soon (to prevent holding the shoot button)
    while (minigame_canmove == false)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAK)
        delay(1);

    // Unfreeze frozen players
    SetPlayerProperty(1, 0, PROP_FROZEN);
}


/*===================================================================================================
                               Non 1v1 TieBreakers (Clientside)
===================================================================================================*/

Script "DoomWare_Client_TieBreakerM1" (void) // Survive (Grenades Fight)
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Survive. Kills give you a 1up";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (game_score[PlayerNumber()] == game_highscores[0])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        GiveInventory("GrenadeLauncher", 1);
        GiveInventory("RocketBox", 20);
        SetWeapon("GrenadeLauncher");
        SetPlayerProperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Don't allow the player to shoot while he waits for the round to begin
    while (minigame_canmove == false)
    {
        if ((GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);
    SetPlayerProperty(1, 0, PROP_FROZEN);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAKM)
        delay(1);
}

Script "DoomWare_Client_TieBreakerM2" (void) // Survive (Decreasing Ring)
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Survive. The Map gets smaller.";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (game_score[PlayerNumber()] == game_highscores[0])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        GiveInventory("PushStaff", 1);
        SetWeapon("PushStaff");
        SetPlayerProperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Don't allow the player to attack while he waits for the round to begin
    while (minigame_canmove == false)
    {
        if ((GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);
    SetPlayerProperty(1, 0, PROP_FROZEN);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAKM)
    {
        if (GetActorZ(TID_PLAYER+PlayerNumber()) < -128.0)
                Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }
}

Script "DoomWare_Client_TieBreakerM3" (void) // Hit the Target (1 Shot)
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Shoot the target.";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (game_score[PlayerNumber()] == game_highscores[0])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        GiveInventory("Railgun", 1);
        SetWeapon("Railgun");
        SetPlayerProperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Wait for the minigame to start
    while (minigame_canmove == false)
        delay(1);

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);
    SetPlayerProperty(1, 0, PROP_FROZEN);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAKM)
        delay(1);
}


/*===================================================================================================
                                    Minigames (Serverside)
===================================================================================================*/

Script "DoomWare_Server_Minigame1" (void) // The floor is lava
{
    HUDMessage(s:"The Floor Is Lava"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_LAVA");
    round_winifmid = true;

    // Lower the lights
    int lowerspeed = 8;
    switch (game_speed)
    {
        case 2:
        case 3: lowerspeed = 9; break;
        case 4: lowerspeed = 10; break;
    }
    floor_lowerbyvalue(20, lowerspeed, 10);
    floor_lowerbyvalue(21, 8, 8);
    floor_lowerbyvalue(22, 8, 8);
    SetThingSpecial(88, 0, 0, 0, 0, 0, 0);
    SetThingSpecial(147, 0, 0, 0, 0, 0, 0);
    delay(SECOND-(2*game_speed));

    // Make the floor lava
    Sector_setDamage(2, 200000, MOD_LAVA);
    Sector_setDamage(20, 200000, MOD_LAVA);
    Sector_setDamage(21, 200000, MOD_LAVA);
    Sector_setDamage(22, 200000, MOD_LAVA);
    ChangeFloor(2, "WFLAVA1");
    ChangeFloor(20, "WFLAVA1");
    ChangeFloor(21, "WFLAVA1");
    ChangeFloor(22, "WFLAVA1");
    delay(SECOND-(2*game_speed));

    // Make everything safe again
	if (!strcmp(GetCVarString("doomware_mode"), "halloween"))
		SetThingSpecial(147, 0, 255, 105, 0, 8, 0);
	else
		SetThingSpecial(147, 0, 0, 0, 255, 8, 0);
	SetThingSpecial(88, 0, 255, 0, 0, 8, 0);
    Sector_setDamage(2, 0, MOD_UNKNOWN);
    Sector_setDamage(20, 0, MOD_UNKNOWN);
    Sector_setDamage(21, 0, MOD_UNKNOWN);
    Sector_setDamage(22, 0, MOD_UNKNOWN);
    ChangeFloor(2, "SLIME15");
    ChangeFloor(20, "N_BRGR13");
    ChangeFloor(21, "TLITE6_5");
	if (!strcmp(GetCVarString("doomware_mode"), "halloween"))
		ChangeFloor(22, "TLITE6_8");
	else
		ChangeFloor(22, "TLITE6_7");
	
    floor_raisebyvalue(20, 8, 10);
    floor_raisebyvalue(21, 8, 8);
    floor_raisebyvalue(22, 8, 8);
    delay(SECOND-(2*game_speed));
}

Script "DoomWare_Server_Minigame2" (void) // Survive (Cyberdemon)
{
    HUDMessage(s:"Survive (Cyberdemon)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CYBRDM");
    round_winifmid = true;

    // Spawn the cyberdemons (more if the game is faster)
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    SpawnSpotForced("Cyberdemon", 1, TID_REMOVE, random(0, 359));
    if (game_speed > 1)
        SpawnSpotForced("Cyberdemon", 7+random(0, 3), TID_REMOVE, random(0, 359));
    if (game_speed == MAXSPEEDUPS)
        SpawnSpotForced("Cyberdemon", 3+random(0, 3), TID_REMOVE, random(0, 359));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10 - (SECOND*game_speed));
}

Script "DoomWare_Server_Minigame3" (void) // Survive (ghouls)
{
    HUDMessage(s:"Survive (Ghouls)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_GHOUL");
    Add_Observer(537);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 440, false, true);

    // Spawn a bunch of Jitterskulls
    SpawnSpotForced("Jitterskull", 25, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 27, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 29, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 31, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 33, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 35, TID_REMOVE, random(0, 359));

    // Spawn more depending on the game speed
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Jitterskull", 32, TID_REMOVE, random(0, 359));
            SpawnSpotForced("Jitterskull", 34, TID_REMOVE, random(0, 359));
        case 3:
            SpawnSpotForced("Jitterskull", 28, TID_REMOVE, random(0, 359));
            SpawnSpotForced("Jitterskull", 30, TID_REMOVE, random(0, 359));
        case 2:
            SpawnSpotForced("Jitterskull", 26, TID_REMOVE, random(0, 359));
            break;
    }

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(SECOND*game_speed));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame4" (void) // Survive (archviles)
{
    hudmessage(s:"Survive (Archvile)";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_ARCHV");
    round_winifmid = true;

    // Move the dynamic lights up
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)+128.0, 0);

    // Spawn everyone's favorite Doom 2 monster
    SpawnSpotForced("Archvile", 1, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 57, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 58, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 59, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 60, TID_REMOVE, random(0, 359));

    // Spawn more depending on the difficulty
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Archvile", 6, TID_REMOVE, random(0, 359));
        case 3:
            SpawnSpotForced("Archvile", 5, TID_REMOVE, random(0, 359));
        case 2:
            SpawnSpotForced("Archvile", 4, TID_REMOVE, random(0, 359));
        case 1:
            SpawnSpotForced("Archvile", 3, TID_REMOVE, random(0, 359));
            break;
    }
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Raise the floor
    floor_raisebyvalue(20, 8, 64);
    floor_raisebyvalue(21, 8, 64);
    floor_raisebyvalue(22, 8, 64);

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(SECOND*game_speed));

    // Move things back
    floor_lowerbyvalue(20, 8, 64);
    floor_lowerbyvalue(21, 8, 64);
    floor_lowerbyvalue(22, 8, 64);
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)-128.0, 0);
}

Script "DoomWare_Server_Minigame5" (void) // Stop moving
{
    hudmessage(s:"Stop Moving";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    setMusic("D_MOVEIT");
    round_winifmid = true;

    // Set the floor friction to help slow down players
    Sector_SetFriction(2, 95);
    Sector_SetFriction(19, 95);
    Sector_SetFriction(20, 95);
    Sector_SetFriction(21, 95);
    Sector_SetFriction(22, 95);
    Sector_SetFriction(23, 95);
    Sector_SetFriction(24, 95);

    // Give players time to react
    delay(SECOND*2-(game_speed*2));

    // Horribly maim anyone who is moving
    for (int i=0; i<MAXPLAYERS; i++)
        if (Calc_Speed(GetActorVelX(TID_PLAYER+i), GetActorVely(TID_PLAYER+i)) > 20)
            thing_damage(TID_PLAYER+i, 1337, MOD_BARREL);

    // Set the friction back to normal
    delay(SECOND);
    Sector_SetFriction(2, 100);
    Sector_SetFriction(19, 100);
    Sector_SetFriction(20, 100);
    Sector_SetFriction(21, 100);
    Sector_SetFriction(22, 100);
    Sector_SetFriction(23, 100);
    Sector_SetFriction(24, 100);
}

Script "DoomWare_Server_Minigame6" (void) // Don't stop moving
{
    hudmessage(s:"Don't Stop Moving";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    setMusic("D_MOVEIT");
    round_winifmid = true;
    delay(SECOND-(game_speed));

    // Horribly maim anyone who isn't moving
    for (int i=0; i<MAXPLAYERS; i++)
        if (Calc_Speed(GetActorVelX(TID_PLAYER+i), GetActorVely(TID_PLAYER+i)) < 20)
            thing_damage(TID_PLAYER+i, 1337, MOD_BARREL);

    delay(SECOND);
}

Script "DoomWare_Server_Minigame7" (void) // Kill Ned Flanders
{
    hudmessage(s:"Kill Ned Flanders";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_SIMPSN");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 70, false, true);

    // Spawn Ned Flanders
    SpawnSpot ("NedFlanders", 728, TID_REMOVE);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame8" (void) // Destroy a Barrel
{
    HUDMessage(s:"Destroy a Barrel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_barrl");

    // Spawn some barrels to whack
    SpawnSpot ("WoodBarrel", 3, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 4, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 5, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 6, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 7, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 8, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 9, TID_REMOVE);
    SpawnSpot ("WoodBarrel", 10, TID_REMOVE);
    SpawnSpot ("WoodBarrel1UP", 1, TID_REMOVE);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame9" (void) // Shoot A Target
{
    HUDMessage(s:"Shoot A Target"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 90, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame10" (void) // Evade the Kamikazi
{
    int time=0;
    HUDMessage(s:"Evade the Kamikazi"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Jihad");
    round_winifmid = true;

    // Spawn a Kamikaze
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    SpawnSpotForced("Jihad", 1, TID_REMOVE , random(0, 359));
    SpawnSpotForced("AvoidDecoration", 1, TID_AVOID, 0);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Move the AVOID item to follow the Kamikaze
    while (time < (SECOND*2 - 10))
    {
        time++;
        SetActorPosition(TID_AVOID, GetActorX(TID_REMOVE), GetActorY(TID_REMOVE), GetActorZ(TID_REMOVE)+64.0, 0);
        delay(1);
    }

    // Blow up the Kamikaze
    thing_remove(TID_AVOID);
    thing_damage(TID_REMOVE, 50, 0);

    delay(10);
}

Script "DoomWare_Server_Minigame11" (void) // Survive (super Shotgun)
{
    HUDMessage(s:"Survive (super Shotgun)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_stelth");
    round_winifmid = true;
    minigame_fragpoints = true;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame12" (void) // Blow Your Brains Out
{
    HUDMessage(s:"Blow Your Brains Out"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_rave");
    round_winifsuicide = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(5*game_speed));
}

Script "DoomWare_Server_Minigame13" (void) // Enter The Door
{
    hudmessage(s:"Enter The Door"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    minigame_wincondition1 = random(0, 3);
    SetMusic("d_door");

    // Store player positions in case they win
    ACS_NamedExecute("DoomWare_Server_SavePlayerPositions", 0);

    // Raise the doors
    floor_raisebyvalue(24, 32, 128);
    floor_raisebyvalue(25, 32, 128);
    floor_raisebyvalue(39, 32, 128);
    floor_raisebyvalue(44, 32, 128);

    // Give players time to reach the doors
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*3-(5*game_speed));

    // Lower the doors
    floor_lowerbyvalue(24, 32, 128);
    floor_lowerbyvalue(25, 32, 128);
    floor_lowerbyvalue(39, 32, 128);
    floor_lowerbyvalue(44, 32, 128);

    // Mark players who didn't do anything as lost (to prevent getting teleported)
    for (int i=0; i<MAXPLAYERS; i++)
        if (player_midround[i])
            Player_Lose(i, true);

    // Bring players back if they're at the island
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame14" (void) // Meet the Worm
{
    hudmessage(s:"Meet the worm"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_worm");
    round_noforceend = true; // To give time to catch the 1-Up

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 110, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4-(3*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame15" (void) // Reach the End (Swapping Boxes)
{
    int time = SECOND*20-(35*game_speed);
    int box = 0;
    hudmessage(s:"Reach the End (Swapping Boxes)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_boxes");
    Sector_SetDamage(876, 10000, MOD_FALLING);
    Sector_SetDamage(10, 10000, MOD_FALLING);
	Add_Observer(518);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 150, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, time);

    // Make the boxes swap
    time = 0;
    do
    {
        int i;
        time++;
        if (time == 89)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "3";
        else if (time == 89+17)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "2";
        else if (time == 89+34)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "1";
        else if (time == 89+51)
        {
            time = 0;
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "";
            if (box == 0)
            {
                Floor_LowerInstant(7, 0, 24);
                Floor_RaiseInstant(876, 0, 26);
                Floor_LowerInstant(859, 0, 28);
                Floor_RaiseInstant(10, 0, 28);
                ChangeFloor(7, "f_sky1");
                ChangeFloor(876, "DEM4_5");
                ChangeFloor(10, "DEM4_5");
                ChangeFloor(859, "f_sky1");
                Sector_SetDamage(9, 10000, MOD_FALLING);
                Sector_SetDamage(859, 10000, MOD_FALLING);
                Sector_SetDamage(876, 0, MOD_FALLING);
                Sector_SetDamage(10, 0, MOD_FALLING);
                box = 1;
            }
            else
            {
                Floor_RaiseInstant(859, 0, 28);
                Floor_LowerInstant(876, 0, 26);
                Floor_RaiseInstant(7, 0, 24);
                Floor_LowerInstant(10, 0, 28);
                ChangeFloor(876, "f_sky1");
                ChangeFloor(10, "f_sky1");
                ChangeFloor(7, "DEM3_5");
                ChangeFloor(859, "DEM3_5");
                Sector_SetDamage(876, 10000, MOD_FALLING);
                Sector_SetDamage(10, 10000, MOD_FALLING);
                Sector_SetDamage(859, 0, MOD_FALLING);
                Sector_SetDamage(7, 0, MOD_FALLING);
                box = 0;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);

    // Fix the boxes
    if (box == 1)
    {
        Floor_RaiseInstant(859, 0, 28);
        Floor_LowerInstant(876, 0, 26);
        Floor_RaiseInstant(7, 0, 24);
        Floor_LowerInstant(10, 0, 28);
        ChangeFloor(876, "f_sky1");
        ChangeFloor(10, "f_sky1");
        ChangeFloor(7, "DEM3_5");
        ChangeFloor(859, "DEM3_5");
        Sector_SetDamage(876, 10000, MOD_FALLING);
        Sector_SetDamage(10, 10000, MOD_FALLING);
        Sector_SetDamage(859, 0, MOD_FALLING);
        Sector_SetDamage(7, 0, MOD_FALLING);
    }
}

Script "DoomWare_Server_Minigame16" (void) // Touch The Sky
{
    HUDMessage(s:"Touch The Sky"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Jump");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*3-(4*game_speed));
}

Script "DoomWare_Server_Minigame17" (void) // Finish a lap (Ancient Lake DDKR)
{
    HUDMessage(s:"Finish A Lap (Ancient Lake)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_ddkr");
    Add_Observer(536);
    Add_Observer(818);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 170, false, true);

    // Countdown until players can move
    SpawnSpotForced("Lakitu", 358, THING_REMOVE, 0);
    delay(SECOND*2);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*18-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame18" (void) // Equip Weapon
{
    HUDMessage(s:"Equip Weapon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    minigame_wincondition1 = random(1, 7);
    SetMusic("d_weapon");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(3*game_speed));
}

Script "DoomWare_Server_Minigame19" (void) // Reach Surface
{
    HUDMessage(s:"Reach Surface"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_water");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 21, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame20" (void) // Reach The End (Factory)
{
    HUDMessage(s:"Reach The End (Factory)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Factry");
    Add_Observer(539);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 190, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame21" (void) // Survive (Grenades)
{
    HUDMessage(s:"Survive (Grenades)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_GRENAD");
    round_winifmid = true;

    // Raise the floor
    ChangeFloor(17, "SHAWN2");
    switch (game_speed)
    {
        case 4:
            floor_raisebyvalue(17, 32, 64);
            break;
        case 3:
        case 2:
            floor_raisebyvalue(17, 24, 64);
            break;
        case 1:
        case 0:
            floor_raisebyvalue(17, 16, 64);
            break;
    }
    delay(SECOND-(2*game_speed));

    // Shoot grenades
    SpawnProjectile(87, "DWGrenade", 0, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 32, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 64, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 96, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 128, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 160, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 192, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 224, 90, 4, 0.25, 0);
    delay(SECOND + 10);

    // Lower the floor
    ChangeFloor(17, "NFMBGY01");
    floor_lowerbyvalue(17, 16, 64);
    delay(SECOND*2);
}

Script "DoomWare_Server_Minigame22" (void) // Collect 10 Rings
{
    hudmessage(s:"Collect 10 Rings"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_Sonic");
    SpawnSpotForced("WonRoundItem", 89, TID_REMOVE, 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 107, true, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    // Check for winners
    do
    {
        for (int i=0; i<MAXPLAYERS; i++)
            if (CheckActorInventory(TID_PLAYER+i, "WonRoundItem") >= 10)
                Player_Win(i);
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Move the players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame23" (void) // Stay Off The Ground
{
    hudmessage(s:"Stay Off The Ground"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_ground");
    round_winifmid = true;
    delay(SECOND+20 - (2*game_speed));

    // Horribly maim anyone who is on the floor
    for (int i=0; i<MAXPLAYERS; i++)
    {
        if ((GetActorZ(TID_PLAYER+i)>>16) < 11)
        {
            thing_damage(TID_PLAYER+i, 10000000, MOD_BARREL);
        }
    }

    delay(SECOND);
}

Script "DoomWare_Server_Minigame24" (void) // Stay On The Ground
{
    hudmessage(s:"Stay On The Ground"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_ground");
    round_winifmid = true;
    delay(SECOND+20 - (2*game_speed));

    // Horribly maim anyone who is off the floor
    for (int i=0; i<MAXPLAYERS; i++)
    {
        if ((GetActorZ(TID_PLAYER+i)>>16) > 11)
        {
            thing_damage(TID_PLAYER+i, 10000000, MOD_BARREL);
        }
    }

    delay(SECOND);
}

Script "DoomWare_Server_Minigame25" (void) // Shoot the Target (Popup)
{
    int time=0;
    int SectorTarget = random(30, 36);
    minigame_wincondition1 = SectorTarget;
    HUDMessage(s:"Shoot the Target (Popup)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 210, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Check for winners
    do
    {
        time++;
        if (time == SECOND)
            Floor_RaiseInstant(SectorTarget, 0, 16);
        if (time == SECOND*2)
            Floor_LowerInstant(SectorTarget, 0, 16);
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame26" (void) // Survive (Boxing)
{
    HUDMessage(s:"Survive (Boxing)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_boxing");
    round_winifmid = true;
    minigame_fragpoints = true;
    Add_Observer(538);

    // Spawn some spectators
    SpawnSpotForced("ScriptedMarine", 108, TID_REMOVE, 0);
    SpawnSpotForced("ScriptedMarine", 309, TID_REMOVE, 64);
    SpawnSpotForced("ScriptedMarine", 334, TID_REMOVE, 128);
    SpawnSpotForced("ScriptedMarine", 336, TID_REMOVE, 192);
    SpawnSpotForced("ScriptedMarine", 332, TID_REMOVE, 32);
    SpawnSpotForced("ScriptedMarine", 333, TID_REMOVE, 96);
    SpawnSpotForced("ScriptedMarine", 335, TID_REMOVE, 160);
    SpawnSpotForced("ScriptedMarine", 337, TID_REMOVE, 224);
    Thing_Deactivate(TID_REMOVE);
    Thing_SetTranslation(TID_REMOVE, 6);
    SpawnSpotForced("ZombieMan", 267, TID_REMOVE, 32);
    SpawnSpotForced("ChaingunGuy", 268, TID_REMOVE, 64);
    SpawnSpotForced("Archvile", 269, TID_REMOVE, 64);
    SpawnSpotForced("BaronOfHell", 286, TID_REMOVE, 96);
    SpawnSpotForced("CyberDemon", 287, TID_REMOVE, 128);
    SpawnSpotForced("ShotgunGuy", 288, TID_REMOVE, 128);
    SpawnSpotForced("Revenant", 289, TID_REMOVE, 160);
    SpawnSpotForced("HellKnight", 306, TID_REMOVE, 192);
    SpawnSpotForced("DoomImp", 307, TID_REMOVE, 192);
    SpawnSpotForced("WolfensteinSS", 308, TID_REMOVE, 0);
    Thing_Deactivate(TID_REMOVE);

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 128, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6+17 -(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame27" (void) // Survive (Terry)
{
    HUDMessage(s:"Survive (Terry)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Terry");
    round_winifmid = true;

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 127, true, true);

	// Summon our lord and saviour
    SpawnSpotForced("dickfail", 129, TID_REMOVE, 0);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame28" (void) // Finish a Lap (E1M1)
{
    HUDMessage(s:"Finish a Lap (E1M1)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_e1m1");
    Add_Observer(758);
    Add_Observer(757);
    Add_Observer(759);
    Add_Observer(557);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 230, false, true);

    // Countdown until players can move
    SpawnSpotForced("Lakitu", 358, THING_REMOVE, 0);
    delay(SECOND*2);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*14-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame29" (void) // Duck Hunt
{
    hudmessage(s:"Duck Hunt"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_duck");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 66, true, true);

    // Spawn some birds to shoot
    SpawnSpotForced("Bird1", 126, TID_REMOVE, random(-180, 180));
    SpawnSpotForced("Bird2", 679, TID_REMOVE, random(-180, 180));
    SpawnSpotForced("Bird3", 149, TID_REMOVE, random(-180, 180));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame30" (void) // Dive into the Water
{
    int time = 0;
    int tp = 0;
    hudmessage(s:"Dive Into The Water"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Lava");

    // Move all players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 250, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6-(10*game_speed));

    time = random(15, SECOND);
    do
    {
        time--;

        // Hop players from water to lava zones
        if (time <= 0)
        {
            time = random(15, 35);
            if (tp == 0)
            {
                TeleportInSector(162, 436, 396, false);
                tp = 1;
            }
            else
            {
                TeleportInSector(161, 396, 436, false);
                tp = 0;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame31" (void) // Server - Reach the End (Boulders)
{
    int time = 0;
    hudmessage(s:"Reach the End (Boulders)"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_SNEAK");
    Add_Observer(558);

    // Move all players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 270, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    do
    {
        time++;
        if (time == 17)
        {
            Thing_ProjectileGravity(random(166, 169), 255, 128, 64, 0);
            Thing_ProjectileGravity(random(186, 189), 255, 128, 64, 0);
            time = 0;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame32" (void) // Server - Reach the End (Ice)
{
    int time = 0;
    int num = 0;
    hudmessage(s:"Reach the End (Ice)"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_echobs");
    Add_Observer(559);
    round_noforceend = true; // To give time to catch the 1-Up

    // Move all players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 290, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND+(10-game_speed)*31);

    // Start shaking the floor after a bit
    delay(SECOND);
    Radius_Quake2(227, 5, SECOND+(10-game_speed)*31, 0, 256, "DoomWare/IceMove");

    // Open the floor
    do
    {
        time++;
        if (time == (10-game_speed))
        {
            Floor_lowerInstant(45+num, 0, 128);
            Floor_lowerInstant(78+num, 0, 128);
            Ceiling_lowerInstant(78+num, 0, 128);
            Sector_setDamage(45+num, 999, mod_falling);
            time = 0;
            num++;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Fix the floor
    for (int i=0;i<31;i++)
    {
        Floor_raiseInstant(45+i, 0, 128);
        Ceiling_raiseInstant(78+i, 0, 128);
        Floor_raiseInstant(78+i, 0, 128);
        Sector_setDamage(45+i, 0, mod_falling);
		if (i%8 == 7)
			delay(1);
    }
}

Script "DoomWare_Server_Minigame33" (void) // Survive (Romero)
{
    hudmessage(s:"Survive (Romero)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_FINBOS");
    round_winifmid = true;

    // Move the dynamic lights up
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)+128.0, 0);

    // Spawn (other) God
    SpawnSpotForced("MechaRomero", 1, TID_REMOVE, random(0, 359));
    SpawnSpotForced("TeleportFog", 1, 42, 0);

    // Spawn more depending on the difficulty
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("MechaRomero", 3+random(0, 3), TID_REMOVE, random(0, 359));
        case 3:
        case 2:
        case 1:
            SpawnSpotForced("MechaRomero", 7+random(0, 3), TID_REMOVE, random(0, 359));
            break;
    }
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Raise the floor
    floor_raisebyvalue(20, 8, 64);
    floor_raisebyvalue(21, 8, 64);
    floor_raisebyvalue(22, 8, 64);

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(SECOND*game_speed));

    // Move things back
    floor_lowerbyvalue(20, 8, 64);
    floor_lowerbyvalue(21, 8, 64);
    floor_lowerbyvalue(22, 8, 64);
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)-128.0, 0);
}

Script "DoomWare_Server_Minigame34" (void) // Survive (Hoth)
{
    HUDMessage(s:"Survive (Hoth)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_hoth");
    round_winifmid = true;
    minigame_fragpoints = true;
    Add_Observer(576);
    Add_Observer(776);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 880, false, true);

    // Spawn a lot of different objects
    SpawnSpotForced("ATST", 246, TID_REMOVE, random(0, 359));
    SetThingSpecial(TID_REMOVE, ACS_ExecuteAlways, 14);
    SpawnSpotForced("HothTurret", 247, TID_REMOVE, random(0, 359));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*14-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame35" (void) // Climb the Colossus
{
    HUDMessage(s:"Climb the Colossus"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_sotc");

	// Start the rain
	SetActorState(577, "Activated");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 819, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*25-(SECOND*game_speed));

    // Return players back and stop the rain
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
	SetActorState(577, "Deactivated");
}

Script "DoomWare_Server_Minigame36" (void) // Get on the Colored Circle
{
    int color = random(0, 3);
    int i;
    HUDMessage(s:"Get on the Colored Circle"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_twistr");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 248, true, true);

    // Display the color after a while
    delay(35);
    switch (color)
    {
        case 0:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANBLUE");
            break;
        case 1:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANGRN");
            break;
        case 2:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANRED");
            break;
        case 3:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANYEL");
            break;
    }
    delay(SECOND*2-(10*game_speed));

    // Lower the floors
    for (i=0; i<5; i++)
    {
        if (i == color)
            continue;
        Floor_LowerInstant(111+i, 0, 16);
        Sector_setDamage(111+i, 200000, MOD_LAVA);
        ChangeFloor(111+i, "WFLAVA1");
    }
    delay(70);

    // Return the players
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Raise the floors back up
    for (i=0; i<5; i++)
    {
        if (i == color)
            continue;
        Floor_RaiseInstant(111+i, 0, 16);
        Sector_setDamage(111+i, 0, MOD_UNKNOWN);
        switch (i)
        {
            case 0:
                ChangeFloor(111, "TRANBLUE");
                break;
            case 1:
                ChangeFloor(112, "TRANGRN");
                break;
            case 2:
                ChangeFloor(113, "TRANRED");
                break;
            case 3:
                ChangeFloor(114, "TRANYEL");
                break;
            case 4:
                ChangeFloor(115, "PURE");
                break;
        }

    }
    SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "PURE");
}

Script "DoomWare_Server_Minigame37" (void) // Dive Down
{
    HUDMessage(s:"Dive Down"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_water");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 249, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*3+17-(10*game_speed));

    do
    {
        delay(1);

        // Make the player win if they're deep enough
        for (int i=0; i<MAXPLAYERS; i++)
            if (GetActorZ(TID_PLAYER+i) < 50.0)
                Player_Win(i);
    }
    while(minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame38" (void) // Repeat the Pattern
{
    int caco1, caco2, caco3, caco4;
    int i, j;
    hudmessage(s:"Repeat The Pattern"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_STALKS");
    caco1 = random(0, 5);
    caco2 = random(0, 5);
    caco3 = random(0, 5);
    caco4 = random(0, 5);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 310, false, true);

    // Clear out player solutions
    for (i=0; i<MAXPLAYERS; i++)
        for (j=0; j<4; j++)
            player_answer2[i][j] = -1;

    // Show the cacodemons to shoot
    delay(35);
    thing_damage(326+caco1, 1, 0);
    delay(SECOND-(5*game_speed));
    thing_damage(326+caco2, 1, 0);
    delay(SECOND-(5*game_speed));
    thing_damage(326+caco3, 1, 0);
    delay(SECOND-(5*game_speed));
    thing_damage(326+caco4, 1, 0);
    delay(SECOND-(5*game_speed));

    // Give time for the players to spit their answers
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4);

    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            if (player_answer1[i] > 0)
                player_answer1[i]--;

            for (j=0; j<4; j++)
            {
                if (player_answer2[i][j] == -1)
                    break;

                switch(j)
                {
                    case 0:
                        if (player_answer2[i][0] != caco1)
                            Player_Lose(i, false);
                        break;
                    case 1:
                        if (player_answer2[i][1] != caco2)
                            Player_Lose(i, false);
                        break;
                    case 2:
                        if (player_answer2[i][2] != caco3)
                            Player_Lose(i, false);
                        break;
                    case 3:
                        if (player_answer2[i][3] != caco4)
                            Player_Lose(i, false);
                        else
                            Player_Win(i);
                        break;
                }
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame39" (void) // Storm the Beach
{
    hudmessage(s:"Storm the beach"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_omaha");
    Add_Observer(777);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 340, false, true);

    // Spawn some horrible hitscanners
    SpawnSpotForced("ChaingunGuy", 1000, TID_REMOVE, 128);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Give time for the players to reach the beach
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5-(2*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame40" (void) // Survive (Dark Corridors)
{
    hudmessage(s:"Survive (Dark Corridors)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_doom");
    minigame_fragpoints = true;
    round_winifmid = true;
    Add_Observer(778);
    Add_Observer(779);
    Add_Observer(797);
    Add_Observer(796);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 360, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame41" (void) // Go To The Light
{
    int i;
    hudmessage(s:"Go To The Light"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_AMPIE");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 206, true, true);

    // Pick a random sector to mark as safe
    int ceil = random(0, 11);
    Light_ChangeToValue(116+ceil, 256);
    delay(SECOND-(5*game_speed));

    // Lower the ceiling
    for (i=0; i<13; i++)
        if (i != ceil)
            Ceiling_LowerAndCrush(116+i, 20+(2*game_speed), 100, 1);
    delay(SECOND*3+17 -(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Raise the ceiling back up
    for (i=0; i<13; i++)
        if (ceil != i)
            Ceiling_RaiseByValue(116+i, 16, 256);
    Light_ChangeToValue(116+ceil, 16);
}

Script "DoomWare_Server_Minigame42" (void) // Survive (Rockets)
{
    hudmessage(s:"Survive (Rockets)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_ROCKET");
    Add_Observer(656);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 226, true, true);

    //Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*13-(SECOND*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame43" (void) // Don't Blow Your Brains Out
{
    HUDMessage(s:"Don't Blow Your Brains Out"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_rave");
    round_winifmid = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(5*game_speed));
}

Script "DoomWare_Server_Minigame44" (void) // Don't Equip Weapon
{
    HUDMessage(s:"Don't Equip Weapon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    minigame_wincondition1 = random(1, 7);
    SetMusic("d_weapon");
    round_winifmid = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(3*game_speed));
}

Script "DoomWare_Server_Minigame45" (void) // Finish a Lap (Rainbow Road)
{
    HUDMessage(s:"Finish a Lap (Rainbow Road)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_rainbw");
    Add_Observer(798);
    Add_Observer(579);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 380, false, true);

    // Countdown until players can move
    SpawnSpotForced("Lakitu", 358, THING_REMOVE, 0);
    delay(SECOND*2);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*39-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame46" (void) // Reach the End (Bigger Swapping Boxes)
{
    int time = SECOND*28+20-(14*game_speed);
    int box = 0;
    Add_Observer(596);
    hudmessage(s:"Reach the End (Bigger Swapping Boxes)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_boxes");
    Sector_SetDamage(136, 10000, MOD_FALLING);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 420, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, time);

    // Make the boxes swap
    time = 0;
    do
    {
        int i;
        time++;
        if (time == 89)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "3";
        else if (time == 89+17)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "2";
        else if (time == 89+34)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "1";
        else if (time == 89+51)
        {
            time = 0;
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "";
            if (box == 0)
            {
                Floor_LowerInstant(135, 0, 32);
                Floor_RaiseInstant(136, 0, 32);
                Floor_LowerInstant(137, 0, 36);
                Floor_RaiseInstant(138, 0, 40);
                Floor_LowerInstant(139, 0, 44);
                ChangeFloor(136, "DEM4_5");
                ChangeFloor(138, "DEM4_5");
                ChangeFloor(135, "f_sky1");
                ChangeFloor(137, "f_sky1");
                ChangeFloor(139, "f_sky1");
                Sector_SetDamage(136, 0, MOD_FALLING);
                Sector_SetDamage(138, 0, MOD_FALLING);
                Sector_SetDamage(135, 10000, MOD_FALLING);
                Sector_SetDamage(137, 10000, MOD_FALLING);
                Sector_SetDamage(139, 10000, MOD_FALLING);
                box = 1;
            }
            else
            {
                Floor_RaiseInstant(135, 0, 32);
                Floor_LowerInstant(136, 0, 32);
                Floor_RaiseInstant(137, 0, 36);
                Floor_LowerInstant(138, 0, 40);
                Floor_RaiseInstant(139, 0, 44);
                ChangeFloor(136, "f_sky1");
                ChangeFloor(138, "f_sky1");
                ChangeFloor(135, "DEM3_5");
                ChangeFloor(137, "DEM3_5");
                ChangeFloor(139, "DEM3_5");
                Sector_SetDamage(136, 10000, MOD_FALLING);
                Sector_SetDamage(138, 10000, MOD_FALLING);
                Sector_SetDamage(135, 0, MOD_FALLING);
                Sector_SetDamage(137, 0, MOD_FALLING);
                Sector_SetDamage(139, 0, MOD_FALLING);
                box = 0;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);

    // Fix the boxes
    if (box == 1)
    {
        Floor_RaiseInstant(135, 0, 32);
        Floor_LowerInstant(136, 0, 32);
        Floor_RaiseInstant(137, 0, 36);
        Floor_LowerInstant(138, 0, 40);
        Floor_RaiseInstant(139, 0, 44);
        ChangeFloor(136, "f_sky1");
        ChangeFloor(138, "f_sky1");
        ChangeFloor(135, "DEM3_5");
        ChangeFloor(137, "DEM3_5");
        ChangeFloor(139, "DEM3_5");
        Sector_SetDamage(136, 10000, MOD_FALLING);
        Sector_SetDamage(138, 10000, MOD_FALLING);
        Sector_SetDamage(135, 0, MOD_FALLING);
        Sector_SetDamage(137, 0, MOD_FALLING);
        Sector_SetDamage(139, 0, MOD_FALLING);
    }
}

Script "DoomWare_Server_Minigame47" (void) // Survive (Banana)
{
    HUDMessage(s:"Survive (Banana)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_banana");
    round_winifmid = true;

    // Spawn some warnings
    SpawnSpotForced("Avoid", 1, TID_REMOVE, random(0, 359));
    if (game_speed > 1)
        SpawnSpotForced("Avoid", 57, TID_REMOVE, random(0, 359));
    if (game_speed == 4)
        SpawnSpotForced("Avoid", 59, TID_REMOVE, random(0, 359));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));
    delay(SECOND*4-(game_speed*17));

    // Spawn the banana
    SpawnSpotForced("Banana", TID_REMOVE, TID_REMOVE+1, random(0, 359));
    thing_destroy(TID_REMOVE, 0);
    delay(SECOND*2);
}

Script "DoomWare_Server_Minigame48" (void) // Survive (Spike)
{
    HUDMessage(s:"Survive (Banana)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_spiky");
    round_winifmid = true;

    // Spawn some warnings
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Avoid", 5, TID_REMOVE+1, random(0, 359));
        case 3:
            SpawnSpotForced("Avoid", 3, TID_REMOVE+1, random(0, 359));
        case 2:
            SpawnSpotForced("Avoid", 9, TID_REMOVE+1, random(0, 359));
        case 1:
            SpawnSpotForced("Avoid", 7, TID_REMOVE+1, random(0, 359));
        default:
            SpawnSpotForced("Avoid", 1, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 58, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 59, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 60, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 57, TID_REMOVE+1, random(0, 359));
            break;
    }
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));
    delay(SECOND*3-(game_speed*7));

    // Spawn the spikes
    SpawnSpotForced("LilithSpikeSpawner", TID_REMOVE+1, TID_REMOVE, random(0, 359));
    thing_destroy(TID_REMOVE+1, 0);
    delay(SECOND + 17);
}

Script "DoomWare_Server_Minigame49" (void) // Math
{
    int i;
    HUDMessage(s:"Math"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_MATH");

    // Create a problem
    int operation = random(0, 2);
    int result;
    minigame_wincondition3 = operation;
    switch (operation)
    {
        case 0:
            minigame_wincondition1 = random(0, 49);
            minigame_wincondition2 = random(0, 50);
            result = minigame_wincondition1 + minigame_wincondition2;
            break;
        case 1:
            minigame_wincondition1 =  random(50, 99);
            minigame_wincondition2 =  random(0, 50);
            result = minigame_wincondition1 - minigame_wincondition2;
            breaK;
        case 2:
            minigame_wincondition1 =  random(0, 10);
            minigame_wincondition2 =  random(0, 9);
            result = minigame_wincondition1 * minigame_wincondition2;
            break;
    }

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 400, false, true);

    // Clear out player solutions
    for (i=0; i<MAXPLAYERS; i++)
        for (int j=0; j<2; j++)
            player_answer2[i][j] = -1;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5 - (game_speed*7));

    // Check if the user spat out the correct answer
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;

            if (player_answer1[i] > 0)
                player_answer1[i]--;

            if ((result < 10 && player_answer2[i][0] == -1) || (result >= 10 && player_answer2[i][1] == -1))
                continue;

            if (result < 10)
            {
                if (player_answer2[i][0] == result)
                    Player_Win(i);
                else
                    Player_Lose(i, false);
            }
            else
            {
                if (player_answer2[i][0] == result/10 && player_answer2[i][1] == result%10)
                    Player_Win(i);
                else
                    Player_Lose(i, false);
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame50" (void) // Survive (Bullet Hell)
{
    HUDMessage(s:"Survive (Bullet Hell)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_trotle");
    Add_Observer(597);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 338, true, true);

    // Spawn Lilith, from the WAD I never finished making :(
    SpawnSpotForced("Lilith", 339, TID_REMOVE, 192);
    NoiseAlert(TID_PLAYER, TID_PLAYER);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4+17 + (SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Award survivors with an achievement
	delaY(2);
    for (int i=0; i<MAXPLAYERS; i++)
        if (player_midround[i] == true)
            Give_Achievement(i, ACHIEVE_ID_BULLETHELL);
}

Script "DoomWare_Server_Minigame51" (void) // Clean your weapon
{
    HUDMessage(s:"Clean your weapon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CLEAN");
    minigame_wincondition1 = 1337; // To force a 320x240 viewsprite

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*14+10-(12*game_speed));
}

Script "DoomWare_Server_Minigame52" (void) // The Air is Lava
{
    HUDMessage(s:"The Air is Lava"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_LAVA");
    round_winifmid = true;

    // Lower the lights
    floor_lowerbyvalue(20, 8, 10);
    floor_lowerbyvalue(21, 8, 8);
    floor_lowerbyvalue(22, 8, 8);
    delay(30);

    // Silently teleport everyone to a copy of the main arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 357, true, false);
	Light_Fade(148, 0, SECOND-(2*game_speed));
	Light_Fade(149, 0, SECOND-(2*game_speed));
	Light_Fade(253, 0, SECOND-(2*game_speed));
	Light_Fade(856, 0, SECOND-(2*game_speed));
    delay(SECOND-(2*game_speed));

    // KIll people not underwater with no remorse
    minigame_wincondition1 = 1;
    delay(SECOND+32-(7*game_speed));

    // Raise the floor back up and silently bring everyone back
    floor_raisebyvalue(20, 8, 10);
    floor_raisebyvalue(21, 8, 8);
    floor_raisebyvalue(22, 8, 8);
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, false);
	Light_ChangeToValue(148, 192);
	Light_ChangeToValue(149, 192);
	Light_ChangeToValue(253, 192);
	Light_ChangeToValue(856, 192);
}

Script "DoomWare_Server_Minigame53" (void) // Drink
{
    HUDMessage(s:"Drink"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DRINK");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7+5-(12*game_speed));
}

Script "DoomWare_Server_Minigame54" (void) // Survive (Chilli)
{
    HUDMessage(s:"Survive (Chilli)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_wtfbmb");
    round_winifmid = true;

    // Create some warnings
    SpawnSpotForced("Avoid", 1, TID_REMOVE+1, random(0, 359));
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Avoid", 59, TID_REMOVE+1, random(0, 359));
        case 3:
        case 2:
            SpawnSpotForced("Avoid", 57, TID_REMOVE+1, random(0, 359));
            break;
    }
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));
    delay(SECOND*4-(game_speed*17));

    // Spawn the chilli
    SetMusic("");
    SpawnSpotForced("Chilli", TID_REMOVE+1, TID_REMOVE, random(0, 359));
    thing_destroy(TID_REMOVE+1, 0);
    delay(SECOND + 18);

    // Make the world tremble at the sight of it's spicyness
    Radius_Quake2(1, 5, SECOND*3+21, 0, 512, "DoomWare/IceMove");
    delay(SECOND*3+21);
}

Script "DoomWare_Server_Minigame55" (void) // Hit the Real Barrel
{
    HUDMessage(s:"Hit the Real Barrel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_BRLCHS");

    // Spawn a bunch of fake and real explosive barrels
    int real = random(1, 9);
    for (int i=1; i<8; i++)
        if (real != i)
            SpawnSpot ("ExplosiveBarrelLegs", 2+i, TID_REMOVE);
    if (real != 9)
        SpawnSpot ("ExplosiveBarrelLegs", 1, TID_REMOVE);
    if (real == 9)
        SpawnSpot ("ExplosiveBarrelReal", 1, TID_REMOVE);
    else
        SpawnSpot ("ExplosiveBarrelReal", 2+real, TID_REMOVE);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6+10-(20*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        Check_FailRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame56" (void) // Survive (Spike Circle)
{
    HUDMessage(s:"Survive (Spike Circle)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Factry");
    round_winifmid = true;
    Add_Observer(598);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 460, false, true);

    // Activate the rotaty dead spikes of doom
    thing_activate(64);
    thing_activate(65);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*8+20+(20*game_speed));

    // Give the spikes a break
    thing_deactivate(64);
    thing_deactivate(65);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame57" (void) // Eat The Chocolate
{
    HUDMessage(s:"Eat The Chocolate"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DRINK");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4+15-(12*game_speed));
}

Script "DoomWare_Server_Minigame58" (void) // Survive (Wind)
{
    HUDMessage(s:"Survive (Wind)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_MUNCH");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 359, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+20-(12*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame59" (void) // Get to Hissy
{
    HUDMessage(s:"Get to Hissy"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_HISSY");
    Add_Observer(616);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 480, false, true);

    // Spawn the Hissy hogger himself
    SpawnSpotForced("Linguica", 376, TID_REMOVE, 192);
    switch(game_speed)
    {
        case 4:
            SpawnSpotForced("Linguica", 379, TID_REMOVE, 192);
        case 3:
        case 2:
            SpawnSpotForced("Linguica", 378, TID_REMOVE, 192);
            break;
    }

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*8+20-(10*game_speed));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame60" (void) // Count the Lost Souls
{
    int i;
    HUDMessage(s:"Count The Lost Souls"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_count");
    minigame_wincondition1 = 0;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 500, false, true);

    // Clear out player solutions
    for (i=0; i<MAXPLAYERS; i++)
        for (int j=0; j<2; j++)
            player_answer2[i][j] = -1;

    // Spawn some Lost Souls
    int result = random(10, 30);
    minigame_wincondition1 = 0;
    for (i=0;i<result;i++)
    {
        SpawnForced("SkullCounter", GetActorX(397)+random(0, +64.0), GetActorY(397)+random(-64.0, +64.0), GetActorz(397)+random(-32.0, +32.0), TID_REMOVE, 0);
        delay(18-random(5-game_speed, 7));
    }
    delay(SECOND*2);

    // Move the players to the numbers
    minigame_wincondition1 = 1;
    for (i=0; i<MAXPLAYERS; i++)
        thing_move(TID_PLAYER+i, 400+i, false);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*3-(game_speed*7));

    // Check if the user spat out the correct answer
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;

            if (player_answer1[i] > 0)
                player_answer1[i]--;

            if (result >= 10 && player_answer2[i][1] == -1)
                continue;

            if (player_answer2[i][0] == result/10 && player_answer2[i][1] == result%10)
                Player_Win(i);
            else
                Player_Lose(i, false);
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame61" (void) // Reach the End (Hurdles)
{
    HUDMessage(s:"Reach the End (Hurdles)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_HURDLE");
    Add_Observer(617);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 520, false, true);

    // Spawn a wall to prevent players from going forward
    SpawnSpotForced("InvisibleBridge32", 398, TID_REMOVE, 0);
    delay(4);
    thing_remove(TID_REMOVE);

    // Countdown until players can move
    delay(SECOND*2+26);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*12+10-(17*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame62" (void) // Cross the Road
{
    int time = 0;
    hudmessage(s:"Cross the Road"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CHICKN");
    Add_Observer(618);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 540, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*8+20-(15*game_speed));

    // Keep the roads busy
    do
    {
        if (time == 0)
        {
			int tran = random(11, 16);
            SpawnProjectile(random(416, 417), "DangerousCar", 0, 256, 0, 0, TID_REMOVE);
			if (tran != 16)
				Thing_SetTranslation(TID_REMOVE, tran);
			Thing_ChangeTID(TID_REMOVE, TID_REMOVE+1);

			tran = random(11, 16);
            SpawnProjectile(random(418, 419), "DangerousCar", 128, 256, 0, 0, TID_REMOVE);
			if (tran != 16)
				Thing_SetTranslation(TID_REMOVE, tran);
			Thing_ChangeTID(TID_REMOVE, TID_REMOVE+1);

            time = random(15, 70);
        }
        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame63" (void) // Collect a Potion
{
    hudmessage(s:"Collect a Potion"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_THIEF");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 399, true, true);

    // Spawn some thiefs
    SpawnSpotForced("BlueThief", 437, TID_REMOVE, random(0, 256));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+25-(15*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame64" (void) // Reach the End (Skyhook)
{
    int i;
    hudmessage(s:"Reach the End (Skyhook)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_SKYHOK");

    // Place the polyobjects in the correct place (TEARS AHEAD, TRY BACK)
    int thing1 = random(1, 4);
    int thing2 = random(1, 4);
    int thing3 = random(1, 4);
    int thing4 = random(1, 4);
    int thing5 = random(1, 4);
    int thing6 = random(1, 4);
    int thing7 = random(1, 4);
    int thing8 = random(1, 4);
    {{if (thing1 == 1)
    {
        SetLineTexture(2, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(2, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(4, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(4, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(0, 128, 10592, 3584);
        Polyobj_MoveTo(1, 128, 10784, 3584);
    }
    if (thing1 == 2)
    {
        SetLineTexture(2, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(2, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(4, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(4, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(0, 128, 10592, 3584);
        Polyobj_MoveTo(2, 128, 10592, 3584);
    }
    if (thing1 == 3)
    {
        SetLineTexture(2, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(2, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(4, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(4, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(2, 128, 10592, 3584);
        Polyobj_MoveTo(3, 128, 10784, 3584);
    }
    if (thing1 == 4)
    {
        SetLineTexture(2, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(2, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(4, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(4, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(1, 128, 10784, 3584);
        Polyobj_MoveTo(3, 128, 10784, 3584);
    }}

    {if (thing2 == 1)
    {
        SetLineTexture(5, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(5, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(6, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(6, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(7, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(7, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(4, 128, 10592, 3584+384);
        Polyobj_MoveTo(5, 128, 10784, 3584+384);
    }
    if (thing2 == 2)
    {
        SetLineTexture(5, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(5, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(6, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(6, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(7, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(7, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(4, 128, 10592, 3584+384);
        Polyobj_MoveTo(6, 128, 10592, 3584+384);
    }
    if (thing2 == 3)
    {
        SetLineTexture(5, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(5, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(6, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(6, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(7, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(7, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(6, 128, 10592, 3584+384);
        Polyobj_MoveTo(7, 128, 10784, 3584+384);
    }
    if (thing2 == 4)
    {
        SetLineTexture(5, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(5, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(6, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(6, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(7, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(7, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(5, 128, 10784, 3584+384);
        Polyobj_MoveTo(7, 128, 10784, 3584+384);
    }}

    {if (thing3 == 1)
    {
        SetLineTexture(8, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(8, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(9, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(9, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(10, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(10, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(8, 128, 10592, 3584+384*2);
        Polyobj_MoveTo(9, 128, 10784, 3584+384*2);
    }
    if (thing3 == 2)
    {
        SetLineTexture(8, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(8, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(9, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(9, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(10, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(10, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(8, 128, 10592, 3584+384*2);
        Polyobj_MoveTo(10, 128, 10592, 3584+384*2);
    }
    if (thing3 == 3)
    {
        SetLineTexture(8, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(8, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(9, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(9, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(10, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(10, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(10, 128, 10592, 3584+384*2);
        Polyobj_MoveTo(11, 128, 10784, 3584+384*2);
    }
    if (thing3 == 4)
    {
        SetLineTexture(8, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(8, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(9, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(9, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(10, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(10, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(9, 128, 10784, 3584+384*2);
        Polyobj_MoveTo(11, 128, 10784, 3584+384*2);
    }}

    {if (thing4 == 1)
    {
        SetLineTexture(11, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(11, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(12, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(12, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(13, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(13, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(8+4, 128, 10592, 3584+384*3);
        Polyobj_MoveTo(9+4, 128, 10784, 3584+384*3);
    }
    if (thing4 == 2)
    {
        SetLineTexture(11, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(11, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(12, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(12, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(13, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(13, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(8+4, 128, 10592, 3584+384*3);
        Polyobj_MoveTo(10+4, 128, 10592, 3584+384*3);
    }
    if (thing4 == 3)
    {
        SetLineTexture(11, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(11, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(12, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(12, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(13, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(13, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(10+4, 128, 10592, 3584+384*3);
        Polyobj_MoveTo(11+4, 128, 10784, 3584+384*3);
    }
    if (thing4 == 4)
    {
        SetLineTexture(11, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(11, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(12, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(12, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(13, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(13, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(9+4, 128, 10784, 3584+384*3);
        Polyobj_MoveTo(11+4, 128, 10784, 3584+384*3);
    }}

    {if (thing5 == 1)
    {
        SetLineTexture(14, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(14, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(15, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(15, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(16, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(16, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(8+8, 128, 10592, 3584+384*4);
        Polyobj_MoveTo(9+8, 128, 10784, 3584+384*4);
    }
    if (thing5 == 2)
    {
        SetLineTexture(14, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(14, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(15, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(15, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(16, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(16, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(8+8, 128, 10592, 3584+384*4);
        Polyobj_MoveTo(10+8, 128, 10592, 3584+384*4);
    }
    if (thing5 == 3)
    {
        SetLineTexture(14, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(14, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(15, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(15, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(16, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(16, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(10+8, 128, 10592, 3584+384*4);
        Polyobj_MoveTo(11+8, 128, 10784, 3584+384*4);
    }
    if (thing5 == 4)
    {
        SetLineTexture(14, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(14, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(15, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(15, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(16, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(16, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(9+8, 128, 10784, 3584+384*4);
        Polyobj_MoveTo(11+8, 128, 10784, 3584+384*4);
    }}

    {if (thing6 == 1)
    {
        SetLineTexture(17, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(17, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(18, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(18, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(19, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(19, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(8+12, 128, 10592, 3584+384*5);
        Polyobj_MoveTo(9+12, 128, 10784, 3584+384*5);
    }
    if (thing6 == 2)
    {
        SetLineTexture(17, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(17, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(18, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(18, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(19, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(19, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(8+12, 128, 10592, 3584+384*5);
        Polyobj_MoveTo(10+12, 128, 10592, 3584+384*5);
    }
    if (thing6 == 3)
    {
        SetLineTexture(17, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(17, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(18, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(18, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(19, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(19, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(10+12, 128, 10592, 3584+384*5);
        Polyobj_MoveTo(11+12, 128, 10784, 3584+384*5);
    }
    if (thing6 == 4)
    {
        SetLineTexture(17, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(17, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(18, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(18, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(19, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(19, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(9+12, 128, 10784, 3584+384*5);
        Polyobj_MoveTo(11+12, 128, 10784, 3584+384*5);
    }}

    {if (thing7 == 1)
    {
        SetLineTexture(20, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(20, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(21, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(21, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(22, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(22, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(8+16, 128, 10592, 3584+384*6);
        Polyobj_MoveTo(9+16, 128, 10784, 3584+384*6);
    }
    if (thing7 == 2)
    {
        SetLineTexture(20, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(20, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(21, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(21, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(22, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(22, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(8+16, 128, 10592, 3584+384*6);
        Polyobj_MoveTo(10+16, 128, 10592, 3584+384*6);
    }
    if (thing7 == 3)
    {
        SetLineTexture(20, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(20, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(21, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(21, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(22, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(22, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(10+16, 128, 10592, 3584+384*6);
        Polyobj_MoveTo(11+16, 128, 10784, 3584+384*6);
    }
    if (thing7 == 4)
    {
        SetLineTexture(20, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(20, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(21, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(21, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(22, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(22, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(9+16, 128, 10784, 3584+384*6);
        Polyobj_MoveTo(11+16, 128, 10784, 3584+384*6);
    }}

    {if (thing8 == 1)
    {
        SetLineTexture(23, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(23, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(24, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(24, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(25, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
        SetLineTexture(25, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
        Polyobj_MoveTo(8+20, 128, 10592, 3584+384*7);
        Polyobj_MoveTo(9+20, 128, 10784, 3584+384*7);
    }
    if (thing8 == 2)
    {
        SetLineTexture(23, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(23, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(24, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(24, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(25, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(25, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        Polyobj_MoveTo(8+20, 128, 10592, 3584+384*7);
        Polyobj_MoveTo(10+20, 128, 10592, 3584+384*7);
    }
    if (thing8 == 3)
    {
        SetLineTexture(23, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(23, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(24, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(24, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(25, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
        SetLineTexture(25, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
        Polyobj_MoveTo(10+20, 128, 10592, 3584+384*7);
        Polyobj_MoveTo(11+20, 128, 10784, 3584+384*7);
    }
    if (thing8 == 4)
    {
        SetLineTexture(23, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(23, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(24, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(24, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        SetLineTexture(25, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
        SetLineTexture(25, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
        Polyobj_MoveTo(9+20, 128, 10784, 3584+384*7);
        Polyobj_MoveTo(11+20, 128, 10784, 3584+384*7);
    }}
    }

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 560, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*8-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Reset the Skyhook
    for (i=0; i<8; i++)
    {
        Polyobj_MoveTo(0+i*4, 128, 11024, 3584+384*i);
        Polyobj_MoveTo(1+i*4, 128, 11248, 3584+384*i);
        Polyobj_MoveTo(2+i*4, 128, 11472, 3584+384*i);
        Polyobj_MoveTo(3+i*4, 128, 11696, 3584+384*i);
    }
}

Script "DoomWare_Server_Minigame65" (void) // Spam the Indicated Button
{
    int time = random(15, SECOND*2);
    hudmessage(s:"Spam the Indicated Button"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_BUTCHG");
    minigame_wincondition1 = 1337; // To force a 320x240 viewsprite
    minigame_wincondition2 = 0;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*11+20-(5*game_speed));

    // Consantly change the objective
    do
    {
        time--;
        if (time == 0)
        {
            AmbientSound("DoomWare/ButtonChange", 127);
            switch (minigame_wincondition2)
            {
                case 0:
                    minigame_wincondition2 = random(1, 2);
                    time = random(SECOND, SECOND*2);
                    break;
                case 1:
                    minigame_wincondition2 = random(0, 2);
                    if (minigame_wincondition2 == 1)
                        minigame_wincondition2 = 0;
                    time = random(SECOND, SECOND*2);
                    break;
                case 2:
                    minigame_wincondition2 = random(0, 1);
                    time = random(SECOND, SECOND*2);
                    break;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame66" (void) // Don't Get Wet
{
    int i;
    hudmessage(s:"Don't Get Wet"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_AMPIE");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 439, true, true);

    // Spawn an umbrella
    int ceil2 = random(0, 4);
    if (ceil2 == 4)
        SpawnSpotForced("Umbrella", 476, TID_REMOVE, random(0, 256));
    else
        SpawnSpotForced("Umbrella", 456+ceil2, TID_REMOVE, random(0, 256));
    delay(SECOND-(5*game_speed));

    // Start the downpour
    if (ceil2 == 0)
    {
        Ceiling_LowerByValue(173, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(174, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(175, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(173, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(174, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(175, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 1)
    {
        Ceiling_LowerByValue(176, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(177, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(178, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(176, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(177, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(178, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 2)
    {
        Ceiling_LowerByValue(163, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(164, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(165, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(163, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(164, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(165, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 3)
    {
        Ceiling_LowerByValue(167, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(168, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(169, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(167, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(168, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(169, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 4)
    {
        Ceiling_LowerByValue(170, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(171, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(172, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(170, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(171, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(172, 24+(2*game_speed), 100, 1);
    }

    for (i=0; i<16; i++)
        ChangeCeiling(163+i, "WFWater1");

    Ceiling_LowerAndCrush(166, 24+(2*game_speed), 100, 1);
    delay(SECOND*4+15-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Raise the water back up
    for (i=0; i<16; i++)
        ChangeCeiling(163+i, "F_SKY1");
    Ceiling_RaiseByValue(166, 64, 384);
    if (ceil2 == 0)
    {
        Ceiling_RaiseByValue(173, 64, 232);
        Ceiling_RaiseByValue(174, 64, 256);
        Ceiling_RaiseByValue(175, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(173, 64, 384);
        Ceiling_RaiseByValue(174, 64, 384);
        Ceiling_RaiseByValue(175, 64, 384);
    }

    if (ceil2 == 1)
    {
        Ceiling_RaiseByValue(176, 64, 232);
        Ceiling_RaiseByValue(177, 64, 256);
        Ceiling_RaiseByValue(178, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(176, 64, 384);
        Ceiling_RaiseByValue(177, 64, 384);
        Ceiling_RaiseByValue(178, 64, 384);
    }

    if (ceil2 == 2)
    {
        Ceiling_RaiseByValue(163, 64, 232);
        Ceiling_RaiseByValue(164, 64, 256);
        Ceiling_RaiseByValue(165, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(163, 64, 384);
        Ceiling_RaiseByValue(164, 64, 384);
        Ceiling_RaiseByValue(165, 64, 384);
    }

    if (ceil2 == 3)
    {
        Ceiling_RaiseByValue(167, 64, 232);
        Ceiling_RaiseByValue(168, 64, 256);
        Ceiling_RaiseByValue(169, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(167, 64, 384);
        Ceiling_RaiseByValue(168, 64, 384);
        Ceiling_RaiseByValue(169, 64, 384);
    }

    if (ceil2 == 4)
    {
        Ceiling_RaiseByValue(170, 64, 232);
        Ceiling_RaiseByValue(171, 64, 256);
        Ceiling_RaiseByValue(172, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(170, 64, 384);
        Ceiling_RaiseByValue(171, 64, 384);
        Ceiling_RaiseByValue(172, 64, 384);
    }

}

Script "DoomWare_Server_Minigame67" (void) // Reach the End (Factory Line)
{
    HUDMessage(s:"Reach The End (Factory)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Factry");
    Add_Observer(799);
    Add_Observer(800);
    Add_Observer(636);
    Add_Observer(801);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 438, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*37+5-((SECOND+5)*game_speed));

    // Spawn some Flamethrowers
    SpawnSpotForced("FlameProjectiler", 477, TID_REMOVE, 0);
    SpawnSpotForced("FlameProjectiler", 479, TID_REMOVE, 128);
    delay(SECOND*2);
    SpawnSpotForced("FlameProjectiler", 478, TID_REMOVE, 0);

    while (minigame_timer != TIMER_OFF)
        delay(1);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame68" (void) // Pick Up The Key
{
    HUDMessage(s:"Pick Up The Key"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_twistr");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 496, true, true);

    // Spawn the cards
    SpawnSpotForced("YellowCard", 497, TID_REMOVE, 0);
    SpawnSpotForced("BlueCard", 498, TID_REMOVE+1, 0);
    SpawnSpotForced("RedCard", 499, TID_REMOVE+2, 0);
    Thing_SetSpecial(TID_REMOVE, 226, 243, 0, 0);
    Thing_SetSpecial(TID_REMOVE+1, 226, 243, 0, 1);
    Thing_SetSpecial(TID_REMOVE+2, 226, 243, 0, 2);

    // Randomly pick the winning key
    minigame_wincondition1 = random(0, 2);
    delay(SECOND);
    switch (minigame_wincondition1)
    {
        case 0:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANBLUE");
            break;
        case 1:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANRED");
            break;
        case 2:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANYEL");
            break;
    }

    // Give players time to catch the key
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*3-(10*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);

    // Reset the color
    SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "PURE");
}

Script "DoomWare_Server_Minigame69" (void) // Survive (Hell Deathmatch)
{
    HUDMessage(s:"Survive (Hell Deathmatch)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_DINO");
	round_winifmid = true;
    Add_Observer(802);
    Add_Observer(803);
    Add_Observer(804);
    Add_Observer(637);
    Add_Observer(805);
    Add_Observer(806);
    Add_Observer(807);
    minigame_fragpoints = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 580, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*22+30-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame70" (void) // Eat
{
    HUDMessage(s:"Eat"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_sushi");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 600, false, true);

    // Spawn the food
    minigame_wincondition1 = random(0, 1);
    SpawnSpotForced("Food_Toro", 516, TID_REMOVE, 0);
    int thingy = random(0, 1);
    if (thingy == 1)
        SpawnSpotForced("Food_SalmonRoll1", 639, TID_REMOVE, 0);
    else
        SpawnSpotForced("Food_SalmonRoll2", 639, TID_REMOVE, 0);
    SpawnSpotForced("Food_Shrimp", 657, TID_REMOVE, 0);
    SpawnSpotForced("Food_EggRoll", 658, TID_REMOVE, 0);
    thingy = random(0, 1);
    if (thingy == 1)
        SpawnSpotForced("Food_Sushi1", 659, TID_REMOVE, 0);
    else
        SpawnSpotForced("Food_Sushi1", 659, TID_REMOVE, 0);
    SpawnSpotForced("Food_Tea", 675, TID_REMOVE, 0);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame71" (void) // Find a Pokemon
{
    HUDMessage(s:"Find a Pokemon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_pkmn");
    SpawnSpotForced("PokemonTrigger", 517, TID_REMOVE, 0);
    minigame_wincondition1 = 1338; // To force a 20x18 viewsprite

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 620, false, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame72" (void) // Survive (Disappearing Floor)
{
    int i;
    int dropped = 0;
    int state = 0;
    bool firstdrop = true;
    round_winifmid = true;
    HUDMessage(s:"Survive (Disappearing Floor)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_twistr");
    Add_Observer(638);

    // We'll make use of the player_answer variables to save up on making more globals
    // Start by filling in a list of all numbers from 1 to 9
    for (i=0; i<9; i++)
        player_answer1[i] = i;

    // Shuffle that array
    for (i=0; i<9; i++)
    {
        int j = random(i, 8);
        int k = player_answer1[i];
        player_answer1[i] = player_answer1[j];
        player_answer1[j] = k;
    }

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 519, true, true);

    // Start the timer
    int time = SECOND*2 + ((8-game_speed)*6)*8 + (SECOND-game_speed*2)*8;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, time);
    time = SECOND*2;

    // Handle the floors
    do
    {
        time--;
        if (time == 0 && dropped != 8)
        {
            switch(state)
            {
                case 4:
                case 2:
                case 0:
                    changefloor(193+player_answer1[dropped], "TRANYEL");
                    SectorSound("doomware/blip", 127);
                    time = (8-game_speed);
                    if (firstdrop)
                    {
                        // Warn newcomers to avoid the color
                        int sector = player_answer1[dropped];
                        SpawnSpotForced("Avoid", 519, TID_REMOVE, 0);
                        SetActorPosition(TID_REMOVE, GetActorX(TID_REMOVE)-213.0+213.0*(sector%3), GetActorY(TID_REMOVE)+213.0-213.0*(sector/3), GetActorZ(TID_REMOVE), false);
                        Thing_Destroy(TID_REMOVE, false, 0);
                        firstdrop = false;
                    }
                    break;
                case 5:
                case 3:
                case 1:
                    changefloor(193+player_answer1[dropped], "PURE");
                    time = (8-game_speed);
                    break;
                case 6:
                    SectorSound("doomware/bloop", 127);
                    Floor_LowerInstant(193+player_answer1[dropped], 0, 16);
                    Sector_setDamage(193+player_answer1[dropped], 200000, MOD_LAVA);
                    ChangeFloor(193+player_answer1[dropped], "WFLAVA1");
                    dropped++;
                    time = (SECOND-game_speed*2);
                    break;
            }
            state = (state+1)%7;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Put the floors back to normal
    for (i=0;i<9;i++)
    {
        if (i < dropped)
        {
            Floor_RaiseInstant(193+player_answer1[i], 0, 16);
            Sector_setDamage(193+player_answer1[i], 0, MOD_LAVA);
        }
        ChangeFloor(193+player_answer1[i], "PURE");
    }
}

Script "DoomWare_Server_Minigame73" (void) // Mine an ore
{
    HUDMessage(s:"Mine an ore"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_snight");
    minigame_wincondition1 = random(0, 2);

    // Spawn the ores
    SpawnSpotForced("CopperOre", 676, TID_REMOVE, 0);
    SpawnSpotForced("TinOre", 677, TID_REMOVE, 0);
    SpawnSpotForced("IronOre", 678, TID_REMOVE, 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 640, false, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+25-(10*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame74" (void) // Reach the End (Eclipse)
{
    HUDMessage(s:"Reach the End (Eclipse)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_eclpse");
    Add_Observer(808);
    Add_Observer(809);
    Add_Observer(810);
    Add_Observer(687);
    Add_Observer(811);
    Add_Observer(812);

    // Spawn Apostles
    SpawnSpotForced("BaronOfHell2", 680, TID_REMOVE, 128);
    SpawnSpotForced("Demon3", 681, TID_REMOVE, 128);
    SpawnSpotForced("TentacleWorm", 682, TID_REMOVE, 128);
    SpawnSpotForced("Aguares", 683, TID_REMOVE, 128);
    SpawnSpotForced("ForbiddenOne", 684, TID_REMOVE, 128);
    SpawnSpotForced("SlimyWorm", 685, TID_REMOVE, 128);
    SpawnSpotForced("Cacodemon2", 686, TID_REMOVE, 128);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 660, false, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*25+25-(20*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame75" (void) // Hit the Target (Grenades)
{
    HUDMessage(s:"Hit the Target (Grenades)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 690, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5+25-(5*game_speed));

	// Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame76" (void) // Score a Basketball
{
    HUDMessage(s:"Score a Basketball"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_bball");

    // Spawn some Spectators
    SpawnSpotForced("ScriptedMarine", 108, TID_REMOVE, 0);
    SpawnSpotForced("ScriptedMarine", 309, TID_REMOVE, 64);
    SpawnSpotForced("ScriptedMarine", 334, TID_REMOVE, 128);
    SpawnSpotForced("ScriptedMarine", 336, TID_REMOVE, 192);
    SpawnSpotForced("ScriptedMarine", 332, TID_REMOVE, 32);
    SpawnSpotForced("ScriptedMarine", 333, TID_REMOVE, 96);
    SpawnSpotForced("ScriptedMarine", 335, TID_REMOVE, 160);
    SpawnSpotForced("ScriptedMarine", 337, TID_REMOVE, 224);
    Thing_Deactivate(TID_REMOVE);
    Thing_SetTranslation(TID_REMOVE, 6);
    SpawnSpotForced("ZombieMan", 267, TID_REMOVE, 32);
    SpawnSpotForced("ChaingunGuy", 268, TID_REMOVE, 64);
    SpawnSpotForced("Archvile", 269, TID_REMOVE, 64);
    SpawnSpotForced("BaronOfHell", 286, TID_REMOVE, 96);
    SpawnSpotForced("CyberDemon", 287, TID_REMOVE, 128);
    SpawnSpotForced("ShotgunGuy", 288, TID_REMOVE, 128);
    SpawnSpotForced("Revenant", 289, TID_REMOVE, 160);
    SpawnSpotForced("HellKnight", 306, TID_REMOVE, 192);
    SpawnSpotForced("DoomImp", 307, TID_REMOVE, 192);
    SpawnSpotForced("WolfensteinSS", 308, TID_REMOVE, 0);
    Thing_Deactivate(TID_REMOVE);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 689, true, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4+10-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame77" (void) // Reach the End (Bit Trip)
{
    int i;
    int time;
    int action=0;
    HUDMessage(s:"Reach the End (Bit Trip)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_runner");
	round_forceobservers = true;
    Add_Observer(709);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 710, false, true);
    delay(1);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*49-SECOND*13);
    time = SECOND*3;

    // Constantly move the players
    do
    {
        time--;
		for (i=0; i<MAXPLAYERS; i++)
		{
			if (!player_lostround[i])
			{
				int oldpos, newpos;
				oldpos = GetActorY(TID_PLAYER+i);
				SetActorPosition(TID_PLAYER+i, GetActorX(TID_PLAYER+i), GetActorY(TID_PLAYER+i)+10.0, GetActorZ(TID_PLAYER+i), 0);
				SetActorAngle(TID_PLAYER+i, 0.25);
				newpos = GetActorY(TID_PLAYER+i);

                // Kill the player if he didn't move
				if (newpos == oldpos)
                    thing_destroy(TID_PLAYER+i, 1);
			}
		}

        // Move the camera
		SetActorPosition(709, GetActorX(709), GetActorY(709)+10.0, GetActorZ(709), 0);

        // Manipulate the world
        if (time == 0)
        {
            switch (action)
            {
                case 0:
                    Generic_Door(207,64,0,34,0);
                    time = SECOND*10+20;
                    break;
                case 1:
                    Generic_Door(207,64,0,34,0);
                    time = SECOND*9;
                    break;
                case 2:
                    Generic_Door(207,64,0,34,0);
                    time = SECOND*2+5;
                    break;
                case 3:
                    Generic_Door(208,64,0,34,0);
                    time = SECOND*24+10-SECOND*13;
                    break;
            }
            action++;
        }

        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

    // Move the camera back
    SetActorPosition(709, GetActorX(709), -5536.0, GetActorZ(709), 0);
}

Script "DoomWare_Server_Minigame78" (void) // Shoot Apple Imp Head
{
    HUDMessage(s:"Shoot Apple Imp Head"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_apple");

    // Spawn the Imp with an apple on its head
    SpawnSpotForced("ImpTarget", 707, TID_REMOVE, 192);
    SpawnSpotForced("Apple", 706, TID_REMOVE, 192);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 730, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        Check_FailRoundItem();
        for (int i=0; i<MAXPLAYERS; i++)
            if (player_lostround[i])
                Give_Achievement(i, ACHIEVE_ID_BADAIM);
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame79" (void) // Shoot an Imp
{
    int time = 0;
    HUDMessage(s:"Shoot an Imp"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CHICKN");
    Line_SetBlocking(26, BLOCKF_CREATURES, 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 540, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*8+20-(15*game_speed));

    // Keep the roads busy
    do
    {
        Check_WonRoundItem();
        if (time == 0)
        {
            SpawnSpotForced("ImpKart", random(416, 417), TID_REMOVE, 0);
            SpawnSpotForced("ImpKart", random(418, 419), TID_REMOVE, 128);
            time = random(15, SECOND*2);
        }
        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
    Line_SetBlocking(26, 0, BLOCKF_CREATURES);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true, true);
}

Script "DoomWare_Server_Minigame80" (void) // Survive (Pyoro)
{
    int time = 0;
	round_winifmid = true;
	round_forceobservers = true;
    hudmessage(s:"Survive (Pyoro)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_PYORO");
    Add_Observer(813);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 820, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*8+(20*game_speed));

    // Make it rain
    do
    {
        if (time == 0)
        {
			SpawnProjectile(814, "Bean", 0, 0, -64-game_speed*4, 0, TID_REMOVE+1);
			SetActorPosition(TID_REMOVE+1, GetActorX(TID_REMOVE+1)+32.0*random(0,29), GetActorY(TID_REMOVE+1), GetActorZ(TID_REMOVE+1), false);
			Thing_ChangeTID(TID_REMOVE+1, TID_REMOVE);
            time = random(15, 35-game_speed*3);
        }
        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

	// Fix the floors
	for (int i=0; i<30; i++)
		if (GetSectorFloorZ(222+i, GetActorX(814)+32.0*i, GetActorY(814)) != 40.0)
		{
			Floor_RaiseInstant(222+i, 0, 64);
			Sector_SetDamage(222+i, 0, MOD_UNKNOWN);
		}
}

Script "DoomWare_Server_Minigame81" (void) // Dodge the Car
{
	int time = 0;
	round_winifmid = true;
	round_forceobservers = true;
    hudmessage(s:"Dodge the Car"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DODGE");
    Add_Observer(815);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 840, false, true);

	// Spawn a car
	Thing_ProjectileGravity(816, random(253, 254), 128, 64, 0);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame82" (void) // Whack a Mole
{
    HUDMessage(s:"Whack a Mole"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DIGLET");

    // Spawn some digletts to whack
	for (int i=0; i<9; i++)
		Spawn("Diglett", random(-304, 304)<<16,random(-304, 304)<<16, 10.0, TID_REMOVE);
	Spawn("DiglettShiny", random(-304, 304)<<16,random(-304, 304)<<16, 10.0, TID_REMOVE);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame83" (void) // Charge your Laz0r
{
	int i;
    HUDMessage(s:"Charge your Laz0r"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DBZ");
	minigame_fragpoints = true;
	minigame_wincondition1 = 1337;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5+30-(12*game_speed));

	// Make the Auras follow the players
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
		{
			if (ThingCount(0, TID_EXTRA+i) != 0 && GetActorProperty(TID_PLAYER+i, APROP_Health) > 0)
				SetActorPosition(TID_EXTRA+i, GetActorX(TID_PLAYER+i),  GetActorY(TID_PLAYER+i),  GetActorZ(TID_PLAYER+i), false);
			else if (ThingCount(0, TID_EXTRA+i) != 0 && player_answer1[i] != -1)
			{
				SetActorState(TID_EXTRA+i, "Death", true);
				player_answer1[i] = -1;
			}
		}
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

	// Kill the auras
	for (i=0; i<MAXPLAYERS; i++)
		if (ThingCount(0, TID_EXTRA+i) != 0)
			SetActorState(TID_EXTRA+i, "Death", true);
}

Script "DoomWare_Server_Minigame84" (void) // Stay on the Road
{
	int time = 10;
	int direction = 0;
    HUDMessage(s:"Stay on the Road"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("");
	Add_Observer(817);
	round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 860, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10+(12*game_speed));

	// Make the buses drift
    do
    {
		// Change the direction of the buses
		if (time == 0)
		{
			time = random(20, SECOND*2-game_speed*12);
			direction = random(-4, 4);
		}

		// Make the buses drift off
		for (int i=0; i<MAXPLAYERS; i++)
			if (player_lostround[i] == false)
				SetActorVelocity(TID_PLAYER+i, (direction<<16)/(8-game_speed/2), 0, 0, true, false);

		time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame85" (void) // Survive (Time Freeze)
{
    HUDMessage(s:"Survive (Time freeze)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
	round_winifmid = true;
	minigame_fragpoints = true;

	// Give all the players a time freeze powerup
	for (int i=0; i<MAXPLAYERS; i++)
		GiveActorInventory(TID_PLAYER+i, "TimeFreeze", 1);

	// Since timefreeze stops music, we gotta fake some
	PlaySound(1, "DoomWare/MusicFreeze", CHAN_ITEM | CHAN_NOPAUSE, 1.0, true, ATTN_NONE);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10);

	// Stop the "music"
	PlaySound(1, "DoomWare/Blank", CHAN_ITEM | CHAN_NOPAUSE, 1.0, false, ATTN_NONE);
}

Script "DoomWare_Server_Minigame86" (void) // Reach the End (Chasm)
{
    HUDMessage(s:"Reach The End (Chasm)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_the_da");
	Add_Observer(878);
	Add_Observer(877);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 857, true, true);
	
	// Because this map isn't cruel enough
	Thing_SpawnNoFog(879, T_IMP, GetActorAngle(879), TID_REMOVE);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*25-game_speed*SECOND);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_Minigame87" (void) // Be the highest player
{
	int i;
	int highest = 0;
	SetMusic("d_height");
	hudmessage(s:"Be the highest player"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
	
    // Raise the floor
	floor_raisebyvalue(19, 16, 64);
    floor_raisebyvalue(20, 8, 32);
    floor_raisebyvalue(21, 8, 32);
    floor_raisebyvalue(22, 8, 32);

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+(SECOND*game_speed));

	// Find out what the biggest height is
	for (i=0; i<MAXPLAYERS; i++)
		if (GetActorZ(TID_PLAYER+i) > highest)
			highest = GetActorZ(TID_PLAYER+i);
	
	// Make the highest players win
	for (i=0; i<MAXPLAYERS; i++)
		if (GetActorZ(TID_PLAYER+i) == highest)
			Player_Win(i);
	delay(1);

    // Move things back
    floor_lowerbyvalue(19, 16, 64);
    floor_lowerbyvalue(20, 8, 32);
    floor_lowerbyvalue(21, 8, 32);
    floor_lowerbyvalue(22, 8, 32);
	
}

Script "DoomWare_Server_Minigame88" (void) // Choose a side
{
	bool shifted = 0;
	Add_Observer(898);
	round_forceobservers = true;
	round_winifmid = true;
    hudmessage(s:"Choose a side"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_STEADY");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 900, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5);
	
	// Shift the seesaw
	delay(1);
    do
    {
		// If two seconds are left
		if (minigame_timer < SECOND*2 && shifted == 0)
		{
			int side1count = ThingCountNameSector("DoomPlayer", 0, 837);
			int side2count = ThingCountNameSector("DoomPlayer", 0, 836);
			
			if (side1count > side2count)
			{
				shifted = 1;
				Floor_LowerInstant(837, 0, 16);
				Sector_SetDamage(837, 1337, MOD_LAVA);
			}
			else if (side1count < side2count)
			{
				shifted = 2;
				Floor_LowerInstant(836, 0, 16);
				Sector_SetDamage(836, 1337, MOD_LAVA);
			}
		}
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);

	// Fix the seesaw
	if (shifted == 1)
	{
		Floor_RaiseInstant(837, 0, 16);
		Sector_SetDamage(837, 0, MOD_UNKNOWN);
	}
	else if (shifted == 2)
	{
		Floor_RaiseInstant(836, 0, 16);
		Sector_SetDamage(836, 0, MOD_UNKNOWN);
	}
}

Script "DoomWare_Server_Minigame89" (void) // Abandon Ship
{
	int i, j, k;
    hudmessage(s:"Abandon Ship"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_ABANDN");
	
	// Close doors at random
	for (i=0; i<8; i++)
		player_answer1[i] = 900+i;
	for (i=0; i<8; i++)
	{
		j = random(i, 7);
		k = player_answer1[i];
		player_answer1[i] = player_answer1[j];
		player_answer1[j] = k;
	}
	for (i=7; i>=PlayerCount()/2; i--)
		Ceiling_LowerInstant(player_answer1[i], 0, 16);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 896, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7-game_speed*15);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}


/*===================================================================================================
                                    1v1 TieBreakers (Serverside)
===================================================================================================*/

Script "DoomWare_Server_TieBreaker1" (void) // Gun Duel
{
    HUDMessage(s:"TieBreaker1v1 - Gun Duel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_gduel");
    Add_Observer(727);

    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[0], 726);
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[1], 708);
    for (int i=2; i<MAXPLAYERS; i++)
        Player_Lose(game_highnames[i], true);

    Delay(random(SECOND*3, SECOND*7));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, (SECOND*2));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_TieBreaker2" (void) // Rope Tug
{
    HUDMessage(s:"TieBreaker1v1 - Rope Tug"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_tug");
    Add_Observer(729);

    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[0], 747);
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[1], 746);
    for (int i=2; i<MAXPLAYERS; i++)
        Player_Lose(game_highnames[i], true);

    delay(random(SECOND, SECOND*3));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, (SECOND*10));

    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_TieBreaker3" (void) // Barrels 1v1
{
    int i;
    HUDMessage(s:"TieBreaker1v1 - Gun Duel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_brlfun");
    Add_Observer(751);

    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[0], 750);
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[1], 749);
    for (i=2; i<MAXPLAYERS; i++)
        Player_Lose(game_highnames[i], true);

    SpawnSpotForced("ExplosiveBarrel", 748, TID_REMOVE, 0.0);

    Delay(random(SECOND*2, SECOND*4));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, (SECOND*5));

    // Check for winners
    do
    {
        if (player_lostround[game_highnames[0]])
        {
            Player_Win(game_highnames[1]);
            SetActorProperty(TID_PLAYER+game_highnames[1], APROP_Invulnerable, 1);
        }
        else if (player_lostround[game_highnames[1]])
        {
            Player_Win(game_highnames[0]);
            SetActorProperty(TID_PLAYER+game_highnames[0], APROP_Invulnerable, 1);
        }

        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Move the players back if they didn't die
    SetActorProperty(TID_PLAYER+game_highnames[0], APROP_Invulnerable, 0);
    SetActorProperty(TID_PLAYER+game_highnames[1], APROP_Invulnerable, 0);
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}


/*===================================================================================================
                                    Non 1v1 TieBreakers (Serverside)
===================================================================================================*/

Script "DoomWare_Server_TieBreakerM1" (void) // Survive (Grenades Fight)
{
    HUDMessage(s:"TieBreakerM - Survive (Grenades Fight)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_GARAGE");
    round_winifmid = true;
    minigame_fragpoints = true;
    Add_Observer(752);
    Add_Observer(756);

    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 760, false, true);
    delay(random(SECOND*2, SECOND*4));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, (SECOND*13));

    // Check for last man standing
    do
    {
        Check_LMS_MVMTie();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_TieBreakerM2" (void) // Survive (Decreasing Ring)
{
    int i;
    int floors_dropped = 0;
    int ticks_passsed = 0;
    HUDMessage(s:"TieBreakerM - Survive (Decreasing Ring)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_PUSHER");
    Add_Observer(754);
    minigame_fragpoints = true;
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 753, true, true);
    delay(random(SECOND*2, SECOND*4));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, (SECOND*5 + SECOND*2*9));

    // While the game is running
    do
    {
        // Drop a floor ever 2 seconds
        ticks_passsed++;
        if (ticks_passsed%(SECOND*2) == 0)
        {
            ticks_passsed = 0;
            Floor_LowerInstant(210+floors_dropped, 0, 314);
            Sector_setDamage(210+floors_dropped, 200000, MOD_WATER);
            ChangeFloor(210+floors_dropped, "WFWATER1");
            floors_dropped++;
        }

        // Check for last man standing
        Check_LMS_MVMTie();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Bring the dropped floors back up
    for (i=0;i<floors_dropped;i++)
    {
        Floor_RaiseInstant(210+i, 0, 314);
        Sector_setDamage(210+i, 0, MOD_UNKNOWN);
        ChangeFloor(210+i, "NFMBGY01");
    }

    // Return survivors to the waiting room
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}

Script "DoomWare_Server_TieBreakerM3" (void) // Shoot the Target (1 shot)
{
    int i;
    int time = 0;
    int checks = 0;
    HUDMessage(s:"TieBreakerM - Shoot the Target (1 shot)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 780, false, true);
    Add_Observer(755);
    delay(random(SECOND*2, SECOND*4));

    // Raise the target
    minigame_canmove = true;
    minigame_wincondition1 = random(2, 4);
    Floor_RaiseInstant(217+minigame_wincondition1, 0, 16);

    // Lower the target once it's been shot
    while (time < SECOND*2)
    {
        for (i=0; i<MAXPLAYERS; i++)
            if (player_wonround[i] == true)
            {
                Floor_LowerInstant(217+minigame_wincondition1, 0, 16);
                break;
            }
        time++;
        delay(1);
    }

    // Lower the target if no one shot it
    for (i=0; i<MAXPLAYERS; i++)
        if (player_wonround[i] != true)
            checks++;
    if (checks == MAXPLAYERS)
        Floor_LowerInstant(217+minigame_wincondition1, 0, 16);

    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false, true);
}


/*===================================================================================================
                                    Extra Minigame Scripts
===================================================================================================*/

Script 9 (int Condition) // Check win with condition
{
    if (Condition == minigame_wincondition1)
        Player_Win(PlayerNumber());
}

Script 10 (void) // Give WonRoundItem for DECORATE
{
    SetActivatorToTarget(0);
    GiveInventory("WonRoundItem", 1);
}

Script 11 (void) // Give FailRoundItem for DECORATE
{
    SetActivatorToTarget(0);
    GiveInventory("FailRoundItem", 1);
}

Script 12 (int variable) // Win players for accomplishing tasks
{
    int current_minigame = round_current[game_roundnum-1];
    switch (current_minigame)
    {
        case 13:
			if (minigame_timer == TIMER_OFF)
				terminate;
            if (variable == minigame_wincondition1)
            {
                thing_move(0, 130+PlayerNumber(), false);
                Player_Win(PlayerNumber());
            }
            else
            {
                thing_move(0, 19, false);
                Player_Lose(PlayerNumber(), false);
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_WRONGDOOR);
            }
            break;
        case 14:
            LocalAmbientSound("DoomWare/Worm", 127);
            Player_Win(PlayerNumber());
            break;
		case 77:
			Give_Achievement(PlayerNumber(), ACHIEVE_ID_RUNNER);
			Player_Win(PlayerNumber());
            break;
        default:
            Player_Win(PlayerNumber());
            break;
    }
}

Script 13 (void) // Give achievement for catching the 1up in the Sonic Minigame
{
    Give_Achievement(PlayerNumber(), ACHIEVE_ID_LONGJUMP);
}

Script 14 (void) // Give achievement for destroying an ATST
{
    if (ActivatorTID() >= TID_PLAYER && ActivatorTID() <= TID_PLAYER+MAXPLAYERS)
        Give_Achievement(PlayerNumber(), ACHIEVE_ID_ATST);
}

Script 15 (void) // Flash the screen with the NES Zapper
{
    FadeTo(0, 0, 0, 1.0, 0.01);
    delay(2);
    FadeTo(0, 0, 0, 0.0, 0.01);
}

Script 16 (void) // Teleport players in Chasm
{
	Teleport(858, 0, 0);
}

Script 17 (int door) // Abandon Ship Doors
{
	Ceiling_LowerAndCrushDist(900 + door, 120, 1337, 0, 1);
	Player_Win(PlayerNumber());
}


Script 241 (void) // Lose invulnerability in rocket launcher minigame
{
	Thing_Destroy(TID_PLAYER+PlayerNumber(), 1);
}

Script 242 (int HitCaco) // Cacodemon/Number shot
{
    // Prevent the script from running multiple times in one tick
    if (player_answer1[PlayerNumber()] != 0)
        terminate;

    for (int j=0; j<4; j++)
        if (player_answer2[PlayerNumber()][j] == -1)
        {
            player_answer1[PlayerNumber()] = 3;
            player_answer2[PlayerNumber()][j] = HitCaco;
            break;
        }
}

Script 243 (int Key) // Key Reset
{
	if (game_status == STATUS_MINIGAME)
	{
		if (Key == 0)
            SpawnSpotForced("YellowCard", 497, 42, 0);
		if (Key == 1)
            SpawnSpotForced("BlueCard", 498, 4300, 0);
		if (Key == 2)
            SpawnSpotForced("RedCard", 499, 4400, 0);
		Thing_SetSpecial(42, 226, 243, 0, 0);
		Thing_SetSpecial(4300, 226, 243, 0, 1);
		Thing_SetSpecial(4400, 226, 243, 0, 2);
	}
}

Script 244 (void) // Basketball points
{
    if (!(ClassifyActor(0) & ACTOR_PLAYER) && GetActorZ(0) > 83.0 && GetActorZ(0) < 103.0)
    {
        GiveActorInventory(GetActorProperty(0, APROP_TargetTID), "WonRoundItem", 1);
        GiveInventory("WonRoundItem", 1);
        delay(1);
        if (game_status == STATUS_MINIGAME)
            restart;
        else
            thing_remove(0);
    }
}

Script 245 (void) // Bean floor destruction
{
	int floor = ((GetActorX(0)-GetActorX(814))/32) >> 16;

	// Play a sound if the floor hasn't been destroyed
	if (GetActorZ(0) > 0.0)
		PlaySound(813,"DoomWare/BeanDie");

	// Remove the floor
	if (GetSectorFloorZ(222+floor, GetActorX(0), GetActorY(0)) == 40.0)
	{
		Floor_LowerInstant(222+floor, 0, 64);
		Sector_SetDamage(222+floor, 666, MOD_FALLING);
	}
}

Script 246 (void) // Manipulate projectile on car dodging
{
	int chance = random(1, 2);

	if (game_speed > 0 && chance == 1)
	{
		int velx = GetActorVelX(TID_REMOVE);
		SetActorVelocity(TID_REMOVE, 0.0, 0.0, 0.0, false, false);
		delay(17);
		SetActorVelocity(TID_REMOVE, velx, 0.0, 0.0, false, false);
	}
	else if (game_speed > 2 && chance == 2)
	{
		ThrustThingZ(TID_REMOVE, 23, 0, 0);
	}

	PlaySound(815, "DoomWare/DriveBy");
}

Script 247 (void) // Slow the bus down
{
	Player_Lose(ActivatorTID()-TID_PLAYER, false);
	Thing_Stop(0);
	SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
	While(GetActorProperty(0, APROP_HEalth) > 0 && minigame_timer != TIMER_OFF)
	{
		SetActorVelocity(0, 0.0, -16.0, 0.0, false, false);
		delay(1);
	}
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
}

Script 250 (int CheckpointNum) // Checkpoint in kart racing
{
    // If half-way there, increase the checkpoint counter
	if (CheckpointNum == 0)
		player_answer1[PlayerNumber()] = 1;

    // If at the finish lap, and has passed the checkpoint
	if (CheckpointNum == 1 && player_answer1[PlayerNumber()] == 1 && !player_wonround[PlayerNumber()] && ClassifyActor(0) & ACTOR_ALIVE)
    {
        // If first place, give an achievement
        bool otherwinner = false;
        for (int i=0; i<MAXPLAYERS; i++)
            if (player_wonround[i] == true)
                otherwinner = true;
        if (otherwinner == false)
            Give_Achievement(PlayerNumber(), ACHIEVE_ID_KARTWIN);

        // Make player win round
        Player_Win(PlayerNumber());
    }
}

/*===================================================================================================
                                        Console Commands
===================================================================================================*/

Script "DoomWare_Console_ListPlayers" (void)
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (playerInGame(i))
            HUDMessage(d:i, s:" - ", n:i+1; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
}

Script "DoomWare_Console_AssignRole" (int ply, int role)
{
    data_role[ply] = role;
    HUDMessage(s:"Player ", n:ply+1, s:" was given role ", d:role; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
}

Script "DoomWare_Console_ForceEnd" (void)
{
    game_over = OVER_FORCED;
}


/*===================================================================================================
                                          Miscellaneous
===================================================================================================*/

Script "DoomWare_Entity_MarkCleanup" (void) // ACS so that I can use it in DECORATE
{
    Thing_ChangeTID (0, TID_REMOVE);
}

Script "DoomWare_Entity_Cleanup" (void)
{
    // Remove entities marked for deletion
    While (ThingCount(0, TID_REMOVE) > 0)
	{
        thing_remove(TID_REMOVE);
        delay(1);
    }
}

Script "DoomWare_Entity_CheckCleanup" (void) // In case it missed the first cleanup
{
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
        terminate;

    // Remove entities marked for deletion
    While (ThingCount(0, TID_REMOVE) > 0)
	{
        thing_remove(TID_REMOVE);
        delay(1);
    }
}

script "DoomWare_DoLightning" (void) // Halloween lightning
{
	delay(random(SECOND*5, SECOND*15));
	ChangeSky("STSKY22", "");
	AmbientSound("world/thunder", 127);
	Light_ChangeToValue(256, 255);
	Light_ChangeToValue(23, 255);
	Light_ChangeToValue(24, 255);
	Light_ChangeToValue(44, 255);
	Light_ChangeToValue(2, 255);
	Light_ChangeToValue(19, 255);
	Light_ChangeToValue(17, 255);
	Light_ChangeToValue(256, 255);
	Light_ChangeToValue(20, 255);
	Light_ChangeToValue(20, 255);
	Light_ChangeToValue(21, 255);
	Light_ChangeToValue(22, 255);
	delay(5);
	ChangeSky("STSKY21", "");
	Light_ChangeToValue(256, 192);
	Light_ChangeToValue(23, 192);
	Light_ChangeToValue(24, 192);
	Light_ChangeToValue(44, 192);
	Light_ChangeToValue(2, 192);
	Light_ChangeToValue(19, 192);
	Light_ChangeToValue(17, 192);
	Light_ChangeToValue(256, 192);
	Light_ChangeToValue(20, 192);
	Light_ChangeToValue(20, 192);
	Light_ChangeToValue(21, 192);
	Light_ChangeToValue(22, 192);
	restart;
}

function void Player_Morph(int plynum, str what)
{
    SpawnSpotForced("PlayerTranslator", TID_PLAYER+plynum, TID_EXTRA+plynum, 0);
    Thing_SetTranslation(TID_EXTRA+plynum, -1);
    MorphActor(TID_PLAYER+plynum, what, 1, minigame_timer, MRF_NEWTIDBEHAVIOUR, "Nothing", "Nothing");
}

function void Player_FreezeTotally(int who)
{
    SetPlayerProperty(who, 1, PROP_TOTALLYFROZEN);

    if (who == 0)
        player_frozen[PlayerNumber()] = true;
    else
        for (int i=0; i<MAXPLAYERS; i++)
            player_frozen[i] = true;
}

function void Player_UnFreezeTotally(int who)
{
    int i;
    if (who == 0 && !player_viewingmenu[PlayerNumber()])
        SetPlayerProperty(who, 0, PROP_TOTALLYFROZEN);
    else if (who == 1)
         for (i=0; i<MAXPLAYERS; i++)
            if (!player_viewingmenu[i])
                SetPlayerProperty(who, 0, PROP_TOTALLYFROZEN);

    if (who == 0)
        player_frozen[PlayerNumber()] = false;
    else
        for (i=0; i<MAXPLAYERS; i++)
            player_frozen[i] = false;
}

function int Calc_Speed(int vi, int vii)
{
	int viii = vi >> 16;
    int viiii = vii >> 16;
	return viii*viii  + viiii*viiii;
}

function int Distance(int tid1, int tid2)
{
	int x, y, z, d;
	x = GetActorX(tid1) - GetActorX(tid2) >> 16;
	y = GetActorY(tid1) - GetActorY(tid2) >> 16;
	z = GetActorZ(tid1) - GetActorZ(tid2) >> 16;
	d = sqrt( x*x + y*y + z*z );
	return d;
}

Script "DoomWare_Entity_SetPlayerTranslation" (void) // Translate colors on morphed actors
{
	Thing_SetTranslation(TID_PLAYER+(ActivatorTID()-TID_EXTRA), -1);
	while (game_status != STATUS_WINLOSE)
        delay(1);
	thing_Remove(ActivatorTID());
}

function void Load_PlayerDB(int plynum)
{
    BeginDBTransaction();
    data_points[plynum] = GetDBEntry("Points", getPlayerAccountName(plynum));
    data_wins[plynum] = GetDBEntry("Wins", getPlayerAccountName(plynum));
    data_deaths[plynum] = GetDBEntry("Deaths", getPlayerAccountName(plynum));
    data_1ups[plynum] = GetDBEntry("1Ups", getPlayerAccountName(plynum));
    data_role[plynum] = GetDBEntry("Role", getPlayerAccountName(plynum));
    data_achieve[plynum] = GetDBEntry("Achievements", getPlayerAccountName(plynum));
    EndDBTransaction();
}

function void Check_WonRoundItem(void)
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (CheckActorInventory(TID_PLAYER+i, "WonRoundItem") > 0)
            Player_Win(i);
}

function void Check_FailRoundItem(void)
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (CheckActorInventory(TID_PLAYER+i, "FailRoundItem") > 0)
            Player_Lose(i, false);
}

function int AToI (str s)
{
    bool negative = false;
    int n = 0;
    int len = StrLen(s);

    // Go through every character in the string
    for (int i = 0; i < len; i++)
    {
        int char = GetChar(s, i);

        // Check if we found a negative sign
        if (i == 0 && char == '-')
        {
            negative = true;
            continue;
        }

        // Check that we are actually converting a number
        if (char < '0' || char > '9')
        {
            print(s:"ERROR, attempting to convert ", c:char, s:" to number!");
            continue;
        }

        // Add the number to our total
        n = n*10 + (char-'0');
    }

    if (negative)
        n = -n;

    return n;
}
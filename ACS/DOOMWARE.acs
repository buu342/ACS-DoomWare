/*===========================================================================================================================================
    Welcome to DoomWare's ACS Code! This is where all the magic happens.
    After Beta 1.8, I went ahead and rewrote the entire core of the gamemode from scratch in an attempt to both make the code
    more stable, but more importantly to make it easier to read and modify. This has allowed me to add all sorts of new features
    really easily, as I didn't have to keep writing exceptions/rewriting entire blocks of code to implement new stuff.

    DoomWare's Source Code should be pretty well commented, but if you want a better overview, I highly recommend reading the Wiki on 
	DoomWare's GitHub page! It covers everything you need to know, in a nicer to follow format.
    https://github.com/buu342/ACS-DoomWare/wiki

    Have fun!

    - Buu342
===========================================================================================================================================*/


/*===================================================================================================
                                           Definitions
===================================================================================================*/

// Don't Touch
#define SECOND 35 // Doom's internal tickrate
#define SAFETY "" // To prevent "BEGINNERS LUCK" from being the default text due to it being the first #define'd string


// Game selection

#define NUMBEROFWACKYMODS    10  // Number of wacky mods


// Game settings

#define MAXPLAYERS  16 // All minigames were designed with 16 players in mind! Change if you know what you're doing!
#define MAXTEAMS    2  // The maximum amount of teams. Changing this will require modifying quite a few if and switch statements!
#define MAXROUNDS   25 // How many rounds per game (Default 25)


// Game Speedups

#define MAXSPEEDUPS 4 // How many times should the game speedup (Increase only if you know what you're doing!)

// Round number(s) to speedup in
#define SPEEDUP1 6  // default 6
#define SPEEDUP2 11 // default 11
#define SPEEDUP3 16 // default 16
#define SPEEDUP4 20 // default 20


// Game Status

#define STATUS_NOTSTARTED 0 // Waiting for players
#define STATUS_STARTING   1 // Game Initializing
#define STATUS_WACKYMOD   2 // Wacky modifier selection
#define STATUS_WAITING    3 // Waiting between minigames
#define STATUS_SPEEDUP    4 // The game is speeding up
#define STATUS_WINLOSE    5 // Announce the winners and losers
#define STATUS_MINIGAME   6 // We are playing a minigame
#define STATUS_GAMEOVER   7 // The game has ended
#define STATUS_TIEDETECT  8 // A tie has been detected
#define STATUS_TIEBREAK   9 // We are playing a tie breaker (1v1)
#define STATUS_TIEBREAKM 10 // We are playing a tie breaker (more than 1v1)


// Message ID's

#define MELEMENTS       48  // Number of reserved slots for menu elements

#define MSGID_CONSOLE   -1                        // Console only messages
#define MSGID_HSPLAYR   1                         // Highscore background
#define MSGID_HSBACK    2+MAXPLAYERS+1            // Highscore table player name (occupies MAXPLAYERS+1 numbers)
#define MSGID_CURSOR    3+MAXPLAYERS+1            // Menu Cursor
#define MSGID_MELEM     4+MAXPLAYERS+1            // Menu element (occopies 64 slots)
#define MSGID_MENU      5+MAXPLAYERS+1+MELEMENTS  // Menu background
#define MSGID_CENTER    6+MAXPLAYERS+1+MELEMENTS  // Centered messages (eg You Win!)
#define MSGID_CENTER2   7+MAXPLAYERS+1+MELEMENTS  // Centered messages below above (eg speedup hints)
#define MSGID_SCORE     8+MAXPLAYERS+1+MELEMENTS  // HUD Score background
#define MSGID_ROUND     9+MAXPLAYERS+1+MELEMENTS  // HUD Round background
#define MSGID_ROUND2    10+MAXPLAYERS+1+MELEMENTS // HUD Round counter
#define MSGID_LEADER    11+MAXPLAYERS+1+MELEMENTS // HUD Leader background
#define MSGID_SPREAD    12+MAXPLAYERS+1+MELEMENTS // HUD Spread
#define MSGID_LEADER2   13+MAXPLAYERS+1+MELEMENTS // HUD Leader name
#define MSGID_SCORE2    14+MAXPLAYERS+1+MELEMENTS // HUD score counter
#define MSGID_SCORE3    15+MAXPLAYERS+1+MELEMENTS // HUD score text
#define MSGID_ROUND3    16+MAXPLAYERS+1+MELEMENTS // HUD Round text
#define MSGID_VIEWHS    17+MAXPLAYERS+1+MELEMENTS // HUD Highscore reminder
#define MSGID_STFACE    18+MAXPLAYERS+1+MELEMENTS // STATUSBAR Face
#define MSGID_STBAR     19+MAXPLAYERS+1+MELEMENTS // STATUSBAR Extra
#define MSGID_TIMER     20+MAXPLAYERS+1+MELEMENTS // Timer on the HUD
#define MSGID_TIMER2    21+MAXPLAYERS+1+MELEMENTS // Timer on the HUD background
#define MSGID_CENTER3   22+MAXPLAYERS+1+MELEMENTS // Centered messages below CENTER2
#define MSGID_OBSERVE   23+MAXPLAYERS+1+MELEMENTS // Press # to observe this minigame
#define MSGID_MENUBIND  24+MAXPLAYERS+1+MELEMENTS // Press # to open the menu
#define MSGID_VIEWSP    25+MAXPLAYERS+1+MELEMENTS // View sprite
#define MSGID_WARNING   26+MAXPLAYERS+1+MELEMENTS // Warnings
#define MSGID_WACKYMOD  27+MAXPLAYERS+1+MELEMENTS // Wackymod reminder
#define MSGID_ACHIEVEM  28+MAXPLAYERS+1+MELEMENTS // Achievement notifications
#define MSGID_PLYHERE   29+MAXPLAYERS+1+MELEMENTS // You are Here


// Special TID's

#define TID_PLAYER    1337 // TID given to players (Occupies MAXPLAYERS amount of TID's)
#define TID_HATGAME   3337 // TID given to leader/winner hat (Occupies 2 TID's)
#define TID_EXTRA     4337 // TID given to extra objects during minigames (Occupies MAXPLAYERS amount of TID's)
#define TID_HATROLE   5337 // TID given to players with roles (Occupies MAXPLAYERS amount of TID's)
#define TID_AVOID     6337 // TID given to the AVOID object
#define TID_REMOVE    7337 // TID given to objects to be removed after a minigame ended


// Game Over Reasons

#define OVER_NONE       -1 // Game is not over
#define OVER_WINNER     0  // Because someone won
#define OVER_PLAYER     1  // Because of a lack of players
#define OVER_FORCED     2  // Because it was forced to end
#define OVER_JOIN       3  // Because someone joined during a solo game
#define OVER_WINNERSOLO 4  // Someone won during a solo game
#define OVER_WINNERRED  5  // Red team won
#define OVER_WINNERBLUE 6  // Blue team won
#define OVER_NOTIEGAMES 7  // No tiebreaker games


// Player Roles

#define ROLE_UNLOGGED   -1 // Player is not logged in
#define ROLE_NONE       0  // No role
#define ROLE_REGULAR    1  // Someone who played this game wayyyyy too much
#define ROLE_BETA       2  // Someone special <3
#define ROLE_BUU342     3  // The God himself
#define ROLE_ACHIEVER   4  // Someone who has unlocked all the achievements


// Music Durations (only change if you changed the sounds)

#define MUSICDUR_WAIT1 (SECOND*4)
#define MUSICDUR_WAIT2 (SECOND*3 + 25)
#define MUSICDUR_WAIT3 (SECOND*3 + 10)
#define MUSICDUR_WAIT4 (SECOND*2 + 30)
#define MUSICDUR_WAIT5 (SECOND*2 + 20)

#define MUSICDUR_SPEEDUP1 (SECOND*7 + 10)
#define MUSICDUR_SPEEDUP2 (SECOND*6 + 25)
#define MUSICDUR_SPEEDUP3 (SECOND*6)
#define MUSICDUR_SPEEDUP4 (SECOND*5 + 15)

#define MUSICDUR_WINLOSE (SECOND + 32)

#define MUSICDUR_GAMEOVER (SECOND*7)
#define MUSICDUR_TIEBREAK (SECOND*4 + 9)


// Achievements

#define ACHIEVE_ID_1WIN        0
#define ACHIEVE_ID_10WIN       1
#define ACHIEVE_ID_50WIN       2
#define ACHIEVE_ID_25POINTS    3
#define ACHIEVE_ID_1v1WIN      4
#define ACHIEVE_ID_MVMWIN      5
#define ACHIEVE_ID_501UPS      6
#define ACHIEVE_ID_100DEATH    7
#define ACHIEVE_ID_300POINTS   8
#define ACHIEVE_ID_JUMP        9
#define ACHIEVE_ID_LONGJUMP    10
#define ACHIEVE_ID_3FRAGS      11
#define ACHIEVE_ID_BULLETHELL  12
#define ACHIEVE_ID_KARTWIN     13
#define ACHIEVE_ID_ATST        14
#define ACHIEVE_ID_WAIFU       15
#define ACHIEVE_ID_BOSS        16
#define ACHIEVE_ID_FULLSERVER  17

#define ACHIEVE_NAME_1WIN        "Beginners Luck"
#define ACHIEVE_NAME_10WIN       "Just getting warmed up!"
#define ACHIEVE_NAME_50WIN       "Bingo Bango Bongo Bish Bash Bosh"
#define ACHIEVE_NAME_25POINTS    "Hoarder"
#define ACHIEVE_NAME_1v1WIN      "Fastest Gun in the West"
#define ACHIEVE_NAME_MVMWIN      "Darwinism"
#define ACHIEVE_NAME_501UPS      "Poor Kids in Africa Could Have Eaten Those"
#define ACHIEVE_NAME_100DEATH    "The Final Frontier"
#define ACHIEVE_NAME_300POINTS   "DoomWare veteran"
#define ACHIEVE_NAME_JUMP        "Future Legend of Rhythm Alien"
#define ACHIEVE_NAME_LONGJUMP    "Mike Powell"
#define ACHIEVE_NAME_3FRAGS      "Point Man"
#define ACHIEVE_NAME_BULLETHELL  "Mushihimesama"
#define ACHIEVE_NAME_KARTWIN     "Tokyo Drifter"
#define ACHIEVE_NAME_ATST        "Dash Rendar"
#define ACHIEVE_NAME_WAIFU       "The Perfect Waifu"
#define ACHIEVE_NAME_BOSS        "Deicide"
#define ACHIEVE_NAME_FULLSERVER  "House party"

#define ACHIEVE_DESC_1WIN        "Win a single game"
#define ACHIEVE_DESC_10WIN       "Win 10 games"
#define ACHIEVE_DESC_50WIN       "Win 50 games"
#define ACHIEVE_DESC_25POINTS    "Finish a game with 25 points or more"
#define ACHIEVE_DESC_1v1WIN      "Win a 1v1 tiebreaker match"
#define ACHIEVE_DESC_MVMWIN      "Be the sole survivor of a non-1v1 combat tiebreaker match"
#define ACHIEVE_DESC_501UPS      "Collect 50 1-ups"
#define ACHIEVE_DESC_100DEATH    "Die 100 times"
#define ACHIEVE_DESC_300POINTS   "Earn a total of 300 points"
#define ACHIEVE_DESC_JUMP        "Beat the Jumping Scroller minigame (without flying)"
#define ACHIEVE_DESC_LONGJUMP    "Get the 1-Up in the sonic minigame (without flying)"
#define ACHIEVE_DESC_3FRAGS      "Frag 3 players in a deathmatch minigame"
#define ACHIEVE_DESC_BULLETHELL  "Survive the bullet hell minigame (without flying)"
#define ACHIEVE_DESC_KARTWIN     "Finish first in a kart race"
#define ACHIEVE_DESC_ATST        "Destroy an AT-ST"
#define ACHIEVE_DESC_WAIFU       "Sucessfully match a fully scrambled Imp"
#define ACHIEVE_DESC_BOSS        "Defeated the final boss"
#define ACHIEVE_DESC_FULLSERVER  "Play on a full server"


// Wacky modifiers

#define WACKYMOD_NONE    0
#define WACKYMOD_BOSS    1
#define WACKYMOD_JUMP    2
#define WACKYMOD_FLIGHT  3
#define WACKYMOD_1HP     4
#define WACKYMOD_SPEED   5
#define WACKYMOD_INVERT  6
#define WACKYMOD_T1UPS   7
#define WACKYMOD_SPEEDUP 8
#define WACKYMOD_SPREAD  9
#define WACKYMOD_RAGE    10

#define WACKYMOD_NAME1  "Boss Round"
#define WACKYMOD_NAME2  "Double Jump"
#define WACKYMOD_NAME3  "Flight"
#define WACKYMOD_NAME4  "1 Health"
#define WACKYMOD_NAME5  "Sonic Speed"
#define WACKYMOD_NAME6  "Inverted Controls"
#define WACKYMOD_NAME7  "1-Ups are worth Triple"
#define WACKYMOD_NAME8  "Max Game Speed"
#define WACKYMOD_NAME9  "Bullet Spread"
#define WACKYMOD_NAME10 "Double Fire Rate"


// Map Skins

#define MAPSKIN_NONE      0
#define MAPSKIN_HALLOWEEN 1
#define MAPSKIN_CHRISTMAS 2


// Miscellaneous

#define NUMOBSERVERS    8  // Size of the observers array. Increase if you need more.
#define TIMER_OFF       -1 // Not using the timer
#define TIMER_EARLY     -2 // Timer ended early


// Menu Text

#define WELCOME "\
Welcome to DoomWare, a fast paced competitive minigame wad. Every few seconds you are\n\
thrown into a new minigame with variying goals. The longer you play, the faster and\n\
harder the game gets...\n\n\
Before you get started, make sure you have mouselook and jump bound, as you're going\n\
to need them. Also, make sure you have DoomWare specific binds setup as well (you\n\
should see them in 'DoomWare Settings->DoomWare Controls' in your ESC menu). You\n\
can alternatively bind them manually via '+dwscores' (highscore), '+dwobserve'\n\
(observation) and '+dwmenu' (this menu).\n\n\
You can navigate this menu either using your movement keys or mouse, and you can select\n\
buttons via your USE or ATTACK key. You can close this menu via your menu button.\n\n\
If you are having trouble reading this or any other text due to a large resolution, you\n\
can force HUD scaling in the options tab of this menu, DoomWare options in the ESC menu,\n\
or via the console command 'doomware_hudscale'.\n\n\
Good luck, and have fun!\
"

// Login Menu Text

#define LOGIN "You are not logged in.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
You must have an account at www.auth.zandronum.com, and then login by opening the\n\
console and typing in 'login username password'. If you do not login, your stats and\n\
achievemnts will not be tracked.\
"


// Game changelog

#define CHANGES "\
Version Beta 1.99\n\
What's new in the Beta?\n\n\
+ Added a failsafe for when no tie breaker games exist\n\
+ Added 'doomware_wackymodsmonsters' CVar\n\
+ Added Female OSRS Sound\n\
+ Added F.E.A.R. game to solo banlist\n\
+ Added last barrage of Beta hats\n\
+ Added MAP02 for future updates\n\
+ Reached 100 minigames!\n\
+ Reached 5 1v1 and 1vM Wackymods!\n\
* Changed timer 'Eror' to 'End'\n\
* Decorated 'Abandon Ship' and 'Reach Surface'\n\
* Enabled Wackymods in solo play\n\
* Finalized achievements\n\
* Fixed 1HP not being set on morphs\n\
* Fixed boss fight awards not working in unsafe db mode\n\
* Fixed Daisy sometimes not spawning\n\
* Fixed Dynamic Lights not disabling properly\n\
* Fixed multiplayer chat logs... Again...\n\
* Fixed login text rescaling randomly\n\
* Fixed Railgun not penetrating\n\
* Fixed veteran hat not working properly\n\
* Fixed wins being incremented every tick\n\
* Improved the intermission screens\n\
* Increased time in basketball game\n\
* Made internal minigame names consistent\n\
* Optimized sound sizes to keep this WAD under 64MB\n\
* Reduced the Jumping Scroller minigame by half\n\
* Reworked 'Storm the Beach'\n\
* Tweaked some minigame times\n\
* Widened the spawn points on some minigames\n\
- Removed custom SBAR after respawning\n\
- Removed Melee Lock from the C.A.W.\n\
- Removed Spread wackymod in some games\n\
"


/*===================================================================================================
                                        Global Variables
===================================================================================================*/

bool player_wonround[MAXPLAYERS];       // (Internal) Players put here have won the round (usually denoted by the green particle effect)
bool player_lostround[MAXPLAYERS];      // (Internal) Players in here have lost the round (usually denoted by the red particle effect)
bool player_midround[MAXPLAYERS];       // (Internal) All players are put in here at the start of each round.
bool player_viewingscore[MAXPLAYERS];   // (Internal) List of players looking at the highscore table
bool player_viewingmenu[MAXPLAYERS];    // (Internal) List of players looking at the DoomWare Menu
bool player_musicwaiting[MAXPLAYERS];   // (Internal) List of whether players are hearing the waiting/speedup music
bool player_musicwinlose[MAXPLAYERS];   // (Internal) List of whether players are hearing the win/lose music
bool player_musicgameover[MAXPLAYERS];  // (Internal) List of whether players are hearing the game over music
int  player_observe[MAXPLAYERS];        // (Internal) List of what camera players are observing
bool player_frozen[MAXPLAYERS];         // (Internal) List of what players have APROP_TOTALLYFROZEN
bool player_haswackyscript[MAXPLAYERS]; // (Internal) List of what players that have a wackymod script running
int  player_position[MAXPLAYERS][3];    // (Internal) List player's XYZ pos before a minigame starts
int  player_teleporter[MAXPLAYERS];     // (Internal) Helper array to keep track of randomized player spawns
int  player_frags[MAXPLAYERS];          // (Internal) List of each player's frags
str  player_viewsprite[MAXPLAYERS];     // List of player's view sprite (like in the clean your weapon minigame)
int  player_answer1[MAXPLAYERS];        // Variables for minigame stuff (like keeping track of laps in Kart races)
int  player_answer2[MAXPLAYERS][4];     // Variables for minigame stuff (like keeping track of cacodemon answers)

int  game_score[MAXPLAYERS];           // (Internal) The score of each PlayerNumber()
int  game_scoreteams[MAXTEAMS];        // (Internal) The score of each team
int  game_extrascoreteams[MAXTEAMS+1]; // (Internal) The extra score of each team (team members that disconnected)
int  game_highscores[MAXPLAYERS];      // (Internal) The global highscore table sorted by winner first
int  game_highnames[MAXPLAYERS];       // (Internal) The global highscore table of player names sorted by winner first
int  game_roundnum;                    // (Internal) A number containing the current round.
int  game_status;                      // (Internal) A number containing the status of the gamemode's logic.
int  game_speed;                       // (Internal) How fast is the game going
int  game_over;                        // (Internal) The reason the game ended
bool game_solo;                        // (Internal) Is someone playing alone?
int  game_wackymod;                    // (Internal) Wacky Modifier
int  game_skin;                        // (Internal) Map seasonal skin
bool game_teams;                       // (Internal) Whether a team game is happening

int  round_current[MAXROUNDS];      // (Internal) An array containing a list of all minigames to be played/that have been played
str  round_hints[MAXSPEEDUPS];      // (Internal) An array containing a list of all hints to be/that have been displayed.
bool round_winifmid;                // Allow a player to win if he is in the midround array (like in games where you don't do anything to win)
bool round_winifsuicide;            // Pass the player if he killed himself
int  round_noforceend;              // Prevent the game from ending prematurely (unless everyone lost). Useful so people can collect 1ups.
int  round_tiebreaker;              // (Internal) The number value of the tiebreaker round are we playing
bool round_is1vmtiebreaker;			// (Internal) Are we playing a 1VM Tiebreaker round?
int  round_observers[NUMOBSERVERS]; // (Internal) An array containing all the possible observer TID's
bool round_forceobservers;          // Does this round need observers to work? Only used for game_solo.

int  minigame_wincondition1;            // A generic global variable for minigames
int  minigame_wincondition2;            // A generic global variable for minigames
int  minigame_wincondition3;            // A generic global variable for minigames
int  minigame_timer;                    // (Internal) A timer that is displayed during the minigame
bool minigame_canmove;                  // (Internal) Used to signal that players can move in tiebreaker rounds
bool minigame_canobserve;               // (Internal) Can this minigame be observed?
bool minigame_fragpoints;               // Can you get points for frags?
bool minigame_invisiblehats;            // Should this minigame hide the player hats?
str  minigame_instruction1[MAXPLAYERS]; // Center text during minigame
str  minigame_instruction2[MAXPLAYERS]; // Center text below center text during minigame
str  minigame_instruction3[MAXPLAYERS]; // Center text below center text below center text during minigame

int data_points[MAXPLAYERS];    // (Internal) List of points each player has received in total
int data_wins[MAXPLAYERS];      // (Internal) List of wins each player has achieved in total
int data_deaths[MAXPLAYERS];    // (Internal) List of deaths each player suffered in total
int data_1ups[MAXPLAYERS];      // (Internal) List of 1Ups each player got in total
int data_role[MAXPLAYERS];      // (Internal) List of each player's role
int data_achieve[MAXPLAYERS];   // (Internal) Bit field each player's achievements
int data_bosskills[MAXPLAYERS]; // (Internal) List of each player's boss kills


/*===================================================================================================
                                DoomWare Server Logic Initialization
===================================================================================================*/

script "DoomWare_Server_Boot" OPEN // Called when the map starts. Waits for players to join
{
    // Initialize some global variables
    game_status = STATUS_NOTSTARTED;
    game_solo = false;
    game_wackymod = WACKYMOD_NONE;
    
    // Figure out the map skin
    if (!StrICmp(GetCVarString("doomware_mode"), "halloween") || (GetCVar("doomware_automode") && GetTimeProperty(SystemTime(), TM_MONTH) == 9))
        game_skin = MAPSKIN_HALLOWEEN;
    else if (!StrICmp(GetCVarString("doomware_mode"), "christmas") || (GetCVar("doomware_automode") && GetTimeProperty(SystemTime(), TM_MONTH) == 11))
        game_skin = MAPSKIN_CHRISTMAS;
    else
        game_skin = MAPSKIN_NONE;

    // Some nice elevator music
    if (game_skin == MAPSKIN_HALLOWEEN)
        SetMusic("D_WAIT2");
    else if (game_skin == MAPSKIN_CHRISTMAS)
        SetMusic("D_WAIT3");
    else
        SetMusic("D_WAIT");

    // Create a "thread" that continually updates the hats and handles the database
    ACS_NamedExecute("DoomWare_Server_Hats", 0);

    // Clean up all the globals
    ACS_NamedExecute("DoomWare_Server_InitGlobals", 0);

    // Create a "thread" to syncronize global variables for CLIENTSIDE scripts
    ACS_NamedExecute("DoomWare_Server_SyncGlobals", 0);

    // Initialize the map
    ACS_NamedExecute("DoomWare_Server_InitMap", 0);

    // Wait until we have enough players
    while (PlayerCount() < 2 && !game_solo)
        Delay(1);

    // Stop the music and mark the game's start
    game_status = STATUS_STARTING;
    SetMusic("");
    
    // Check if a team game is happening
    game_teams = ((GetTeamProperty(TEAM_BLUE, TPROP_NumPlayers) + GetTeamProperty(TEAM_BLUE, TPROP_NumPlayers)) > 0 && !game_solo);

    // Initialize the game's serverside logic
    ACS_NamedExecute("DoomWare_Server_Initialize", 0);
}

Script "DoomWare_Server_Initialize" (void) // Initializes the rest of the gamemode and creates "threads"
{
    // Initialize the hints
    ACS_NamedExecute("DoomWare_Server_InitHints", 0);

    // Select which games will be played from the collection
    ACS_NamedExecute("DoomWare_Server_InitRounds", 0);

    // Initialize the highscore table
    ACS_NamedExecute("DoomWare_Server_InitHighscores", 0);

    // Wipe the Observers array
    ACS_NamedExecute("DoomWare_Server_ClearObservers", 0);
    
    // Wait a bit so everyone knows the game is starting
    minigame_timer = GetCVar("doomware_gamestarttime")*SECOND; // Used for the HUD  timer
    while (minigame_timer > 0)
    {
        minigame_timer--;
        delay(1);
    }
    
    // Initialize wacky modifiers
    if (DEBUG_WACKY != -1 || GetCVar("doomware_wackymods"))
        ACS_NamedExecuteWait("DoomWare_Server_InitWackymods", 0);

    // Create a "thread" that continually updates the highscores
    ACS_NamedExecute("DoomWare_Server_CalcHighscore", 0);

    // Create a "thread" that controls the game logic
    ACS_NamedExecute("DoomWare_Server_GameLogic", 0);
}

#define NUMBEROFHINTS 100
str temp_hint[NUMBEROFHINTS];
Script "DoomWare_Server_InitHints" (void) // Initializes the list of hints to display during speedup
{
    temp_hint[0]  = "This WAD was created by \cqB\csU\cdU\cq3\cs4\cd2\c-, he has a skull over his head.";
    temp_hint[1]  = "Sunglasses are an important accessory for reducing damage from the Sun.";
    temp_hint[2]  = "Can't access the scoreboard? Change the bind in the options (at the very bottom) or bind +dwscores.";
    temp_hint[3]  = "Not coming soon: Minigame based off Doomguy's Pimp Ventures.";
    temp_hint[4]  = "If this is your first time playing DoomWare, I am so sorry for you.";
    temp_hint[5]  = "Some of these hints are useless.";
    temp_hint[6]  = "This WAD has over 15000 lines of ACS Code, and 8000 of Decorate.";
    temp_hint[7]  = "There is a 1UP mushroom hidden in many minigames.";
    temp_hint[8]  = "1UP Mushrooms give you an extra point. Grab them!";
    temp_hint[9]  = "I've included the ZDaemon source code in this WAD.";
    temp_hint[10] = "The throwback minigames have anatomically correct HUDs made with ACS.";
    temp_hint[11] = "Dash Rendar > Han Solo";
    temp_hint[12] = "I probably have more hours in the RAGE Mod Toolkit than anyone has in the base game...";
    temp_hint[13] = "Anyone who recognizes most of the music is super cool.";
    temp_hint[14] = "This WAD was inspired by WarioWare, duh.";
    temp_hint[15] = "I think it's time to blow this scene, get everybody and the stuff together.";
    temp_hint[16] = "I don't remember hurting any priest... lately... that much...";
    temp_hint[17] = "This WAD is a celebration of video games and everything I love, including other Doom WADs.";
    temp_hint[18] = "If I were a vegetable, I would be a couch potato.";
    temp_hint[19] = "Fast reactions and adaptability are the only way of surviving this next round.";
    temp_hint[20] = StrParam(s:"There are currently ",d:NUMBEROFGAMES, s:" minigames in this WAD.");
    temp_hint[21] = "I am extremely thankful to some people for coming and testing this WAD so often. Love you guys <3";
    temp_hint[22] = "I tend to make spelling mistaeks.";
    temp_hint[23] = "Diddy Kong Racing's final boss is literally impossible.";
    temp_hint[24] = "This server should have free custom skins that you can change in the options.";
    temp_hint[25] = "Chasecam should be enabled in the server. Use it!";
    temp_hint[26] = "If at first you don't succeed, try and try a gun.";
    temp_hint[27] = "The only way to win is to be an asshole to the lead players. If you're the lead, oh dear...";
    temp_hint[28] = "Dumbledore kills Snape.";
    temp_hint[29] = "Spoiler, after round 25 the game says 'Game Over'.";
    temp_hint[30] = "Griffith did nothing wrong.";
    temp_hint[31] = "When the game speeds up it gets both faster and harder.";
    temp_hint[32] = "Wanna make suggestions for new minigames? Get in touch, or open an issue on GitHub!";
    temp_hint[33] = "Coming Soon: Complex DoomWare vs Ghouls vs Megaman vs Unholy bosses - Push + Jumpmaze edition.";
    temp_hint[34] = "This WAD encourages and rewards suicide, sometimes.";
    temp_hint[35] = "This WAD contains memes older than the average internet user.";
    temp_hint[36] = "Hissy Hogging was an inside job.";
    temp_hint[37] = "Press your jump button to jump.";
    temp_hint[38] = "I bet you can't spell Diarrhea.";
    temp_hint[39] = "If you can't read the scoreboard, stop playing Doom on an iPod. No one uses 320x200.";
    temp_hint[40] = "Watch those wrist rockets.";
    temp_hint[41] = "Boo!";
    temp_hint[42] = "Please don't sue me for using some music. You wouldn't hurt a pregnant man.";
    temp_hint[43] = "The Falador Massacre is a myth perpetrated by King Roald.";
    temp_hint[44] = "'0/5, bad map' - Anonymous @ doomworld.com/idgames";
    temp_hint[45] = "Fat people aren't real.";
    temp_hint[46] = "The racist jokes in this WAD are not racist.";
    temp_hint[47] = "Buying Girlfriend for 10k.";
    temp_hint[48] = "Need buddy to finish Shield of Arrav quest :(";
    temp_hint[49] = "Your ad here.";
    temp_hint[50] = "You lost the game.";
    temp_hint[51] = "Hey can I have a quote in your Doom thingy? - CougarMagnum";
    temp_hint[52] = "This WAD is ad free because no one likes headaches, just like Nurofen, eliminating them with ease!";
    temp_hint[53] = "A group of baboons is called a council.";
    temp_hint[54] = "Please stop asking me for feet pics, Jennifer.";
    temp_hint[55] = "This WAD may be sold to Korean gangsters.";
    temp_hint[56] = "Doom 3 is fun.";
    temp_hint[57] = "Still trying to figure out why the Major was a cyborg.";
    temp_hint[58] = "I finished Super Sonic Doom with a score of 2,282,450.";
    temp_hint[59] = "Pushing people doesn't give points, you're just being an asshole.";
    temp_hint[60] = "Keikaku means plan.";
    temp_hint[61] = "*insert movie reference here*";
    temp_hint[62] = "Achievement Get!";
    temp_hint[63] = "ALL THESE SQUARES MAKE A CIRCLE.";
    temp_hint[64] = "I am hilarious and you will quote everything I say.";
    temp_hint[65] = "Some games have custom taunts. Use them!";
    temp_hint[66] = "Holding strafe and forward at the same time makes you move faster than just pressing forward.";
    temp_hint[67] = "Linguica is a Portuguese word so his keyboard is in Portuguese. Shut up and deal with it.";
    temp_hint[68] = "I am never detailing a keyboard ever again...";
    temp_hint[69] = "If you see this message, press F10 and Enter for a free point.";
    temp_hint[70] = "Alderaan shot first.";
    temp_hint[71] = "The 'reach the end' Shadows of the Empire minigame uses 32 polyobjects.";
    temp_hint[72] = "It only took me 8 years to finish Spacechem.";
    temp_hint[73] = "The player in first place has the rainbow badge above him. Go ruin his day.";
    temp_hint[74] = "So what do you think of Chubbs's man-boobies?";
    temp_hint[75] = "Died during a round? Press O to observe others playing, or bind +dwobserve.";
    temp_hint[76] = "One of my favorite shapes is the Great disnub dirhombidodecahedron.";
    temp_hint[77] = "Featuring Dante from the Devil May Cry series.";
    temp_hint[78] = "Players wearing Party Hats are wonderful beta testers :>";
    temp_hint[79] = "Players with a pink heart over their heads have played too much Doomware.";
    temp_hint[79] = "Players with a blue heart over their heads Unlocked all achievements. Wow!";
    temp_hint[80] = "You can scale the HUD using the DoomWare Menu, or the console command doomware_hudscale.";
    temp_hint[81] = "This WAD contains Berserk references.";
    temp_hint[82] = "You were always such a kidder, Steve.";
    temp_hint[83] = "There are hidden SOMEMONG's in inaccessible areas.";
    temp_hint[84] = "I want to paint my house in FIREBLU.";
    temp_hint[85] = StrParam(s:"Today's random number is: ", d:random(0xFFFFFFFF, 0x7FFFFFFF)); // Maximum negative and positive integer
    temp_hint[86] = "This WAD contains war crimes, domestic abuse, and taxes.";
    temp_hint[87] = "Chameleon Machine. Ride on now!";
    temp_hint[88] = "It's ok, Marphy Black isn't here, he can't hurt you.";
    temp_hint[89] = "I tried to sneak through the door man! Can't make it, can't make it, the shit's stuck!";
    temp_hint[90] = "I seem to be wounded, but I can keep going";
	temp_hint[91] = "<Controversial Opinion about Star Wars Here>";
	temp_hint[92] = "Node Graph Out of Date. Rebuilding...";
	temp_hint[93] = "This is an Anti-Skub household.";
	temp_hint[94] = "If you are Scottish lord, then I am Mickey Mouse!";
	temp_hint[95] = "int i = *((int*)0);";
	temp_hint[96] = "Please keep all appendages and bodily fluids inside the ride at all times.";
	temp_hint[97] = "The Janitor that cleans up the lobby after every game gets paid above minimum wage.";
	temp_hint[98] = "I have altered the game speed, pray I don't alter it any further.";
	temp_hint[99] = "Bames Nond's having a stronk, call a Bondulance.";
    
    // Shuffle the array of hints
    int i, j, k;
    for (i=0; i<NUMBEROFHINTS; i++)
    {
        j = random(i, NUMBEROFHINTS-1);
        k = temp_hint[i];
        temp_hint[i] = temp_hint[j];
        temp_hint[j] = k;
    }

    // Pick the first few hints
    for (i=0; i<MAXSPEEDUPS; i++)
        round_hints[i] = temp_hint[i];
}

bool temp_bannedrounds[NUMBEROFGAMES];
int temp_allrounds[NUMBEROFGAMES];
Script "DoomWare_Server_InitRounds" (void) // Initializes the list of minigames to play
{
    int i, j, k;
    int bancount = 0;
    int totalrounds = 0;
    game_roundnum = 1;
    game_speed = 0;
    game_over = OVER_NONE;
        
    // Initialize the banned games array
    for (i=0; i<NUMBEROFGAMES; i++)
        temp_bannedrounds[i] = false;

    // Get the banned minigames list
    if (GetCVarString("doomware_banlist") != "" || game_solo)
    {
        str banlist = GetCVarString("doomware_banlist");
        int strs = 0;
        int strl = 0;
        
        // If we're in solo play, ban deathmatch levels
        if (game_solo && StrCmp(BANNEDSOLOGAMES, ""))
            banlist = StrParam(s:banlist, s:" ", s:BANNEDSOLOGAMES);
        strl = StrLen(banlist);
            
        // Read the cvar and get the banlist
        for (i=0; i<strl; i++)
        {
            // If we found a space or reached EOL
            if (GetChar(banlist, i) == ' ' || i+1 == strl)
            {
                // If we're at EOL, increment i so that the math checks ount
                if (i+1 == strl)
                    i++;
                    
                // Get the minigame number from the string and increment our counters
                temp_bannedrounds[AToI(StrMid(banlist, strs, i-strs))-1] = true;
                bancount++;
                strs = i+1;
            }
        }
    }
    
    // If we banned too many games, ignore the ban list
    if (bancount >= NUMBEROFGAMES)
    {
        bancount = 0;
        for (i=0; i<NUMBEROFGAMES; i++)
            temp_bannedrounds[i] = false;
    }
        
    // Create a temporary array with all the rounds that aren't banned
    for (i=0; i<NUMBEROFGAMES; i++)
        if (!temp_bannedrounds[i])
            temp_allrounds[totalrounds++] = i+1;
    
    // If we have enough rounds to not have repeats
    if (!GetCVar("doomware_duplicates") && NUMBEROFGAMES-bancount >= MAXROUNDS)
    {
        // Shuffle the temp array
        for (i=0; i<totalrounds; i++)
        {
            j = random(i, totalrounds-1);
            k = temp_allrounds[i];
            temp_allrounds[i] = temp_allrounds[j];
            temp_allrounds[j] = k;
        }

        // Now copy the first MAXROUNDS elements onto our rounds array
        for (i=0; i<MAXROUNDS; i++)
            round_current[i] = temp_allrounds[i];
    }
    else 
    {
        // Otherwise just pick a bunch of games at random
        for (i=0; i<MAXROUNDS; i++)
            round_current[i] = temp_allrounds[random(0, totalrounds-1)];
    }
}

Script "DoomWare_Server_InitHighscores" (void) // Initializes the highscore table
{
    int i;
    for (i=0; i<MAXPLAYERS; i++)
    {
        game_highscores[i] = -1;
        game_highnames[i] = -1;
        game_score[i] = 0;
    }
}

Script "DoomWare_Server_InitGlobals" (void) // Initializes all the global variables
{
    for (int i=0; i< MAXPLAYERS; i++)
    {
        game_score[i] = 0;
        data_points[i] = 0;
        data_wins[i] = 0;
        data_deaths[i] = 0;
        data_1ups[i] = 0;
        data_role[i] = 0;
        data_achieve[i] = 0;
        data_bosskills[i] = 0;
        player_lostround[i] = 0;
        player_viewingmenu[i] = 0;
        minigame_instruction1[i] = "";
        minigame_instruction2[i] = "";
        minigame_instruction3[i] = "";
        player_viewsprite[i] = "";
        player_wonround[i] = false;
        player_midround[i] = false;
        player_lostround[i] = false;
    }

    SetCVar("__clientsync_round", 0);
    SetCVar("__clientsync_gamestatus", 0);
    SetCVar("__clientsync_gameover", 0);
    SetCVar("__clientsync_minigametimer", 0);
    SetCVar("__clientsync_highscore1", 0);
    SetCVar("__clientsync_highscore2", 0);
    SetCVar("__clientsync_canobserve", 0);
    SetCVar("__clientsync_canmove", 0);
    SetCVar("__clientsync_gamesolo", 0);
    SetCVar("__clientsync_wincondition1", 0);
    SetCVar("__clientsync_roundcurrent", 0);
    SetCVar("__clientsync_wackymod", 0);
    SetCVarString("__clientsync_highname", "");
    SetCVarString("__clientsync_speeduphint", "");

    SetCVarString("__clientsync_player_score", "");
    SetCVarString("__clientsync_player_loggedin", "");
    SetCVarString("__clientsync_player_datascore", "");
    SetCVarString("__clientsync_player_datawins", "");
    SetCVarString("__clientsync_player_datadeaths", "");
    SetCVarString("__clientsync_player_data1ups", "");
    SetCVarString("__clientsync_player_dataroles", "");
    SetCVarString("__clientsync_player_dataachieve", "");
    SetCVarString("__clientsync_player_databosskills", "");
    SetCVarString("__clientsync_player_checklost", "");
    SetCVarString("__clientsync_player_lostround", "");
    SetCVarString("__clientsync_player_viewingmenu", "");
    SetCVarString("__clientsync_player_instruction1", "");
    SetCVarString("__clientsync_player_instruction2", "");
    SetCVarString("__clientsync_player_instruction3", "");
    SetCVarString("__clientsync_player_viewsprite", "");
    
    // Get global stat data
    DB_NetworkStats("Wins", "wins");
    DB_NetworkStats("Points", "points");
    DB_NetworkStats("1Ups", "1ups");
    DB_NetworkStats("Deaths", "deaths");
    DB_NetworkStats("BossKills", "bosses");
}

Script "DoomWare_Server_InitWackymods" (void) // Initializes the wacky modifiers
{
    int wackymod = random(0, GetCVar("doomware_wackymodschance"));
    if (wackymod == 0 || DEBUG_WACKY != -1)
    {
        // Pick a wackymod at random
        if (DEBUG_WACKY == -1)
        {
            if (GetCVar("doomware_bossfight") && !game_teams)
                game_wackymod = 1+random(0, NUMBEROFWACKYMODS-1);
            else
                game_wackymod = 2+random(0, NUMBEROFWACKYMODS-2);
        }
        else
            game_wackymod = DEBUG_WACKY;
        game_status = STATUS_WACKYMOD;
        delay(SECOND*5);
        
        // If we got the max game speed modifier, then set the game speed
        if (game_wackymod == WACKYMOD_SPEEDUP)
            game_speed = 4;
        
        // If we got the boss fight, then change level
        if (game_wackymod == WACKYMOD_BOSS)
            ChangeLevel("MAP30", 0, 0, 0);
    }
}

int linealpha[4];
Script 255 (int lineid, int angle) // Arena wall bumping
{
    int linealpha_max = 75;
    int linealpha_speed = 5;
    int lineslot = 255-lineid;
    
    // Push the player
    ThrustThing(angle, 8);
    
    // If there's no other script running
    if (linealpha[lineslot] == 0)
    {
        // Change the line to FIREBLU
        linealpha[lineslot] = linealpha_max;
        setlinetexture(lineid, SIDE_FRONT, TEXTURE_MIDDLE, "FIREBLU1");
        setlinetexture(lineid, SIDE_BACK, TEXTURE_MIDDLE, "FIREBLU1");
        
        // Decrease the line alpha over time
        while (linealpha[lineslot] > 0)
        {
            linealpha[lineslot] = linealpha[lineslot]-linealpha_speed;
            TranslucentLine(lineid, linealpha[lineslot], 0);
            delay(1);
        }
        
        // Remove the texture entirely
        setlinetexture(lineid, SIDE_FRONT, TEXTURE_MIDDLE, "-");
        setlinetexture(lineid, SIDE_BACK, TEXTURE_MIDDLE, "-");    
        linealpha[lineslot] = 0;
    }
    else
        linealpha[lineslot] = linealpha_max;
}


/*===================================================================================================
                                DoomWare Client Logic Initialization
===================================================================================================*/

script "DoomWare_Client_Join" ENTER // Called when a player joins. Initializes the player and creates "threads"
{
    // Initialize the player's variables
    ACS_NamedExecuteAlways("DoomWare_Client_Initialize", 0);

    // Notify about what's new
    HUDMessage(s:CHANGES; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 10.0, 10.0, 0.1);

    // Start the HUD "thread"
    ACS_NamedExecuteAlways("DoomWare_Client_DrawHUD", 0);
    ACS_NamedExecuteAlways("DoomWare_Client_DrawMenu", 0);

    // Wait until we have enough players
    while (game_status == STATUS_NOTSTARTED || game_status == STATUS_STARTING)
        delay(1);

    // Start the main clientside logic "thread"
    ACS_NamedExecuteAlways("DoomWare_Client_GameLogic", 0);
}

Script "DoomWare_Client_Initialize" (void) // Initializes variables related to the player
{
    // Wipe the player's Inventory and score
    clearinventory();
    game_score[PlayerNumber()] = 0;

    // Assign each player a TID, starting at 1337
    Thing_ChangeTID(0, TID_PLAYER+PlayerNumber());

    // Clean up the database and variables for this player
    data_deaths[PlayerNumber()] = 0;
    data_1ups[PlayerNumber()] = 0;
    player_wonround[PlayerNumber()] = false;
    minigame_instruction1[PlayerNumber()] = "";
    minigame_instruction2[PlayerNumber()] = "";
    minigame_instruction3[PlayerNumber()] = "";
    player_viewsprite[PlayerNumber()] = "";
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
    {
        player_wonround[PlayerNumber()] = false;
        player_midround[PlayerNumber()] = false;
        player_lostround[PlayerNumber()] = true;
    }
    else
    {
        player_midround[PlayerNumber()] = true;
        player_lostround[PlayerNumber()] = false;
    }

    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_ACHIEVEM, CR_CYAN, 0, 0, 1.0);


    // Check the player's role or warn if they're not logged in
    if (!GetCVar("doomware_unsafedb") && playerIsLoggedIn(PlayerNumber()))
        Load_PlayerDB(PlayerNumber());
    else
        data_role[PlayerNumber()] = ROLE_UNLOGGED;

    // If the server is full, give the achievement
    if (PlayerCount() == MAXPLAYERS)
        for (int i=0; i<MAXPLAYERS; i++)
            Give_Achievement(i, ACHIEVE_ID_FULLSERVER);

    // Fail the player for this round if they joined late
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
        Player_Lose(PlayerNumber(), true);
}


/*===================================================================================================
                                     DoomWare Server Main Logic
===================================================================================================*/

Script "DoomWare_Server_GameLogic" (void) // Main game logic "thread"
{
    // Initialize some global variables
    int i;
    round_winifmid = false;
    round_winifsuicide = false;
    round_noforceend = false;
    round_forceobservers = false;
	round_is1vmtiebreaker = false;
    minigame_wincondition1 = 0;
    minigame_wincondition2 = 0;
    minigame_wincondition3 = 0;
    minigame_fragpoints = false;
    minigame_invisiblehats = false;
    minigame_timer = TIMER_OFF;
    for (i=0; i<MAXPLAYERS; i++)
    {
        player_midround[i] = PlayerInGame(i);
        player_wonround[i] = false;
        player_lostround[i] = false;
        Player_InvalidatePosition(i);
    }

    // Stop the game if a solo match has more than one person
    if (game_solo && PlayerCount() > 1)
        game_over = OVER_JOIN;

    // Stop the game if a non solo match has only one person
    if (PlayerCount() < 2 && !game_solo)
        game_over = OVER_PLAYER;

    // Check if the game's over
    if (DEBUG_GAME == -2 || game_roundnum > MAXROUNDS || game_over != OVER_NONE)
    {
		bool shouldtie = Should_TieBreak();
        game_speed = 0;

        // Check for ties
        if (shouldtie && (((Is_1v1_TieBreaker() && NUMBEROFTIEBREAKERS > 0)) || NUMBEROFTIEBREAKERSM > 0))
        {
            game_status = STATUS_TIEDETECT;
            HUDMessage(s:"Tie!"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
            delay(MUSICDUR_TIEBREAK);
            game_status = STATUS_WAITING;
        }
        else
        {
            // Figure out the game over reason if it doesn't exist yet
            if (game_over == OVER_NONE)
            {
				if (shouldtie) // We don't have enough tiebreaker minigames
					game_over = OVER_NOTIEGAMES;
				else if (game_teams) // We're using teams
                {
                    // Pick the winning team (TODO: expand this to work with more teams using a loop)
                    if (game_scoreteams[TEAM_RED] > game_scoreteams[TEAM_BLUE])
                        game_over = OVER_WINNERRED;
                    else
                        game_over = OVER_WINNERBLUE;
                }
                else
                {
                    // Pick if we have a solo winner
                    if (!game_solo)
                        game_over = OVER_WINNER;
                    else
                        game_over = OVER_WINNERSOLO;
                }
            }

            // Print game over and the score tally
            game_status = STATUS_GAMEOVER;
            HUDMessage(s:"Game Over"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
            if (game_teams && !game_solo)
            {
                str printscore = "Final score tally:";
                
                // Iterate through all players to construct the string
                for (i=0; i<PlayerCount(); i++)
                {
                    printscore = StrParam(s:printscore, s:"\n");
                    
                    // Print player info, based on their team
                    switch (GetPlayerInfo(game_highnames[i], PLAYERINFO_TEAM))
                    {
                        case TEAM_RED:
                            printscore = StrParam(s:printscore, s:"\cgTEAM RED: ");
                            break;
                        case TEAM_BLUE:
                            printscore = StrParam(s:printscore, s:"\chTEAM BLUE: ");
                            break;
                        default:
                            break;
                    }
                    printscore = StrParam(s:printscore, d:game_highscores[i], s:" - ", n:game_highnames[i]+1);
                }
                HUDMessage(s:printscore; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
            }

            // Wait for the music to finish, then update the databases and restart the level
            delay(MUSICDUR_GAMEOVER);
            ACS_NamedExecute("DoomWare_Server_UpdateDB", 0);
            NamedScriptWait("DoomWare_Server_UpdateDB");
            Exit_Normal(0);
        }
    }

    // Wait a bit to play the round starting music (or warn that the game is speeding up)
    if (Should_Speedup() == true && game_roundnum <= MAXROUNDS)
    {
        game_speed++;
        game_status = STATUS_SPEEDUP;
        switch (game_roundnum)
        {
            case SPEEDUP1: delay(MUSICDUR_SPEEDUP1); break;
            case SPEEDUP2: delay(MUSICDUR_SPEEDUP2); break;
            case SPEEDUP3: delay(MUSICDUR_SPEEDUP3); break;
            case SPEEDUP4: delay(MUSICDUR_SPEEDUP4); break;
        }
    }
    else
    {
        game_status = STATUS_WAITING;

        // Calculate a tiebreaker beforehand to help lagging players
		if (DEBUG_GAME == -2 || game_roundnum > MAXROUNDS)
		{
			if (Is_1v1_TieBreaker())
			{
				if (DEBUG_TIEB > 0)
					round_tiebreaker = DEBUG_TIEB;
				else
					round_tiebreaker = random(1, NUMBEROFTIEBREAKERS);
			}
			else
			{
				if (DEBUG_TIEBM > 0)
					round_tiebreaker = DEBUG_TIEBM;
				else
					round_tiebreaker = random(1, NUMBEROFTIEBREAKERSM);
				round_is1vmtiebreaker = true;
			}
		}

        // Wait until the music is done playing
        switch (game_speed)
        {
            case 0: delay(MUSICDUR_WAIT1); break;
            case 1: delay(MUSICDUR_WAIT2); break;
            case 2: delay(MUSICDUR_WAIT3); break;
            case 3: delay(MUSICDUR_WAIT4); break;
            case 4: delay(MUSICDUR_WAIT5); break;
        }
    }

    // If not a tiebreaker
    str gametoplay;
    if (DEBUG_GAME != -2 && game_roundnum <= MAXROUNDS)
    {
        // Select the minigame to play
        game_status = STATUS_MINIGAME;
        if (DEBUG_GAME > 0)
            round_current[game_roundnum-1] = DEBUG_GAME;
        gametoplay = StrParam(s:"DoomWare_Server_Minigame", d:round_current[game_roundnum-1]);
    }
    else
    {
        minigame_canmove = false;

        if (Is_1v1_TieBreaker())
        {
            game_status = STATUS_TIEBREAK;
            gametoplay = StrParam(s:"DoomWare_Server_TieBreaker", d:round_tiebreaker);
        }
        else
        {
            game_status = STATUS_TIEBREAKM;
            gametoplay = StrParam(s:"DoomWare_Server_TieBreakerM", d:round_tiebreaker);
        }
        
        // Auto fail anyone who isn't in first place
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (game_score[i] != game_highscores[0])
            {
                player_lostround[i] = true;
                player_midround[i] = false;
            }
        }
    }
    ACS_NamedExecute(gametoplay, 0);

    // Wait until the minigame is over
    NamedScriptWait(gametoplay);

    // Stop any music
    SetMusic("");

    // Cleanup entities marked for death and clear the observers array
    ACS_NamedExecute("DoomWare_Entity_Cleanup", 0);
    ACS_NamedExecute("DoomWare_Server_ClearObservers", 0);

    // Announce the winners
    game_status = STATUS_WINLOSE;
    delay(MUSICDUR_WINLOSE-(7*game_speed));
    game_roundnum++;

    // Restart this script
    restart;
}

Script "DoomWare_Server_GameWait" (int time) // Sets a minigame timer
{
    int time_passed;
    minigame_timer = time;
    while (time_passed < time)
    {
        delay(1);
        time_passed++;
        minigame_timer--;

        // Stop if everyone has already passed/died
        if (No_MidRound_Array() && !round_noforceend)
        {
            if (time - time_passed < SECOND)
                delay(time - time_passed);
            else
            {
                minigame_timer = TIMER_EARLY;
                delay(SECOND);
            }
            break;
        }
    }
    minigame_timer = TIMER_OFF;
}

Script "DoomWare_Server_TeleportPlayers" (int tid, int telesector, int fog) // Teleports all players to an arena
{
    int i;
    
    // Randomize the destinations if we're not using telesector
    if (telesector == 0)
    {
        for (i=0; i<MAXPLAYERS; i++)
            player_teleporter[i] = tid+i;

        int j, k;
        for (i=0; i<MAXPLAYERS; i++)
        {
            j = random(i, MAXPLAYERS-1);
            k = player_teleporter[i];
            player_teleporter[i] = player_teleporter[j];
            player_teleporter[j] = k;
        }
    }

    // Teleport everyone
    for (i=0; i<MAXPLAYERS; i++)
    {
        // Don't bother if the player doesn't exist or they're not tied for first place (during a tiebreaker round)
        if (!PlayerInGame(i) || (game_status == STATUS_TIEBREAKM && !game_teams && game_score[i] != game_highscores[0]))
            continue;

        // Get the player's position
        Player_SavePosition(i);

        // Teleport them
        if (!telesector)
        {
            Thing_Move(TID_PLAYER+i, player_teleporter[i], !fog); // Move to an individual TID
        }
        else
        {
            TeleportInSector(2, 1, tid, fog, TID_PLAYER+i);  // Move them using a single TID
            TeleportInSector(17, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(19, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(20, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(21, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(22, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(23, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(24, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(25, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(39, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(44, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(691, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(692, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(693, 1, tid, fog, TID_PLAYER+i);
        }
    }

    // Reduce everyone's speed and fix their angles
    delay(1);
    if (fog)
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            // Don't bother if the player doesn't exist or they're not tied for first place
            if (!PlayerInGame(i) || (game_status == STATUS_TIEBREAKM && game_score[i] != game_highscores[0]))
                continue;

            SetActorPitch(TID_PLAYER+i, 0.0);
            if (telesector)
                SetActorAngle(TID_PLAYER+i, GetActorAngle(tid));
            else
                SetActorAngle(TID_PLAYER+i, GetActorAngle(player_teleporter[i]));
            SetActorVelocity(TID_PLAYER+i, 0.0, 0.0, 0.0, false, false);
        }
    }

    // Retry for anyone who was not teleported due to telefragging prevention
    for (i=0; i<MAXPLAYERS; i++)
    {
        // Don't bother if the player doesn't exist or they're not tied for first place
        if (!PlayerInGame(i) || (game_status == STATUS_TIEBREAKM && game_score[i] != game_highscores[0]))
            continue;

        while (Distance(TID_PLAYER+i, 1) < 512 && game_status == STATUS_MINIGAME)
        {
            if (!telesector)
            {
                Thing_Move(TID_PLAYER+i, player_teleporter[i], !fog); // Move to an individual TID
            }
            else
            {
                TeleportInSector(2, 1, tid, fog, TID_PLAYER+i);  // Move them using a single TID
                TeleportInSector(17, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(19, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(20, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(21, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(22, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(23, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(24, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(25, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(39, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(44, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(691, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(692, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(693, 1, tid, fog, TID_PLAYER+i);
            }
            delay(1);

            if (fog)
            {
                SetActorPitch(TID_PLAYER+i, 0.0);
                if (telesector)
                    SetActorAngle(TID_PLAYER+i, GetActorAngle(tid));
                else
                    SetActorAngle(TID_PLAYER+i, GetActorAngle(player_teleporter[i]));
                SetActorVelocity(TID_PLAYER+i, 0.0, 0.0, 0.0, false, false);
            }
        }
    }
}

Script "DoomWare_Server_TeleportSingle" (int plynum, int dest) // Teleports a single player
{
    Player_SavePosition(plynum);
    Thing_Move(TID_PLAYER+plynum, dest, false);
    SetActorPitch(TID_PLAYER+plynum, 0.0);
    SetActorAngle(TID_PLAYER+plynum, GetActorAngle(dest));
}

Script "DoomWare_Server_ReturnPlayers" (int fog) // Returns all players to the lobby
{
    for (int i=0; i<MAXPLAYERS; i++)
    {
        // Don't teleport the player if they're not ingame or if their return position is invalid
        if (!PlayerInGame(i) || (player_position[i][0] == 0xFFFFFFFF && player_position[i][1] == 0xFFFFFFFF && player_position[i][2] == 0xFFFFFFFF))
            continue;

        // Move the player back to their original spot
        SetActorPosition(TID_PLAYER+i, player_position[i][0], player_position[i][1], player_position[i][2], fog);

        // If for some reason they're not at the spawn, force them back to the center
        while (Distance(TID_PLAYER+i, 1) > 512)
        {
            SetActorPosition(TID_PLAYER+i, GetActorX(1), GetActorY(1), GetActorZ(1), fog);
            delay(1);
        }
    }
}

Script "DoomWare_Server_UpdateDB" (void) // Updates the Database at the end of the game
{
    int i;

    // Don't update if it was a solo game
    if (game_solo)
        terminate;

    // Check for people who have played too much DoomWare
    for (i=0; i<MAXPLAYERS; i++)
        if ((GetCVar("doomware_unsafedb") || playerIsLoggedIn(i)) && playerInGame(i) && data_role[i] == ROLE_NONE)
            if ((GetCVar("doomware_unsafedb") && (GetDBEntry("Points", StrParam(n:i+1)) + game_score[i]) >= 300) || GetDBEntry("Points", getPlayerAccountName(i)) + game_score[i] >= 300)
                data_role[i] = ROLE_REGULAR;

    // Begin the Database Transaction
    BeginDBTransaction();

    for (i=0; i<MAXPLAYERS; i++)
    {
        if ((PlayerIsLoggedIn(i) || GetCVar("doomware_unsafedb")) && playerInGame(i))
        {
            str plyname = getPlayerAccountName(i);
            if (GetCVar("doomware_unsafedb"))
                plyname = StrParam(n:i+1);
            
            // Log the wins
            SetDBEntry("Wins", plyname, data_wins[i]);

            // Log the total points
            incrementDBEntry("Points", plyname, game_score[i]);

            // Log the number of deaths
            SetDBEntry("Deaths", plyname, data_deaths[i]);

            // Log the number of 1ups caught
            SetDBEntry("1Ups", plyname, data_1ups[i]);

            // Log the achievements
            SetDBEntry("Achievements", plyname, data_achieve[i]);

            // Log the player's roles
            SetDBEntry("Role", plyname, data_role[i]);
        }
    }

    // Update the Database
    EndDBTransaction();
    delay(1);
}

function void Load_PlayerDB(int plynum) // Loads a player's database data
{
    str plyname = getPlayerAccountName(plynum);
    if (GetCVar("doomware_unsafedb"))
        plyname = StrParam(n:plynum+1);
    BeginDBTransaction();
    data_points[plynum] = GetDBEntry("Points", plyname);
    data_wins[plynum] = GetDBEntry("Wins", plyname);
    data_deaths[plynum] = GetDBEntry("Deaths", plyname);
    data_1ups[plynum] = GetDBEntry("1Ups", plyname);
    data_role[plynum] = GetDBEntry("Role", plyname);
    data_achieve[plynum] = GetDBEntry("Achievements", plyname);
    data_bosskills[plynum] = GetDBEntry("BossKills", plyname);
    EndDBTransaction();
}

Script "DoomWare_Entity_Cleanup" (void) // Cleans up entities with ThingID TID_REMOVE
{
    // Remove entities marked for deletion
    While (ThingCount(0, TID_REMOVE) > 0)
    {
        thing_remove(TID_REMOVE);
        delay(1);
    }
}


/*===================================================================================================
                                     DoomWare Client Main Logic
===================================================================================================*/

Script "DoomWare_Client_Death" DEATH // Called when a player dies
{
	int plynum = PlayerNumber();
		
	// Win or lose the player
    if ((game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM))
    {
        if (!round_winifsuicide)
        {
            Player_Lose(PlayerNumber(), false);
            data_deaths[PlayerNumber()]++;
            if (data_deaths[PlayerNumber()] == 100)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_100DEATH);
        }
        else
            Player_Win(PlayerNumber());
    }
	
	// Invalidate the player teleport position to prevent them from being re-teleported to the arena (because they respawn there)
    Player_InvalidatePosition(PlayerNumber());

    // Spawn a spoopy ghost
    if (game_skin == MAPSKIN_HALLOWEEN)
        SpawnSpotForced("SpoopyGhost", TID_PLAYER+PlayerNumber(), TID_REMOVE, 0);
	
    // Remove the player's TID if they're dead (to prevent corpses from emitting effects)
    if (GetActorProperty(TID_PLAYER+PlayerNumber(), APROP_HEALTH) <= 0)
        Thing_ChangeTID(TID_PLAYER+PlayerNumber(), 0);
}

Script "DoomWare_Client_Disconnect" (int gone) DISCONNECT // Called when the player leaves
{
    // Wipe all messages
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_SCORE, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_ROUND, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_LEADER, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_SPREAD, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWHS, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSBACK, CR_WHITE, 0.5, 0.3, 1);
	
	// If the player was in a team, save his score
	// We can't get their team in DISCONNECT scripts, so we'll have to figure it out later
	if (game_teams)
		game_extrascoreteams[MAXTEAMS] += game_score[gone];

    // Reset that player's score and data
    game_score[gone] = 0;
    data_points[gone] = 0;
    data_wins[gone] = 0;
    data_deaths[gone] = 0;
    data_1ups[gone] = 0;
    data_role[gone] = ROLE_UNLOGGED;
    data_achieve[gone] = 0;
    data_bosskills[gone] = 0;
    player_haswackyscript[gone] = false;

    // Stop the game if there aren't enough players
    if (game_status != STATUS_NOTSTARTED)
    {
        // End the game if we ran out of players
        if (PlayerCount() < 2 && !game_solo)
            game_over = OVER_PLAYER;

        // Force change map if there are no players
        if (PlayerCount() == 0)
            Exit_Normal(0);
    }
}

Script "DoomWare_Client_Respawn" RESPAWN // Called when a player respawns
{
    thing_changetid(0, TID_PLAYER+PlayerNumber());
    player_observe[PlayerNumber()] = 0;
    clearinventory();
    Player_SetWackymod(PlayerNumber());
}

Script "DoomWare_Client_GameLogic" (void) // Main client gamemode logic "thread"
{
    str extra = "";
    if (game_skin == MAPSKIN_HALLOWEEN)
        extra = "Halloween/";
    else if (game_skin == MAPSKIN_CHRISTMAS)
        extra = "Christmas/";
        
    // Set player wackymods
    Player_SetWackyMod(PlayerNumber());
    
    // Announce Win/Lose
    if (game_status == STATUS_WINLOSE)
    {        
        // Reset the player
        if (game_wackymod != WACKYMOD_1HP)
            SetActorProperty(TID_PLAYER+PlayerNumber(), APROP_Health, 100);
        player_answer1[PlayerNumber()] = 0;
        player_answer2[PlayerNumber()][0] = 0;
        player_answer2[PlayerNumber()][1] = 0;
        player_answer2[PlayerNumber()][2] = 0;
        player_answer2[PlayerNumber()][3] = 0;
        player_viewsprite[PlayerNumber()] = "";
        ClearInventory();
        fadeto(0, 0, 0, 0.0, 0.0);
        setplayerproperty(1, 0, prop_invulnerability);
        setplayerproperty(1, 0, prop_frozen);
        if (game_wackymod != WACKYMOD_FLIGHT)
            setplayerproperty(1, 0, PROP_FLY);

        // Check if player lost
        if (Check_Player_Lost(PlayerNumber()))
        {
            // Play music depending on the speed
            if (player_musicwinlose[PlayerNumber()] == false && GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_speed)
                {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Fail"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Fail", d:game_speed+1), 127); break;
                }
                player_musicwinlose[PlayerNumber()] = true;
            }
        }
        else
        {
            // Play music depending on the speed
            if (player_musicwinlose[PlayerNumber()] == false)
            {
                if (GetUserCVar(PlayerNumber(), "doomware_music"))
                {
                    switch (game_speed)
                    {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Win"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Win", d:game_speed+1), 127); break;
                    }
                }
                game_score[PlayerNumber()]++;
                player_musicwinlose[PlayerNumber()] = true;
                if (data_points[PlayerNumber()]+game_score[PlayerNumber()] >= 300)
                    Give_Achievement(PlayerNumber(), ACHIEVE_ID_300POINTS);
            }
        }
    }

    // Check if a tiebreaker has started
    if (game_status == STATUS_TIEDETECT && player_musicgameover[PlayerNumber()] == false && GetUserCVar(PlayerNumber(), "doomware_music"))
    {
        // Play the tie warning music
        LocalAmbientSound("DoomWare/TieBreaker", 127);
        player_musicgameover[PlayerNumber()] = true;
    }

    // Check if the game's over
    if (game_status == STATUS_GAMEOVER)
    {
        // Play the game over music
        if (player_musicgameover[PlayerNumber()] == false)
        {
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
                LocalAmbientSound("DoomWare/GameOver", 127);
            player_musicgameover[PlayerNumber()] = true;

            // Give the achievement if the player's score is 25 or more
            if (game_score[PlayerNumber()] >= 25)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_25POINTS);
        }

        // If the game ended normally
        if (game_over == OVER_WINNER || game_over == OVER_WINNERRED || game_over == OVER_WINNERBLUE || game_over == OVER_NOTIEGAMES)
        {
            // Award the winner with stats
            if ((game_teams && ((game_over == OVER_WINNERRED && GetPlayerInfo(PlayerNumber(), PLAYERINFO_TEAM) == TEAM_RED) || (game_over == OVER_WINNERBLUE && GetPlayerInfo(PlayerNumber(), PLAYERINFO_TEAM) == TEAM_BLUE))) || (!game_teams && game_score[PlayerNumber()] == game_highscores[0]))
            {               
                data_wins[PlayerNumber()]++;
                switch (data_wins[PlayerNumber()])
                {
                    case 1:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_1WIN);
                        break;
                    case 10:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_10WIN);
                        break;
                    case 50:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_50WIN);
                        break;
                }
				
				// Give the winner a BFG
				while (1)
				{
					if (CheckInventory("BFG9000") == 0 && game_over != OVER_NOTIEGAMES)
					{
						GiveInventory("BFG9000", 1000);
						GiveInventory("Cell", 1000);
						SetWeapon("BFG9000");
					}
					delay(1);
				}
            }
			
			// Loop here since the game is over
			while(1)
				delay(1);
        }
    }

    // Play Waiting/Speedup music
    if (player_musicwaiting[PlayerNumber()] == false)
    {
        // Check if the game is speeding up
        if (game_status == STATUS_SPEEDUP)
        {
            // Play the speedup music, depending on the speed
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_roundnum)
                {
                    case SPEEDUP1: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup"), 127); break;
                    case SPEEDUP2: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup2"), 127); break;
                    case SPEEDUP3: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup3"), 127); break;
                    case SPEEDUP4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup4"), 127); break;
                }
            }
            player_musicwaiting[PlayerNumber()] = true;
            player_musicgameover[PlayerNumber()] = false;
        }
        else if (game_status == STATUS_WAITING)
        {
            // Play the waiting music
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_speed)
                {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Intro"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Intro", d:game_speed+1), 127); break;
                }
            }
            player_musicwaiting[PlayerNumber()] = true;
            player_musicgameover[PlayerNumber()] = false;
        }
        fadeto(0, 0, 0, 0.0, 0.0); // Pokemon HUD brutefix
    }

    // Play a minigame
    str gametoplay;
    if (game_status == STATUS_MINIGAME)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_Minigame", d:round_current[game_roundnum-1]);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Play a 1v1 Tiebreaker
    if (game_status == STATUS_TIEBREAK)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_TieBreaker", d:round_tiebreaker);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Play a non 1v1 Tiebreaker
    if (game_status == STATUS_TIEBREAKM)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_TieBreakerM", d:round_tiebreaker);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Wait until the round's over
    int fragsmade = 0;
    while (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
    {
        // Give a 1Up if we got a frag
        if (player_frags[PlayerNumber()] < PlayerFrags() && minigame_fragpoints)
        {
            GiveInventory("1up", 1);
            fragsmade++;
            player_frags[PlayerNumber()] = PlayerFrags();

            // Award an achievement if we got 3 frags
            if (fragsmade >= 3)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_3FRAGS);
        }

        // Give points if we ate a 1UP
        if (CheckInventory("1up") > 0)
        {
            if (game_wackymod == WACKYMOD_T1UPS)
            {
                game_score[PlayerNumber()]+=3;
                data_1ups[PlayerNumber()]+=3;
            }
            else
            {
                game_score[PlayerNumber()]++;
                data_1ups[PlayerNumber()]++;
            }
            TakeInventory("1up", 1000);
            SpawnSpotForced("1UPText", PlayerNumber()+TID_PLAYER, 0, 0);
            LocalAmbientSound("DoomWare/1Up", 127);
            if (data_1ups[PlayerNumber()] == 50)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_501UPS);
        }
        delay(1);
    }

    // Clear out the minigame instructions
    minigame_instruction1[PlayerNumber()] = "";
    minigame_instruction2[PlayerNumber()] = "";
    minigame_instruction3[PlayerNumber()] = "";

    delay(1);
    if (PlayerInGame(PlayerNumber()) && !PlayerIsSpectator(PlayerNumber())) // Unless the player disconnected, restart the script
        restart;
}

Script "DoomWare_Client_DrawHUD" (void) CLIENTSIDE // HUD drawing "thread"
{
    // Make sure only the person who called it actually sees the HUD
    if (ConsolePlayerNumber() != PlayerNumber())
        terminate;

    int plynum = ConsolePlayerNumber();
    SetActivator(TID_PLAYER+plynum);

    // Open the menu if this is the player's first time joining
    if (GetUserCVar(plynum, "__doomware_firstjoin") == true)
    {
        SetUserCVar(plynum, "__doomware_firstjoin", false);
        RequestScriptPuke(999);
    }

    // Initialize the hud
    int w = GetScreenWidth();
    int h = GetScreenHeight();
    str hudsprite;
    if (GetUserCVar(plynum, "doomware_hudscale"))
    {
        w = 800;
        h = 600;
    }
    SetHudSize(w, h, true);
    w = w << 16;
    h = h << 16;

    bool remind_login = true;
    bool playedwackysound = false;
	bool diedinround = false;
    int hud_toppos  = 0.0;
    int hud_botpos  = h+64.0;
    int hud_spindex = 0;
    int hud_time    = 0;
    int wackymod_time = 0;
    int lasttimertime   = -1;
    if (GetCvar("__clientsync_gamestatus") <= STATUS_STARTING)
        hud_toppos = -95.0;

    while (1)
    {
        w = GetScreenWidth();
        h = GetScreenHeight();
        if (GetUserCVar(plynum, "doomware_hudscale"))
        {
            w = 800;
            h = 600;
        }
        SetHudSize(w, h, true);
        w = w << 16;
        h = h << 16;

        // Obtain the value of all global variables
        int syncdata_gamestatus = GetCvar("__clientsync_gamestatus");
        int syncdata_gameover = GetCvar("__clientsync_gameover");
        int syncdata_highscore1 = GetCvar("__clientsync_highscore1");
        int syncdata_highscore2 = GetCvar("__clientsync_highscore2");
        int syncdata_wincondition1 = GetCvar("__clientsync_wincondition1");
        int syncdata_wackymod = GetCvar("__clientsync_wackymod");
        str syncdata_highname = GetCVarString("__clientsync_highname");
        str syncdata_insctruction1 = Unpack_CVar_Array_String("__clientsync_player_instruction1");
        str syncdata_insctruction2 = Unpack_CVar_Array_String("__clientsync_player_instruction2");
        str syncdata_insctruction3 = Unpack_CVar_Array_String("__clientsync_player_instruction3");
        str syncdata_hint = GetCVarString("__clientsync_speeduphint");
        str syncdata_gamesolo = GetCvar("__clientsync_gamesolo");
        str syncdata_roundnum = GetCvar("__clientsync_round");
        str syncdata_canobserve = GetCvar("__clientsync_canobserve");
        str syncdata_timer = GetCvar("__clientsync_minigametimer");
        str syncdata_roundcurrent = GetCvar("__clientsync_roundcurrent");
        str syncdata_teams = GetCvar("__clientsync_teams");

        int syncdata_score = Unpack_CVar_Array("__clientsync_player_score");
        str syncdata_checklost = Unpack_CVar_Array("__clientsync_player_checklost");
        str syncdata_lostround = Unpack_CVar_Array("__clientsync_player_lostround");
        str syncdata_loggedin = Unpack_CVar_Array("__clientsync_player_loggedin");
        str syncdata_viewsprite = Unpack_CVar_Array_String("__clientsync_player_viewsprite");

        /*==============================
                 Center Text
        ==============================*/

        // Move the top of the HUD stuff downwards if game is ready
        if (syncdata_gamestatus >= STATUS_STARTING && hud_toppos < 0)
        {
            // Make some sounds
            if (hud_toppos == -92.0 && GetUserCVar(plynum, "doomware_huddynamic") && GetUserCVar(plynum, "doomware_hudsounds"))
                AmbientSound("DoomWare/HUDMove", 127);

            // Move the hud
            if (GetUserCVar(plynum, "doomware_huddynamic"))
                hud_toppos += 1.0;
            else
                hud_toppos = 0;
        }

        SetFont("DW_FONT4");
        if (syncdata_gamestatus == STATUS_NOTSTARTED) // State that we're waiting for players
        {
            HUDMessage(s:"Waiting for Players"; HUDMSG_PLAIN, MSGID_CENTER, CR_PURPLE, w/2, FixedMul(h, 0.25), 1);
            SetFont("DW_FONT5");
            HUDMessage(s:"\n\nOr Press ", k:"+dwscores", s:" to start a game by yourself"; HUDMSG_PLAIN, MSGID_CENTER2, CR_PURPLE, w/2, FixedMul(h, 0.25) + 4.0, 1);
            HUDMessage(s:"\n\n\n\nWarning: Most Minigames are designed with 2+ players in mind and stats won't be tracked!"; HUDMSG_PLAIN, MSGID_CENTER3, CR_RED, w/2, FixedMul(h, 0.25) + 4.0, 1);
        }
        else if (syncdata_gamestatus == STATUS_STARTING) // We're ready to go
        {
            int waittime = ((FixedDiv(syncdata_timer, SECOND)*100)&0xFFFF0000) >> 16;
            int waittens = waittime/1000;
            int waitones = (waittime/100)%10;
            int waittenths = (waittime/10)%10;
            int waithundredths = waittime%10;
            HUDMessage(s:"READY TO PLAY!"; HUDMSG_PLAIN, MSGID_CENTER, CR_PURPLE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(d:waittens, d:waitones, s:":", d:waittenths, d:waithundredths; HUDMSG_PLAIN, MSGID_CENTER2, CR_PURPLE, w/2, FixedMul(h, 0.25)+18.0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
        }
        else if (syncdata_gamestatus == STATUS_WACKYMOD) // Wacky modifier selection
        {
            HUDMessage(s:"WACKY MODIFIER"; HUDMSG_PLAIN, MSGID_CENTER, CR_BLUE, w/2, FixedMul(h, 0.25), 1);
            
            // Play roulette sound
            if (!playedwackysound && GetUserCVar(plynum, "doomware_hudsounds"))
            {
                AmbientSound("DoomWare/WackyMod", 127);
                playedwackysound = true;
            }
            
            // Roulette animation
            if (wackymod_time < (SECOND*2 + 15))
                HUDMessage(s:(WACKYMOD_NAME1+random(0,NUMBEROFWACKYMODS-1)); HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);
            else if (wackymod_time > (SECOND*3+17) || (wackymod_time%14 > 7))
			{
				str finalprint = (WACKYMOD_NAME1+(syncdata_wackymod-1));
				if (GetCVar("doomware_wackymodsmonsters"))
				{
					switch (syncdata_wackymod)
					{
						case WACKYMOD_FLIGHT:
						case WACKYMOD_1HP:
						case WACKYMOD_SPEED:
						case WACKYMOD_RAGE:
						case WACKYMOD_SPREAD:
							finalprint = StrParam(s:finalprint, s:"\nMonsters also affected");
					}
				}
                HUDMessage(s:finalprint; HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);
			}
            else 
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_BLACK, 0, 0, 1);
                
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
            wackymod_time++;
        }
        else if (syncdata_gamestatus == STATUS_SPEEDUP)
        {
            // Announce the speedup, and select a hint from the pile
            HUDMessage(s:"Speed Up"; HUDMSG_PLAIN, MSGID_CENTER, CR_BLUE, w/2, FixedMul(h, 0.25), 1);
            SetFont("DW_FONT5");
            HUDMessage(s:syncdata_hint; HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);

            // Do animation stuff for the HIUD
            hud_time += 1;
            if (hud_time > SECOND/4)
            {
                hud_time = 0;
                hud_spindex = (hud_spindex + 1)%2;
            }
        }
        else if (syncdata_gamestatus == STATUS_WINLOSE)
        {
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_GREEN, 0.5, 0.3, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);

            // Do animation stuff for the HIUD
            hud_time += 1;
            if (hud_time > SECOND/4)
            {
                hud_time = 0;
                hud_spindex = (hud_spindex + 1)%3;
            }

            // Check if player lost
            if (syncdata_checklost == 1)
                HUDMessage(s:"You Failed!"; HUDMSG_PLAIN, MSGID_CENTER, CR_RED, w/2, FixedMul(h, 0.25), 1);
            else
                HUDMessage(s:"You Won!"; HUDMSG_PLAIN, MSGID_CENTER, CR_GREEN, w/2, FixedMul(h, 0.25), 1);
        }
        else if (syncdata_gamestatus == STATUS_TIEDETECT)
        {
            HUDMessage(s:"Game Over"; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\nThere is a tie, initializing Tie Breaker round."; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);
        }
        else if (syncdata_gamestatus == STATUS_GAMEOVER)
        {
            HUDMessage(s:"Game Over"; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_GREEN, 0.5, 0.3, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);

            // State why the game ended
            switch (syncdata_gameover)
            {
                case OVER_WINNER:
                    HUDMessage(s:"\n\nThe winner is ", s:syncdata_highname, s:" with ", d:syncdata_highscore1, s:" points"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERRED:
                    HUDMessage(s:"\n\nRED Team Victory!"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERBLUE:
                    HUDMessage(s:"\n\n\chBLUE Team\cg Victory!"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERSOLO:
                    if (syncdata_score != 1)
                        HUDMessage(s:"\n\nYou scored ", d:syncdata_score, s:" points"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    else
                        HUDMessage(s:"\n\nYou scored 1 point"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_PLAYER:
                    HUDMessage(s:"\n\nThere are not enough players"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_FORCED:
                    HUDMessage(s:"\n\nThe game was forcefully ended"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_JOIN:
                    HUDMessage(s:"\n\nA new player has entered the game"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_NOTIEGAMES:
                    HUDMessage(s:"\n\nThere is a tie for first place"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
            }
        }
        else if (syncdata_gamestatus == STATUS_MINIGAME || syncdata_gamestatus == STATUS_TIEBREAK || syncdata_gamestatus == STATUS_TIEBREAKM)
        {
            HUDMessage(s:syncdata_insctruction1; HUDMSG_PLAIN, MSGID_CENTER, CR_ORANGE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\n", s:syncdata_insctruction2; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\n\n\n", s:syncdata_insctruction3; HUDMSG_PLAIN, MSGID_CENTER3, CR_RED, w/2, FixedMul(h, 0.25), 1);
        }
        else
        {
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
        }


        /*==============================
                 HUD Animation
        ==============================*/

        if (syncdata_gamestatus == STATUS_WINLOSE && GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (syncdata_checklost == 0)
                hudsprite = StrParam(s:"WIN", d:(hud_spindex+1));
            else
                hudsprite = "FAIL";
        }
        else if (syncdata_gamestatus == STATUS_SPEEDUP && GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (hud_spindex == 0)
                hudsprite = "SPED";
            else
                hudsprite = "OFF";
        }
        else
            hudsprite = "OFF";


        /*==============================
               Leader and Spread
        ==============================*/

        if (syncdata_gamesolo == 0)
        {
            // Background
            SetFont(StrParam(s:"HUD2", s:hudsprite));
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_LEADER2, CR_PURPLE, w/2, hud_toppos + 0.1, 1);

            if (syncdata_gamestatus > STATUS_STARTING)
            {
                // If the player is in a team
                if (syncdata_teams)
                {
                    int myteamscore = 0;
                    switch (GetPlayerInfo(ConsolePlayerNumber(), PLAYERINFO_TEAM))
                    {
                        case TEAM_BLUE:
                            myteamscore = syncdata_highscore1;
                            break;
                        case TEAM_RED:
                            myteamscore = syncdata_highscore2;
                            break;
                    }
                    
                    // Leading team
                    SetFont("DW_FONT1");
                    if (syncdata_highscore1 == syncdata_highscore2)
                        HUDMessage(s:"Teams are tied"; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);
                    else if (syncdata_highscore1 > syncdata_highscore2)
                        HUDMessage(s:"Blue Team"; HUDMSG_PLAIN, MSGID_LEADER, CR_BLUE, w/2, hud_toppos+46.0, 1);
                    else
                        HUDMessage(s:"Red Team"; HUDMSG_PLAIN, MSGID_LEADER, CR_RED, w/2, hud_toppos+46.0, 1);

                    // Spread
                    SetFont("DW_FONT3");
                    if (syncdata_highscore1 == myteamscore)
                    {
                        if (syncdata_highscore1 >= syncdata_highscore2)
                            HUDMessage(s:"+", d:(syncdata_highscore1-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                        else
                            HUDMessage(s:"-", d:(syncdata_highscore2-syncdata_highscore1); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                    }
                    else
                    {
                        if (syncdata_highscore2 >= syncdata_highscore1)
                            HUDMessage(s:"+", d:(syncdata_highscore2-syncdata_highscore1); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                        else
                            HUDMessage(s:"-", d:(syncdata_highscore1-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                    }
                }
                else
                {
                    // Leading player
                    SetFont("DW_FONT1");
                    if (syncdata_highscore1 == syncdata_highscore2)
                        HUDMessage(s:"There are multiple leaders"; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);
                    else
                        HUDMessage(s:syncdata_highname; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);

                    // Spread
                    SetFont("DW_FONT3");
                    if (syncdata_highscore1 <= syncdata_score)
                        HUDMessage(s:"+", d:(syncdata_score-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                    else
                        HUDMessage(s:"-", d:(syncdata_highscore1-syncdata_score); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                }
                
                // Remind people that they can view the highscore table
                if (GetUserCVar(plynum, "doomware_hudshowbinds"))
                    HUDMessage(s:"\n\n\nPress ", k:"+dwscores", s:" to view the Highscore table"; HUDMSG_PLAIN, MSGID_VIEWHS, CR_ORANGE, w/2, hud_toppos+64.0 + 0.1, 1);
                else
                    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWHS, CR_ORANGE, w/2, hud_toppos+64.0 + 0.1, 1);
            }
        }


        /*==============================
                     Score
        ==============================*/

        int x_start = 64.0;
        if (GetUserCVar(plynum, "doomware_hudscale") && GetUserCVar(plynum, "doomware_hudwide"))
            x_start = -48.0;
        SetFont(StrParam(s:"HUD1", s:hudsprite));
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_SCORE2, CR_PURPLE, x_start + 0.1, hud_toppos + 0.1, 1);
        SetFont("HUD1SCOR");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_SCORE3, CR_PURPLE, x_start+32.0 + 0.1, hud_toppos + 9.0 + 0.1, 1);
        if (syncdata_gamestatus > STATUS_STARTING)
        {
            SetFont("DW_FONT1");
            HUDMessage(d:syncdata_score; HUDMSG_PLAIN, MSGID_SCORE, CR_YELLOW, x_start+64.0, hud_toppos+46.0, 1);
            if (GetUserCVar(plynum, "doomware_hudshowbinds"))
            {
                SetFont("DW_FONT3");
                HUDMessage(s:"Press ", k:"+dwmenu", s:" to open the menu"; HUDMSG_PLAIN, MSGID_MENUBIND, CR_YELLOW, x_start+64.0 + 0.4, hud_toppos + 68.0 + 0.1, 1);
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MENUBIND, CR_YELLOW, 0.0, 0.0, 1);
        }


        /*==============================
                     Round
        ==============================*/

        SetFont(StrParam(s:"HUD1", s:hudsprite));
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_ROUND2, CR_PURPLE, w-x_start + 0.2, hud_toppos + 0.1, 1);
        SetFont("HUD1RND");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_ROUND3, CR_PURPLE, w-x_start-32.0 + 0.2, hud_toppos + 9.0 + 0.1, 1);
        if (GetUserCVar(plynum, "doomware_hudshowbinds") && syncdata_canobserve && syncdata_lostround)
        {
            SetFont("DW_FONT3");
            HUDMessage(s:"Press ", k:"+dwobserve", s:" to observe the game"; HUDMSG_PLAIN, MSGID_OBSERVE, CR_CYAN, w-x_start-64.0 + 0.4, hud_toppos + 68.0 + 0.1, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_OBSERVE, CR_CYAN, 0.0, 0.0, 1);
        SetFont("DW_FONT1");
        if (syncdata_gamestatus > STATUS_STARTING)
        {
            if (syncdata_roundnum <= MAXROUNDS)
                HUDMessage(d:syncdata_roundnum; HUDMSG_PLAIN, MSGID_ROUND, CR_GREEN, w-x_start-64.0, hud_toppos+46.0, 1);
            else
                HUDMessage(d:MAXROUNDS; HUDMSG_PLAIN, MSGID_ROUND, CR_GREEN, w-x_start-64.0, hud_toppos+46.0, 1);
        }


        /*==============================
                     Timer
        ==============================*/

        if (syncdata_gamestatus != STATUS_STARTING)
        {
            if (GetUserCVar(plynum, "doomware_huddynamic"))
            {
                if (syncdata_timer != TIMER_EARLY && syncdata_timer <= 0 && hud_botpos < h+64.0)
                    hud_botpos += 4.0;
                else if (syncdata_timer > 0 && hud_botpos > h)
                    hud_botpos -= 4.0;

                // In case people decide to resize the hud midway through the round
                if (hud_botpos < h)
                    hud_botpos = h;
            }
            else
            {
                if (syncdata_timer > 0)
                    hud_botpos = h;
                else
                    hud_botpos = h+64.0;
            }

            SetHudSize(w>>16, h>>16, false);
            if (syncdata_timer == TIMER_EARLY)
                SetFont("HUDCLK2");
            else
                SetFont("HUDCLK1");

            if (hud_botpos != h+64.0)
                HUDMessage(s:"a"; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER2, CR_GREEN, w/2, hud_botpos + 0.2, 1);
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_TIMER2, CR_GREEN, 0.0, 0.0, 1);
            SetFont("DW_FONT2");
            int time = ((FixedDiv(syncdata_timer, SECOND)*100)&0xFFFF0000) >> 16;
            int oldtime = ((FixedDiv(lasttimertime, SECOND)*100)&0xFFFF0000) >> 16;
            int tens = time/1000;
            int ones = (time/100)%10;
            int oldones = (oldtime/100)%10;
            int tenths = (time/10)%10;
            int hundredths = time%10;
            if (syncdata_timer > 0)
            {
                HUDMessage(d:tens, d:ones, s:":", d:tenths, d:hundredths; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER, CR_RED, w/2, hud_botpos - 16.0 + 0.2, 1);

                // Play some ticking sounds when there's 3, 2, 1 seconds left
                if (GetUserCvar(plynum, "doomware_hudsounds") && tens == 0)
                {
                    if (ones == 2 && oldones == 3)
                        AmbientSound("DoomWare/Clock3", 127);
                    if (ones == 1 && oldones == 2)
                        AmbientSound("DoomWare/Clock2", 127);
                    if (ones == 0 && oldones == 1)
                        AmbientSound("DoomWare/Clock1", 127);
                }
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER, CR_RED, w/2, hud_botpos + 0.2, 1);
        }

        /*==============================
                Wacky Mod Notice
        ==============================*/

        int extray = 0.0;
        SetFont("DW_FONT5");
        
        // Wacky Modifier
        if (syncdata_wackymod != WACKYMOD_NONE && syncdata_gamestatus > STATUS_WACKYMOD)
        {
            if (remind_login)
                extray = 16.0;
            HUDMessage(s:"Wacky Modifier: ", s:(WACKYMOD_NAME1+(syncdata_wackymod-1)); HUDMSG_PLAIN, MSGID_WACKYMOD, CR_CYAN, w/2 + 0.4, h + 0.2, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_WACKYMOD, CR_CYAN, w/2, h + 0.2, 1);
            

        /*==============================
                    Warnings
        ==============================*/
        
		SetHudSize(w>>16, h>>16, false);
        SetFont("DW_FONT5");
        if (PlayerCount() > MAXPLAYERS)// Warn that we have too many players
            HUDMessage(s:"WARNING! TOO MANY PLAYERS! MAX: ", d:MAXPLAYERS; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2, h-extray + 0.2, 1);
        else if (remind_login == true && GetUserCVar(plynum, "doomware_loginwarn")) // Remind players to login
        {
            HUDMessage(s:"You are not logged in, your stats will not be tracked!\nPress ", k:"+use", s:" to dismiss this message."; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2 + 0.4, h-extray + 0.2, 1);

            // Allow players to dismiss that message
            if (GetPlayerInput(plynum, MODINPUT_BUTTONS) & BT_USE || syncdata_loggedin)
                remind_login = false;
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2, h + 0.2, 1);


        /*==============================
            Player position observing
        ==============================*/
        
        if (CheckPlayerCamera(plynum) != TID_PLAYER+plynum && (ClassifyActor(TID_PLAYER+plynum) & ACTOR_ALIVE))
        {
            int camtid = CheckPlayerCamera(plynum);
            int plyx = GetActorX(TID_PLAYER+plynum)-GetActorX(camtid);
            int plyy = GetActorY(TID_PLAYER+plynum)-GetActorY(camtid);
            int plyz = GetActorZ(TID_PLAYER+plynum);
            int dist, xScale, yScale;
            
            // Get the player's angle and distance
            int vang = VectorAngle(plyx, plyy);
            int angle = (vang - GetActorAngle(camtid) + 1.0) % 1.0;
            if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(plyy, sin(vang));
            else dist = FixedDiv(plyx, cos(vang));

            // Scale the cursor
            if (GetUserCVar(plynum, "doomware_hudwide"))
            {
                xScale = 1072;
                yScale = 603;
            }
            else
            {
                xScale = 800;
                yScale = 600;
            }
            SetHudSize(xScale, yScale, 0);

            // If the player is inside our horizontal view
            if ((angle < 0.23 || angle > 0.85) && dist < 1024.0)
            {
                // And our vertical view
                if (GetActorPitch(camtid) >= -0.5 && GetActorPitch(camtid) <= 0.5)
                {
                    // Get the player angles
                    int pitch = VectorAngle(dist, plyz - (GetActorZ(camtid) + GetActorViewHeight(camtid)));
                    pitch += FixedMul(GetActorPitch(camtid), 1.2) % 1.0;

                    // If the player is in our view (taking into account angles)
                    if ((xScale/2) * sin(angle) != 0 && cos(angle) != 0 && (xScale/2) * sin(pitch) != 0 && cos(pitch) != 0)
                    {
                        // Finalize the x and y positions
                        plyx = xScale/2 - ((xScale/2) * sin(angle) / cos(angle));
                        plyy = yScale/2 - ((xScale/2) * sin(pitch) / cos(pitch));
                        SetFont("YOUHA0");
                        HudMessage(c:'A'; HUDMSG_ALPHA, MSGID_PLYHERE, CR_WHITE, plyx << 16, plyy << 16, 1);
                    }
                }
            }
        }
        else
            HudMessage(s:""; HUDMSG_ALPHA, MSGID_PLYHERE, CR_WHITE, 0.0, 0.0, 1);


        /*==============================
            Extra Minigame Elements
        ==============================*/

		// Handle throwback minigame STATUSBAR's
        if (syncdata_gamestatus == STATUS_MINIGAME && GetCVar("screenblocks") < 11 && (!diedinround || (diedinround && GetActorProperty(TID_PLAYER+ConsolePlayerNumber(), APROP_Health) <= 0)))
        {
            int status_w = 320;
            int status_h = 200;
            if (!GetCVar("st_scale"))
            {
                status_w = GetScreenWidth();
                status_h = GetScreenHeight();
            }
            SetHudSize(status_w, status_h, true);
            status_w = (status_w << 16)/2 + 0.4;
            status_h = (status_h << 16)-200.0 + 0.1;
			
			// Animate the STATUSBAR face
            hud_time +=1;
            if (hud_time >= 20)
            {
                hud_spindex = random(1, 4);
                hud_time = 0;
            }
			
			// Draw the STATUSBAR
			DoomWare_Client_HUDStatusBars(syncdata_roundcurrent, hud_time, hud_spindex, status_w, status_h, diedinround);
        }
        else
        {
            hudmessage(s:"";HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, 0.5, 0.5, 1);
            hudmessage(s:"";HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, 0.5, 0.5, 1);
        }

        // View sprite
        if (StrCmp(syncdata_viewsprite, "") != 0)
        {
            if (syncdata_wincondition1 == 1337)
                SetHudSize(320, 200, false);
            else if (syncdata_wincondition1 == 1338)
                SetHudSize(20, 18, false);
            else
                SetHudSize(640, 400, false);
            SetFont(syncdata_viewsprite);
            HUDMessage(s:"A"; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_VIEWSP, CR_WHITE, 0.5, 0.9, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWSP, CR_WHITE, 160.0, 120.0, 1);

		// Checking if the player died in a round
		if (syncdata_gamestatus == STATUS_MINIGAME)
		{
			if (GetActorProperty(TID_PLAYER+ConsolePlayerNumber(), APROP_Health) <= 0)
				diedinround = true;
		}
		else
			diedinround = false;


        SetHudSize(w>>16, h>>16, true);

        lasttimertime = syncdata_timer;

        if (PlayerInGame(plynum))
            delay(1);
        else
            break;
    }
}


/*===================================================================================================
										Minigame Functions
===================================================================================================*/

function void Check_LMS(void) // Check if only one player is alive, and make him win if so
{
    int i;
    
    // Decide on how to check for LMS depending on whether we're playing a team game or not
    if (game_teams)
    {
        int redalive = 0;
        int bluealive = 0;
        
        // Iterate through all players and check if they haven't lost the round
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (player_midround[i])
            {
                switch(GetPlayerInfo(i, PLAYERINFO_TEAM))
                {
                    case TEAM_RED:
                        redalive++;
                        break;
                    case TEAM_BLUE:
                        bluealive++;
                        break;
                    default:
                        break;
                }
            } 
        }
        
        // If one team has no members, and at least one team has a member alive
        if ((redalive == 0 || bluealive == 0) && !(bluealive == 0 && redalive == 0))
        {
            // Iterate through all players again, and win them if they're alive
            for (i=0; i<MAXPLAYERS; i++)
			{
                if (player_midround[i])
				{
                    Player_Win(i);
					if (round_is1vmtiebreaker)
						Give_Achievement(i, ACHIEVE_ID_MVMWIN);
				}
			}
        }
    }
    else
    {
        int alivecount = 0;
        int winid = -1;
        
        // Iterate through all players and check if they haven't lost the round
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (player_midround[i])
            {
                winid = i;
                alivecount++;
            }
        }

        // If only one person is alive, make them win
        if (alivecount == 1)
		{
            Player_Win(winid);
			if (round_is1vmtiebreaker)
				Give_Achievement(winid, ACHIEVE_ID_MVMWIN);
		}
    }
}

function void Check_WonRoundItem(void) // Makes players with WonRoundItem in their inventory win
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (CheckActorInventory(TID_PLAYER+i, "WonRoundItem") > 0)
            Player_Win(i);
}

function void Check_FailRoundItem(void) // Makes players with FailRoundItem in their inventory lose
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (CheckActorInventory(TID_PLAYER+i, "FailRoundItem") > 0)
            Player_Lose(i, false);
}

function bool Should_Speedup(void) // Return true/false if we are speeding up
{
    if (game_wackymod == WACKYMOD_SPEEDUP)
        return false;
    switch (game_roundnum)
    {
        case SPEEDUP1: break;
        case SPEEDUP2: break;
        case SPEEDUP3: break;
        case SPEEDUP4: break;
        default: return false; break;
    }
    return true;
}

function bool Should_TieBreak(void) // Return true/false if we should initialize a tiebreaker round
{        
    // Don't check if we were in a solo game or it was forcefully ended
    if (game_solo || game_over == OVER_FORCED)
        return false;
    
    // If we're not playing a team game, then just check if the top 2 players are tied
    if (!game_teams)
        return (game_highscores[0] == game_highscores[1]);
    
    // Return whether or not the team scores match
    return (game_scoreteams[TEAM_BLUE] == game_scoreteams[TEAM_RED]); // TODO: Expand this for more than 2 teams using a loop
}

function bool Is_1v1_TieBreaker(void) // Return true/false if we are playing a 1v1 tiebreaker
{
    return (((PlayerCount() == 2 && game_teams) || !game_teams) && game_highscores[0] == game_highscores[1] && game_highscores[0] != game_highscores[2]);
}

function bool No_MidRound_Array(void) // Return whether everyone has passed/failed
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (player_midround[i] != false && PlayerInGame(i))
            return false;
    return true;
}


/*===================================================================================================
                                          Player Functions
===================================================================================================*/

function void Player_Win(int plynum) // Make a player win
{
    if (player_midround[plynum] == true)
    {
		int active = ActivatorTID();
		SetActivatorToPlayer(plynum);
        LocalAmbientSound("DoomWare/Check", 127);
        SpawnSpotForced("WonRoundEffect", TID_PLAYER+plynum, 0, 0);
        player_wonround[plynum] = true;
        player_midround[plynum] = false;
            
		// Reset the activator to prevent problems
		if (active < TID_PLAYER)
			SetActivator(0, AAPTR_NULL);
		else
			SetActivatorToPlayer(active-TID_PLAYER);
    }
}

function void Player_Lose(int plynum, bool silent) // Make a player lose
{
    if (player_midround[plynum] == true)
    {
        // Make the sound + effects
        if (!silent)
        {
			int active = ActivatorTID();
            SetActivatorToPlayer(plynum);
            LocalAmbientSound("DoomWare/Failure", 127);
            SpawnSpotForced("FailedRoundEffect", TID_PLAYER+plynum, 0, 0);
            
			// Reset the activator to prevent problems
			if (active < TID_PLAYER)
				SetActivator(0, AAPTR_NULL);
			else
				SetActivatorToPlayer(active-TID_PLAYER);
        }
        player_lostround[plynum] = true;
        player_midround[plynum] = false;

        // If in a 1v1 tiebreaker, make the other player win
        if (game_status == STATUS_TIEBREAK)
        {
            if (plynum == game_highnames[0])
            {
                Player_Win(game_highnames[1]);
                Give_Achievement(game_highnames[1], ACHIEVE_ID_1v1WIN);
            }
            else if (plynum == game_highnames[1])
            {
                Player_Win(game_highnames[0]);
                Give_Achievement(game_highnames[0], ACHIEVE_ID_1v1WIN);
            }
        }
    }
}

function void Player_SetWackymod(int plynum) // Sets the wacky modifier on a player
{
	// Set team items
	if (game_teams)
	{
		switch (GetPlayerInfo(plynum, PLAYERINFO_TEAM))
		{
			case TEAM_BLUE:
				GiveActorInventory(TID_PLAYER+plynum, "BlueTeamItem", 1);
				break;
			case TEAM_RED:
				GiveActorInventory(TID_PLAYER+plynum, "RedTeamItem", 1);
				break;
		}
	}
	
    // Enable wacky mod    
    if (game_wackymod != WACKYMOD_NONE && game_status != STATUS_WACKYMOD)
    {
        switch (game_wackymod)
        {
            case WACKYMOD_JUMP:
                if (!player_haswackyscript[plynum])
                {
                    ACS_NamedExecuteAlways("DoomWare_WackyMod_DoubleJump", 0);
                    player_haswackyscript[plynum] = true;
                }
                break;
            case WACKYMOD_FLIGHT:
                setplayerproperty(1, 1, PROP_FLY);
                break;
            case WACKYMOD_SPEED:
                setplayerproperty(1, 1, PROP_SPEED);
                break;
            case WACKYMOD_INVERT:
                SetActorProperty(TID_PLAYER+plynum, APROP_Speed, -1.0);
                break;
            case WACKYMOD_1HP:
                SetActorProperty(TID_PLAYER+plynum, APROP_Health, 1);
                break;
            case WACKYMOD_SPREAD:
                GiveActorInventory(TID_PLAYER+plynum, "PowerSpread", 1);
                break;
            case WACKYMOD_RAGE:
                GiveActorInventory(TID_PLAYER+plynum, "PowerDoubleFiringSpeed", 1);
                break;
        }
    }    
}

function void Player_SavePosition(int plynum) // Stores the player's position
{
    player_position[plynum][0] = GetActorX(TID_PLAYER+plynum);
    player_position[plynum][1] = GetActorY(TID_PLAYER+plynum);
    player_position[plynum][2] = GetActorZ(TID_PLAYER+plynum);
}

function void Player_InvalidatePosition(int plynum) // Clears the stored player's position
{
    player_position[plynum][0] = 0xFFFFFFFF;
    player_position[plynum][1] = 0xFFFFFFFF;
    player_position[plynum][2] = 0xFFFFFFFF;
}

function bool Check_Player_Won(int plynum) // Returns true/false if this player won the round
{
    return (player_wonround[plynum] || (player_midround[plynum] && round_winifmid));
}

function bool Check_Player_Lost(int plynum) // Returns true/false if this player lost the round
{
    return (player_lostround[plynum] || (player_midround[plynum] && !round_winifmid));
}

function void Player_Morph(int plynum, str class) // Morphs the player into the provided class
{
    UnMorphActor(TID_PLAYER+plynum, true);
    SpawnSpotForced("PlayerTranslator", TID_PLAYER+plynum, TID_EXTRA+plynum, 0);
    Thing_SetTranslation(TID_EXTRA+plynum, -1);
    MorphActor(TID_PLAYER+plynum, class, 1, minigame_timer, MRF_NEWTIDBEHAVIOUR, "Nothing", "Nothing");
    if (game_wackymod == WACKYMOD_INVERT && GetActorProperty(0, APROP_Speed) > 0)
        SetActorProperty(0, APROP_Speed, -GetActorProperty(0, APROP_Speed));
	if (game_wackymod == WACKYMOD_1HP)
		SetActorProperty(TID_PLAYER+plynum, APROP_Health, 1);
}

function void Player_FreezeTotally(int who) // Totally freezes the player without messing with other freezes
{
    SetPlayerProperty(who, 1, PROP_TOTALLYFROZEN);

    if (who == 0)
        player_frozen[PlayerNumber()] = true;
    else
        for (int i=0; i<MAXPLAYERS; i++)
            player_frozen[i] = true;
}

function void Player_UnFreezeTotally(int who) // Totally unfreezes the player without messing with other freezes
{
    int i;
    if (who == 0 && !player_viewingmenu[PlayerNumber()])
        SetPlayerProperty(who, 0, PROP_TOTALLYFROZEN);
    else if (who == 1)
         for (i=0; i<MAXPLAYERS; i++)
            if (!player_viewingmenu[i])
                SetPlayerProperty(who, 0, PROP_TOTALLYFROZEN);

    if (who == 0)
        player_frozen[PlayerNumber()] = false;
    else
        for (i=0; i<MAXPLAYERS; i++)
            player_frozen[i] = false;
}

function void Give_Achievement(int plynum, int achievement) // Gives the player an achievement
{
	int active = ActivatorTID();
	str name = "";
	
	if (!PlayerInGame(plynum))
		return;
	
    if ((PlayerIsLoggedIn(plynum) || GetCVar("doomware_unsafedb")) && game_status != STATUS_NOTSTARTED && !game_solo && (data_achieve[plynum] & (1<<achievement)) == 0)
    {
        data_achieve[plynum] = data_achieve[plynum] | (1<<achievement);
        switch(achievement)
        {
            case ACHIEVE_ID_1WIN:       name = ACHIEVE_NAME_1WIN; Break;
            case ACHIEVE_ID_10WIN:      name = ACHIEVE_NAME_10WIN; Break;
            case ACHIEVE_ID_50WIN:      name = ACHIEVE_NAME_50WIN; Break;
            case ACHIEVE_ID_25POINTS:   name = ACHIEVE_NAME_25POINTS; Break;
            case ACHIEVE_ID_1V1WIN:     name = ACHIEVE_NAME_1V1WIN; Break;
            case ACHIEVE_ID_MVMWIN:     name = ACHIEVE_NAME_MVMWIN; Break;
            case ACHIEVE_ID_501UPS:     name = ACHIEVE_NAME_501UPS; Break;
            case ACHIEVE_ID_100DEATH:   name = ACHIEVE_NAME_100DEATH; Break;
            case ACHIEVE_ID_300POINTS:  name = ACHIEVE_NAME_300POINTS; Break;
            case ACHIEVE_ID_JUMP:       name = ACHIEVE_NAME_JUMP; Break;
            case ACHIEVE_ID_LONGJUMP:   name = ACHIEVE_NAME_LONGJUMP; Break;
            case ACHIEVE_ID_3FRAGS:     name = ACHIEVE_NAME_3FRAGS; Break;
            case ACHIEVE_ID_BULLETHELL: name = ACHIEVE_NAME_BULLETHELL; Break;
            case ACHIEVE_ID_KARTWIN:    name = ACHIEVE_NAME_KARTWIN; Break;
            case ACHIEVE_ID_ATST:       name = ACHIEVE_NAME_ATST; Break;
            case ACHIEVE_ID_WAIFU:      name = ACHIEVE_NAME_WAIFU; Break;
            case ACHIEVE_ID_BOSS:       name = ACHIEVE_NAME_BOSS; Break;
            case ACHIEVE_ID_FULLSERVER: name = ACHIEVE_NAME_FULLSERVER; Break;
            default: break;
        }
        ACS_NamedExecuteAlways("DoomWare_AchievementLog", 0, plynum, name); // We can't do Log() serverside, so this is a workaround

        // Notify the achievement got received
        SetActivatorToPlayer(plynum);
        SpawnSpotForced("ConfettiEffect", TID_PLAYER+plynum, 0, 0);
        SetFont("DW_FONT1");
        if (game_status != STATUS_NOTSTARTED && name != "")
        {
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            str hudsprite;
            if (GetUserCVar(PlayerNumber(), "doomware_hudscale"))
            {
                w = 800;
                h = 600;
            }
            SetHudSize(w, h, true);
            w = w << 16;
            h = h << 16;
            HUDMessage(s:"Achievement Unlocked!\n", s:name; HUDMSG_FADEOUT, MSGID_ACHIEVEM, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.8) + 0.2, 1.0, 1.0);
            if (GetUserCvar(PlayerNumber(), "doomware_hudsounds"))
                LocalAmbientSound("DoomWare/Achievement", 127);
        }
		
		// Reset the activator to prevent problems
		if (active < TID_PLAYER)
			SetActivator(0, AAPTR_NULL);
		else
			SetActivatorToPlayer(active-TID_PLAYER);
        
        // Give the achiever role if this person unlocked all the achievements
        if (data_achieve[plynum] == 0x3FFFF && data_role[plynum] != ROLE_BETA && data_role[plynum] != ROLE_BUU342)
            data_role[plynum] = ROLE_ACHIEVER;
    }
}


/*===================================================================================================
                                         Variable Networking
===================================================================================================*/

Script "DoomWare_Server_SyncGlobals" (void) // Global variable networking "thread".
{
    /*
        Why on earth are global variables not synced between the server and
        CLIENTSIDE scripts??? Pretty much every single game engine I've worked on
        At least gives me the option of marking a variable as "Syncable" to the
        client...
    */
    str leadname = StrParam(n:(game_highnames[0]+1));
    Player_SetCVar("__clientsync_round", game_roundnum);
    Player_SetCVar("__clientsync_gamestatus", game_status);
    Player_SetCVar("__clientsync_gameover", game_over);
    Player_SetCVar("__clientsync_minigametimer", minigame_timer);
    Player_SetCVar("__clientsync_wincondition1", minigame_wincondition1);
    Player_SetCVarString("__clientsync_highname", leadname);
    Player_SetCVarString("__clientsync_speeduphint", round_hints[game_speed-1]);
    Player_SetCVar("__clientsync_canobserve", minigame_canobserve);
    Player_SetCVar("__clientsync_canmove", minigame_canmove);
    Player_SetCVar("__clientsync_gamesolo", game_solo);
    Player_SetCVar("__clientsync_roundcurrent", round_current[game_roundnum-1]);
    Player_SetCVar("__clientsync_wackymod", game_wackymod);
    Player_SetCVar("__clientsync_teams", game_teams);
    
    // Sync the team scores, or the top 2 scores if we're not in a team mode
    if (game_teams)
    {
        Player_SetCVar("__clientsync_highscore1", game_scoreteams[TEAM_BLUE]);
        Player_SetCVar("__clientsync_highscore2", game_scoreteams[TEAM_RED]);
    }
    else
    {
        Player_SetCVar("__clientsync_highscore1", game_highscores[0]);
        Player_SetCVar("__clientsync_highscore2", game_highscores[1]);
    }

    // Pack player data
    Pack_Global_Array("__clientsync_player_score");
    Pack_Global_Array("__clientsync_player_loggedin");
    Pack_Global_Array("__clientsync_player_datascore");
    Pack_Global_Array("__clientsync_player_datawins");
    Pack_Global_Array("__clientsync_player_datadeaths");
    Pack_Global_Array("__clientsync_player_data1ups");
    Pack_Global_Array("__clientsync_player_dataroles");
    Pack_Global_Array("__clientsync_player_dataachieve");
    Pack_Global_Array("__clientsync_player_databosskills");
    Pack_Global_Array("__clientsync_player_checklost");
    Pack_Global_Array("__clientsync_player_lostround");
    Pack_Global_Array("__clientsync_player_viewingmenu");
    Pack_Global_Array("__clientsync_player_instruction1");
    Pack_Global_Array("__clientsync_player_instruction2");
    Pack_Global_Array("__clientsync_player_instruction3");
    Pack_Global_Array("__clientsync_player_viewsprite");

    delay(1);
    restart;
}

function void DB_NetworkStats(str namespace, str cvarname) // Updates the global stats variables to network to clients
{
    int stat_t = 0;
    int stat_g = 0;
    int stat_n = "Multiple Players";
    int res = GetDBEntries(namespace);
    int c = CountDBResults(res);
    if (c != 0)
    {
        FreeDBResults(res);
        res = SortDBEntries(namespace, c, 0, true);
        if (GetDBResultValue(res, 0) != GetDBResultValue(res, 1))
            stat_n = GetDBResultKeyString(res, 0);
        for (int i=0; i<c; i++)
            stat_g += GetDBResultValue(res, i);
        stat_t = GetDBResultValue(res, 0);
        
        Player_SetCVar(StrParam(s:"__clientsync_stats_t_", s:cvarname), stat_t);
        Player_SetCVar(StrParam(s:"__clientsync_stats_g_", s:cvarname), stat_g);
        Player_SetCVarString(StrParam(s:"__clientsync_stats_n_", s:cvarname), stat_n);
    }
    FreeDBResults(res);
}

function void Player_SetCVar(str cvar, int value) // Efficient SetCVar function
{
    if (GetCVar(cvar) != value)
        SetCVar(cvar, value);
}

function void Player_SetCVarString(str cvar, str value) // Efficient SetCVarString function
{
    if (StrCmp(GetCVarString(cvar), value))
        SetCVarString(cvar, value);
}

function void Pack_Global_Array(str cvar) // Replacement for Get/SetUserCVar
{
    /*
        Since GetUserCVar is broken on Zandronum, instead I fill everyone's data into a single
        string and make it a server cvar. A new line represents a different player, so the data
        in line 3 of the string corresponds to the data of PlayerNumber() == 3
    */
    int i;
    str final = "";
    
    /* 
        Super ugly hack!
        Strings in ACS are pretty much just integers that point to a string table. This means that
        You can do string comparisons in a switch statement! Literally O(1) string comparisons!
    */
    switch (cvar)
    {
        case "__clientsync_player_score":         for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:game_score[i], s:"\n"); break;
        case "__clientsync_player_loggedin":      for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:(PlayerIsLoggedIn(i) || GetCVar("doomware_unsafedb")), s:"\n"); break;
        case "__clientsync_player_datascore":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_points[i], s:"\n"); break;
        case "__clientsync_player_datawins":      for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_wins[i], s:"\n"); break;
        case "__clientsync_player_datadeaths":    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_deaths[i], s:"\n"); break;
        case "__clientsync_player_data1ups":      for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_1ups[i], s:"\n"); break;
        case "__clientsync_player_dataroles":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_role[i], s:"\n"); break;
        case "__clientsync_player_dataachieve":   for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_achieve[i], s:"\n"); break;
        case "__clientsync_player_databosskills": for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_bosskills[i], s:"\n"); break;
        case "__clientsync_player_checklost":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:Check_Player_Lost(i), s:"\n"); break;
        case "__clientsync_player_lostround":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:player_lostround[i], s:"\n"); break;
        case "__clientsync_player_viewingmenu":   for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:player_viewingmenu[i], s:"\n"); break;
        case "__clientsync_player_instruction1":  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction1[i], s:"\n"); break;
        case "__clientsync_player_instruction2":  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction2[i], s:"\n"); break;
        case "__clientsync_player_instruction3":  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction3[i], s:"\n"); break;
        case "__clientsync_player_viewsprite":    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:player_viewsprite[i], s:"\n"); break;
    }

	// Update the cvar if it changed
    if (StrCmp(GetCVarString(cvar), final))
        SetCVarString(cvar, final);
}

function int Unpack_CVar_Array(str cvar) // Retrieve the value of a Pack_Global_Array CVar and convert it to int.
{
    str data = GetCVarString(cvar);
    int datalen = StrLen(data);

    int start = 0;
    int linecount = 0;

    for (int i=0; i<datalen; i++)
    {
        if (GetChar(data, i) == '\n')
        {
            if (linecount == ConsolePlayerNumber())
            {
                data = StrMid(data, start, i-start);
                break;
            }
            else
            {
                start = i+1;
                linecount++;
            }

        }
    }
    return AToI(data);
}

function str Unpack_CVar_Array_String(str cvar) // Retrieve the value of a Pack_Global_Array CVar and convert it to string.
{
    str data = GetCVarString(cvar);
    int datalen = StrLen(data);

    int start = 0;
    int linecount = 0;

    for (int i=0; i<datalen; i++)
    {
        if (GetChar(data, i) == '\n')
        {
            if (linecount == ConsolePlayerNumber())
            {
                data = StrMid(data, start, i-start);
                break;
            }
            else
            {
                start = i+1;
                linecount++;
            }

        }
    }
    return data;
}


/*===================================================================================================
                                           Highscore table
===================================================================================================*/

// This is using a number rather than a named script to make binding the puke easier
Script 257 (void) NET // Highscore table bind
{
    // Start a solo match if the game hasn't started
    if (game_status == STATUS_NOTSTARTED && PlayerCount() == 1)
        game_solo = true;

    // Don't open the highscore table if it's a solo game or if not ready
    if (game_solo || game_status == STATUS_STARTING)
        terminate;

    // Toggle the scoreboard visibility
    if (player_viewingscore[PlayerNumber()] == false)
        player_viewingscore[PlayerNumber()] = true;
    else
        player_viewingscore[PlayerNumber()] = false;

    // Draw the scoreboard
    ACS_NamedExecuteAlways("DoomWare_Client_DrawHighscore", 0);
}

int lastteamscore[MAXTEAMS];
script "DoomWare_Server_CalcHighscore" (void) // A "thread" which continually updates the highscore table
{
	while (1)
	{
		int i, j;

		// Fill the highscore list with the players that are ingame
		for (i=0; i<MAXPLAYERS; i++)
		{
			game_highscores[i] = game_score[i];
			game_highnames[i] = i;

			if (PlayerInGame(i) == false)
			{
				game_highscores[i] = -1;
				game_highnames[i] = -1;
			}
		}

		// Order the list based on who has the highest score
		for (i=0; i<MAXPLAYERS; i++)
		{
			for (j=1; j<MAXPLAYERS-i; j++)
			{
				int temp_value;
				if (game_highscores[j-1] < game_highscores[j])
				{
					temp_value = game_highscores[j-1];
					game_highscores[j-1] = game_highscores[j];
					game_highscores[j] = temp_value;

					temp_value = game_highnames[j-1];
					game_highnames[j-1] = game_highnames[j];
					game_highnames[j] = temp_value;
				}
			}
		}
		
		// Update team scores
		game_scoreteams[TEAM_BLUE] = game_extrascoreteams[TEAM_BLUE];
		game_scoreteams[TEAM_RED] = game_extrascoreteams[TEAM_RED];
		if (game_teams)
		{    
			for (j=0; j<PlayerCount(); j++)
			{
				int team = GetPlayerInfo(game_highnames[j], PLAYERINFO_TEAM);
				game_scoreteams[team] += game_highscores[j];
			}
		}
		
		// If a player disconnected, fix the score (hacky, because we can't get player teams in DISCONNECT scripts)
		if (game_extrascoreteams[MAXTEAMS] != 0)
		{
			for (i=0; i<MAXTEAMS; i++)
			{
				if (lastteamscore[i] > game_scoreteams[i])
				{
					game_extrascoreteams[i] += game_extrascoreteams[MAXTEAMS];
					game_extrascoreteams[MAXTEAMS] = 0;
					break;
				}
			}
		}
		
		// Store the team's last score
		for (i=0; i<MAXTEAMS; i++)
			lastteamscore[i] = game_scoreteams[i];

		// Restart this script
		delay(1);
    }
}

Script "DoomWare_Client_DrawHighscore" (void) // Draws the highscore table for the activator
{
	str extrascore = "";
    int i;
    if (player_viewingscore[PlayerNumber()] == true)
    {
        int hud_y_counter = 0;
		bool hasextrascore = false;
		
		// Check extra team score
		for (i=0; i<MAXTEAMS; i++)
		{
			if (game_extrascoreteams[i] != 0)
			{
				str col = "";
				switch(i)
				{
					case TEAM_BLUE:
						col = "\chBlue: ";
						break;
					case TEAM_RED:
						col = "\cgRed: ";
						break;
				}
				extrascore = StrParam(s:extrascore, s:" ", s:col, d:game_extrascoreteams[i]);
				hasextrascore = true;
			}
		}
		
		// If we're displaying extra score and we've got a full game, move the names up a bit
		if (hasextrascore && PlayerCount() == MAXPLAYERS)
			hud_y_counter = -6;

        // Initialize the GUI
        SetHudSize(800, 600, false);

        // Draw the background
        SetFont("SCRBRDB");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_HSBACK, CR_ORANGE, 400.0, 300.0, 1);

        // Draw each player's score
        SetFont("DW_FONT3");
        for (i=0; i<MAXPLAYERS; i++)
        {
            // If the player is ingame
            if (game_highscores[i] != -1)
            {
                int color = CR_ORANGE;
                
                // Switch the color if the player is in a team
                switch (GetPlayerInfo(game_highnames[i], PLAYERINFO_TEAM))
                {
                    case TEAM_RED:
                        color = CR_RED;
                        break;
                    case TEAM_BLUE:
                        color = CR_BLUE;
                        break;
                }
                
                // Draw the person's name and move the y position lower
                HUDMessage(d:game_highscores[i], s:" ", n:game_highnames[i]+1; HUDMSG_PLAIN, MSGID_HSPLAYR+i, color, 400.0, 216.0+hud_y_counter, 1);
                hud_y_counter +=13.0;
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 200.0+hud_y_counter, 1);
        }
		
		// Draw extra team score
		if (hasextrascore)
			HUDMessage(s:"Extra score:", s:extrascore; HUDMSG_PLAIN, MSGID_HSPLAYR+MAXPLAYERS, CR_ORANGE, 400.0, 210.0+208.0, 1);
        SetHudSize(0, 0, false);

        // Restart the script to keep drawing the scoreboard
        delay(1);
        if (PlayerInGame(PlayerNumber())) // Unless the player disconnected
            restart;
    }
    else
    {
        // Overwrite the scoreboard with blank if it's not being viewed anymore
        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSBACK, CR_ORANGE, 0.5, 0.5, 1);
        for (i=0; i<MAXPLAYERS+1; i++)
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 200.0+hud_y_counter, 1);
    }
}


/*===================================================================================================
                                           Observer System
===================================================================================================*/

function void Add_Observer(int TID) // Adds a camera to the observers list
{
    if (!game_solo || (game_solo && round_forceobservers))
    {
        minigame_canobserve = true;
        for (int i=0; i<NUMOBSERVERS; i++)
            if (round_observers[i] == -1)
            {
                round_observers[i] = TID;
                break;
            }
    }
}

function void Force_Observe(int plynum) // Forces a player to observe a camera in the above list
{
    player_observe[PlayerNumber()]++;
    ChangeCamera(round_observers[0], 0, 0);
}

Script "DoomWare_Server_ClearObservers" (void) // Clears the observers list
{
    int i;

    // Disable minigame observation
    for (i=0; i<NUMOBSERVERS; i++)
        round_observers[i] = -1;
    minigame_canobserve = false;

    // Remove everyone's observation
    for (i=0; i<MAXPLAYERS; i++)
        player_observe[i] = 0;
    ChangeCamera(0, 1, 0);
}

Script 988 (void) NET // Observe minigame bind
{
    if (game_status > STATUS_STARTING)
    {
        if (minigame_canobserve == true && player_lostround[PlayerNumber()])
        {
            if (round_observers[player_observe[PlayerNumber()]] != -1)
            {
                player_observe[PlayerNumber()]++;
                ChangeCamera(round_observers[player_observe[PlayerNumber()]-1], 0, 0);
            }
            else
            {
                ChangeCamera(0, 0, 0);
                player_observe[PlayerNumber()] = 0;
            }
        }
    }
}


/*===================================================================================================
                                            DoomWare Menu
===================================================================================================*/

Script 999 (void) NET // Menu toggle bind
{
    // Toggle the scoreboard visibility
    if (player_viewingmenu[PlayerNumber()] == false)
    {
        player_viewingmenu[PlayerNumber()] = true;
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
    }
    else
    {
        player_viewingmenu[PlayerNumber()] = false;

        // Unfreeze the player (as long as the game lets them)
        if (!player_frozen[PlayerNumber()])
            SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
    }
}

Script "DoomWare_Client_DrawMenu" (void) CLIENTSIDE // Draws the DoomWare menu for the activator
{
    // Make sure only the person who called it actually opens the menu
    if (ConsolePlayerNumber() != PlayerNumber())
        terminate;

    SetActivator(TID_PLAYER+ConsolePlayerNumber());

    // Initialize a bunch of variables
    int i;
    int x = GetScreenWidth() / 2;
    int y = GetScreenHeight() / 2;
    int x_sensitivity = 1.0;
    int y_sensitivity = 1.0;
    int dx;
    int dy;
    int tab = 1;
    int plynum = ConsolePlayerNumber();
    bool menu_wasopen = false;
    
    // Initialize global top stats variables
    int topstat_wins = GetCVar("__clientsync_stats_t_wins");
    int topstat_score = GetCVar("__clientsync_stats_t_points");
    int topstat_1ups = GetCVar("__clientsync_stats_t_1ups");
    int topstat_deaths = GetCVar("__clientsync_stats_t_deaths");
    int topstat_bosskills = GetCVar("__clientsync_stats_t_bosses");
    int topstat_g_wins = GetCVar("__clientsync_stats_g_wins");
    int topstat_g_score = GetCVar("__clientsync_stats_g_points");
    int topstat_g_1ups = GetCVar("__clientsync_stats_g_1ups");
    int topstat_g_deaths = GetCVar("__clientsync_stats_g_deaths");
    int topstat_g_bosskills = GetCVar("__clientsync_stats_g_bosses");
    str topstat_n_wins = GetCVarString("__clientsync_stats_n_wins");
    str topstat_n_score = GetCVarString("__clientsync_stats_n_points");
    str topstat_n_1ups = GetCVarString("__clientsync_stats_n_1ups");
    str topstat_n_deaths = GetCVarString("__clientsync_stats_n_deaths");
    str topstat_n_bosskills = GetCVarString("__clientsync_stats_n_bosses");

    // Start the menu drawing loop
    while (1)
    {
        int menuopen = Unpack_CVar_Array("__clientsync_player_viewingmenu");
        if (menuopen == 1)
        {
            menu_wasopen = true;
            bool changedtab = false;
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            bool moving_mouse = true;

            if (GetUserCVar(plynum, "doomware_hudscale"))
            {
                w = 800;
                h = 600;
            }
            SetHUDSize(w, h, true);

            w = w << 16;
            h = h << 16;

            // Get input
            dx = FixedMul(x_sensitivity, GetPlayerInput(plynum, INPUT_YAW)) / 24;
            dy = FixedMul(y_sensitivity, GetPlayerInput(plynum, INPUT_PITCH)) / 12;
            if (dy == 0)
            {
                dy = -GetPlayerInput(plynum, INPUT_FORWARDMOVE) / 1200;
                moving_mouse = false;
            }

            // Move the mouse
            x -= dx;
            if (moving_mouse && !GetCVar("invertmouse"))
                y -= dy;
            else
                y += dy;

            // Prevent the mouse from escaping
            if (x < 0)
                x = 0;
            if (x > w>>16)
                x = w>>16;
            if (y < 0)
                y = 0;
            if (y > h>>16)
                y = h>>16;

            // Allow changing tabs
            if ((y <= (h/2-220.0)>>16 && y >= (h/2-240.0)>>16) && (x >= (w/2 - 318.00)>>16 && x <= (w/2 + 318.00)>>16))
            {
                int input = GetPlayerInput(plynum, INPUT_BUTTONS);
                int oldinput = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
                if (!(oldinput & (BT_USE|BT_ATTACK)) && (input & (BT_USE|BT_ATTACK)))
                {
                    int oldtab = tab;
                    tab = 1+((x-(((w/2)-318.0)>>16))/106);
                    if (tab != oldtab)
                    {
                        changedtab = true;
                        if (GetUserCVar(plynum, "doomware_hudsounds"))
                            AmbientSound("DoomWare/MenuTab", 127);
                    }

                    if (tab == 6)
                        RequestScriptPuke(999);
                }
            }

            // Draw the mouse
            SetFont("CURSOR");
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_CURSOR, CR_WHITE, (x<<16)+2.0+0.1, (y<<16)+2.0+0.1, 1);

            // Handle each tab
            switch(tab)
            {
                case 1:
                    SetFont("DW_FONT3");
                    HUDMessage(s:WELCOME; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2-322.0 + 0.1, h/2 + 28.0 + 0.1, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
                case 2:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"                                    ", s:CHANGES,
                        s:"\n\n\nCurrent number of minigames: ", d:NUMBEROFGAMES,
                        s:"\nCurrent number of tie breakers (1v1): ", d:NUMBEROFTIEBREAKERS,
                        s:"\nCurrent number of tie breakers (non 1v1): ", d:NUMBEROFTIEBREAKERSM,
                        s:"\nCurrent number of wackymods: ", d:NUMBEROFWACKYMODS;
                        HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2-312.0 + 0.1, h/2 - 200.0 + 0.1, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
                case 3:
                    SetFont("DW_FONT3");
                    int syncdata_loggedin = Unpack_CVar_Array("__clientsync_player_loggedin");
                    
                    // Print global and top stats
                    HUDMessage(s:"\ckGlobal Stats\c-\n\n",
                        s:"Games Played\n", d:topstat_g_wins,
                        s:"\n\nPoints Given\n", d:topstat_g_score,
                        s:"\n\n1-Ups Collected\n", d:topstat_g_1ups,
                        s:"\n\nTotal Deaths\n", d:topstat_g_deaths,
                        s:"\n\nBosses Defeated\n", d:topstat_g_bosskills,
                        s:"\n\n\n\ckThese stats update\n\ckon map start\c-"
                        ; HUDMSG_PLAIN, MSGID_MELEM+2, CR_WHITE, w/2-220.0 + 0.4, h/2 - 200.0 + 0.1, 1);
                    HUDMessage(s:"\ckTop Stats\c-\n\n",
                        s:"Game Wins\n", s:topstat_n_wins, s:" (", d:topstat_wins, s:")",
                        s:"\n\nPoints Received\n", s:topstat_n_score, s:" (", d:topstat_score, s:")",
                        s:"\n\n1-Ups Collected\n", s:topstat_n_1ups, s:" (", d:topstat_1ups, s:")",
                        s:"\n\nTotal Deaths\n", s:topstat_n_deaths, s:" (", d:topstat_deaths, s:")",
                        s:"\n\nBosses Defeated\n", s:topstat_n_bosskills, s:" (", d:topstat_bosskills, s:")",
                        s:"\n\n\n\ckThese stats update\n\ckon map start\c-"
                        ; HUDMSG_PLAIN, MSGID_MELEM+1, CR_WHITE, w/2+220.0 + 0.4, h/2 - 200.0 + 0.1, 1);
                    
                    // Display player stats based on whether they're logged in or not
                    if (syncdata_loggedin >= 1)
                    {
                        int syncdata_score = Unpack_CVar_Array("__clientsync_player_score");
                        int syncdata_totalpoints = Unpack_CVar_Array("__clientsync_player_datascore");
                        int syncdata_wins = Unpack_CVar_Array("__clientsync_player_datawins");
                        int syncdata_deaths = Unpack_CVar_Array("__clientsync_player_datadeaths");
                        int syncdata_1ups = Unpack_CVar_Array("__clientsync_player_data1ups");
                        int syncdata_role = Unpack_CVar_Array("__clientsync_player_dataroles");
                        int syncdata_achieve = Unpack_CVar_Array("__clientsync_player_dataachieve");
                        int syncdata_bosskills = Unpack_CVar_Array("__clientsync_player_databosskills");
                        str role;
                        switch (syncdata_role)
                        {
                            case ROLE_NONE:
                                role = "None";
                                break;
                            case ROLE_REGULAR:
                                role = "\cgVeteran\c-";
                                break;
                            case ROLE_ACHIEVER:
                                role = "\cnOver Achiever\c-";
                                break;
                            case ROLE_BETA:
                                role = "\cfBeta Tester\c-";
                                break;
                            case ROLE_BUU342:
                                role = "\cqG\csO\cdD";
                                break;
                        }
                        HUDMessage(s:"\ckYour Stats\c-\n\n",
                            s:"Game Wins\n", d:syncdata_wins,
                            s:"\n\nPoints Received\n", d:(syncdata_score + syncdata_totalpoints),
                            s:"\n\n1-Ups Collected\n", d:syncdata_1ups,
                            s:"\n\nTotal Deaths\n", d:syncdata_deaths,
                            s:"\n\nBosses Defeated\n", d:syncdata_bosskills,
                            s:"\n\nRank\n", s:role
                            ; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.4, h/2 - 200.0 + 0.1, 1);

                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_1WIN,       ACHIEVE_NAME_1WIN,       ACHIEVE_DESC_1WIN, "ACH_WINO", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_10WIN,      ACHIEVE_NAME_10WIN,      ACHIEVE_DESC_10WIN, "ACH_WINT", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_50WIN,      ACHIEVE_NAME_50WIN,      ACHIEVE_DESC_50WIN, "ACH_WINH", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_25POINTS,   ACHIEVE_NAME_25POINTS,   ACHIEVE_DESC_25POINTS, "ACH_25PN", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_1v1WIN,     ACHIEVE_NAME_1v1WIN,     ACHIEVE_DESC_1v1WIN, "ACH_1V1W", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_MVMWIN,     ACHIEVE_NAME_MVMWIN,     ACHIEVE_DESC_MVMWIN, "ACH_MVMW", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_501UPS,     ACHIEVE_NAME_501UPS,     ACHIEVE_DESC_501UPS, "ACH_1UPF", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_100DEATH,   ACHIEVE_NAME_100DEATH,   ACHIEVE_DESC_100DEATH, "ACH_DEDH", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_300POINTS,  ACHIEVE_NAME_300POINTS,  ACHIEVE_DESC_300POINTS, "ACH_300P", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_JUMP,       ACHIEVE_NAME_JUMP,       ACHIEVE_DESC_JUMP, "ACH_JUMP", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_LONGJUMP,   ACHIEVE_NAME_LONGJUMP,   ACHIEVE_DESC_LONGJUMP, "ACH_1UPS", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_3FRAGS,     ACHIEVE_NAME_3FRAGS,     ACHIEVE_DESC_3FRAGS, "ACH_3FRG", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BULLETHELL, ACHIEVE_NAME_BULLETHELL, ACHIEVE_DESC_BULLETHELL, "ACH_BULL", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_KARTWIN,    ACHIEVE_NAME_KARTWIN,    ACHIEVE_DESC_KARTWIN, "ACH_KART", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_ATST,       ACHIEVE_NAME_ATST,       ACHIEVE_DESC_ATST, "ACH_ATST", plynum, x, y, w, h);
						Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_WAIFU,      ACHIEVE_NAME_WAIFU,     ACHIEVE_DESC_WAIFU, "ACH_WAIF", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BOSS,       ACHIEVE_NAME_BOSS,       ACHIEVE_DESC_BOSS, "ACH_BOSS", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_FULLSERVER, ACHIEVE_NAME_FULLSERVER, ACHIEVE_DESC_FULLSERVER, "ACH_FULL", plynum, x, y, w, h);
                    }
                    else
                    {
                        HUDMessage(s:"\ckYour Stats\n\n", s:LOGIN; HUDMSG_PLAIN, MSGID_MELEM, CR_RED, w/2 + 0.4, h/2 - 200.0 + 0.1, 1);

                        // Clear unused elements
                        if (changedtab)
                            for (i=3; i<MELEMENTS; i++)
                                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    }
                    break;
                case 4:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"Click the switch to toggle the console command"; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.0, h/2 - 200.0 + 0.1, 1);
                    Handle_Menu_Option(0, "doomware_hudscale", "Force large HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(1, "doomware_hudwide", "Widescreen large HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(2, "doomware_hudsounds", "Allow the HUD to emit sound effects", plynum, x, y, w, h);
                    Handle_Menu_Option(3, "doomware_huddynamic", "Allow the HUD to move dynamically", plynum, x, y, w, h);
                    Handle_Menu_Option(4, "doomware_hudshowbinds", "Show your binds on the game HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(5, "doomware_loginwarn", "Warn you that you're not logged in", plynum, x, y, w, h);
                    Handle_Menu_Option(6, "doomware_music", "Enable DoomWare music (such as winning/losing)", plynum, x, y, w, h);
                    Handle_Menu_Option(7, "doomware_invertfly", "Invert Y axis on flight controls", plynum, x, y, w, h);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);

                    //Handle_Menu_Option(6, "doomware_joinmenu", "Open this menu upon connecting to a game", PlayerNumber(), x, y, w, h);
                    break;
                case 5:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"\cgA wad by \cqB\csu\cdu\cq3\cs4\cd2\c-\n\n",
                        s:"Based on the Nintendo game series WarioWare, all rights reserved\n",
                        s:"Credit for all used assets are provided within the wad's data\n\n",
                        s:"\cvPlease report any bugs you encounter to:\n",
                        s:"\cvbuu342@hotmail.com\n",
                        s:"\cvAlternatively, bugs can be reported on the Doomworld or Zandronum\n",
                        s:"\cvDoomWare thread.\n",
                        s:"\cvOr use the GitHub page!\n",
                        s:"https://github.com/buu342/ACS-DoomWare"; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.4, h/2 + 0.0, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
            }

            // Draw the background
            SetFont(StrParam(s:"MENU", d:tab));
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MENU, CR_WHITE, w/2+0.0, h/2+0.0, 1);
        }
        else
        {
            if (menu_wasopen)
            {
                for (i=0; i<MELEMENTS; i++)
                    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MENU, CR_WHITE, 0.0, 0.0, 0);
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CURSOR, CR_WHITE, 0.0, 0.0, 0);
                menu_wasopen = false;
                tab = 1;
            }
        }

        // Restart the script to keep drawing the menu
        delay(1);

        if (!PlayerInGame(plynum))
            terminate;
    }
}

function void Handle_Menu_Option(int number, str command, str desc, int plynum, int mouse_x, int mouse_y, int w, int h) // Handles drawing and clicking of menu options 
{
    int x = w/2-312.0 + 0.1;
    int y = h/2-180.0 + (number)*48.0 + 0.1;
    int oldbutton = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
    int button = GetPlayerInput(plynum, INPUT_BUTTONS);

    // Draw the button
    if (GetUserCVar(plynum, command))
        SetFont("SOTESCHY");
    else
        SetFont("SOTESCHN");
    HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MELEM+(number+1)*2, CR_WHITE, x, y, 1);
    SetFont("DW_FONT3");
    HUDMessage(s:command, s:"\n", s:desc; HUDMSG_PLAIN, MSGID_MELEM+1+(number+1)*2, CR_GOLD, x + 48.0, y + 5.0, 1);

    // Handle the button clicking
    if ((mouse_x >= x>>16 && mouse_x <= (x+32.0)>>16) && (mouse_y >= y>>16 && mouse_y <= (y+32.0)>>16)) // If the mouse is within the button's bounds
        if (!oldbutton & (BT_ATTACK|BT_USE) && button & (BT_ATTACK|BT_USE)) // If the player has pressed the button
        {
            // toggle the command
            SetUserCVar(plynum, command, !GetUserCVar(plynum, command));

            // Play a sound
            if (GetUserCVar(plynum, "doomware_hudsounds"))
                AmbientSound("DoomWare/MenuSwitch", 127);
        }
}

function void Handle_Menu_Achievement(int achieve_data, int number, str name, str desc, str sprite, int plynum, int mouse_x, int mouse_y, int w, int h) // Handles the drawing of the achievements
{
    int x = w/2-312.0 + (number%9)*70.0 + 0.1;
    int y = h/2+98.0 + (number/9)*70.0 + 0.1;
    int oldbutton = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
    int button = GetPlayerInput(plynum, INPUT_BUTTONS);
    int unlocked = achieve_data & (1<<(number));

    // Show the achievement sprite if unlocked
    if (unlocked)
        SetFont(sprite);
    else
        SetFont("ACH_NONE");
    HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MELEM+3+number*2, CR_WHITE, x, y, 1);
    SetFont("DW_FONT3");

    // Handle the button clicking
    if ((mouse_x >= x>>16 && mouse_x <= (x+64.0)>>16) && (mouse_y >= y>>16 && mouse_y <= (y+64.0)>>16)) // If the mouse is within the button's bounds
    {
        if (unlocked)
            HUDMessage(s:name, s:"\n", s:desc; HUDMSG_PLAIN, MSGID_MELEM+3+number*2+1, CR_GOLD, w/2 + 0.4, h/2+72.0, 1);
        else
            HUDMessage(s:"???", s:"\n", s:"This achievement is locked"; HUDMSG_PLAIN, MSGID_MELEM+3+number*2+1, CR_RED, w/2 + 0.4, h/2+72.0, 1);
    }
    else
    {
        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+3+number*2+1, CR_WHITE, w/2 + 0.0, h/2+64.0, 1);
    }
}


/*===================================================================================================
                                                Hats
===================================================================================================*/

#define BETATESTERSIZE 17
str BetaTesterList[BETATESTERSIZE];
function bool IsBetaTester(int plynum) // Returns true/false if the player is a beta tester
{
    BetaTesterList[0] = "asriel";
    BetaTesterList[1] = "margsabl";
    BetaTesterList[2] = "marcaek";
    BetaTesterList[3] = "doomer9000";
    BetaTesterList[4] = "deanyktru";
    BetaTesterList[5] = "dsparil";
    BetaTesterList[6] = "flambeau";
    BetaTesterList[7] = "dastan";
    BetaTesterList[8] = "combinebobnt";
	BetaTesterList[9] = "kaapeli47";
	BetaTesterList[10] = "metaldanny";
	BetaTesterList[11] = "oremex";
	BetaTesterList[12] = "danielcs";
	BetaTesterList[13] = "haispawner";
	BetaTesterList[14] = "daddykrabs";
	BetaTesterList[15] = "obspogon";
    BetaTesterList[16] = "bridgeburner";

    for (int i=0; i<BETATESTERSIZE; i++)
        if (!StrIcmp(BetaTesterList[i], GetPlayerAccountName(i)))
            return true;
    return false;
}

Script "DoomWare_Server_Hats" (void) // A "thread" that handles all the player hats
{
    int z;

    // If not a solo game, handle the leader hat and the crown hat
    if (!game_solo)
    {
        // Leader hat (if there is a leader and not a team game)
        if (!game_teams && game_highscores[0] > game_highscores[1] && game_status != STATUS_GAMEOVER && !(GetActorProperty(TID_PLAYER+0, APROP_Health) <= 0))
        {
            if (ThingCount(0, TID_HATGAME) == 0)
                SpawnSpotForced("LeaderHat", 1, TID_HATGAME, 0);

            z = 64.0;
            if (data_role[game_highnames[0]] > ROLE_NONE)
                z = 84.0;
            SetActorPosition(TID_HATGAME, GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0]), GetActorZ(TID_PLAYER+game_highnames[0])+z, 0);
            if (minigame_invisiblehats)
                SetActorProperty(TID_HATGAME, APROP_RenderStyle, STYLE_None);
            else
                SetActorProperty(TID_HATGAME, APROP_RenderStyle, STYLE_Normal);
        }
        else if (ThingCount(0, TID_HATGAME) > 0)
            Thing_Remove(TID_HATGAME);

        // Winner hat (at the end of the game)
        if (game_status == STATUS_GAMEOVER && game_over == OVER_WINNER)
        {
            if (ThingCount(0, TID_HATGAME+1) == 0)
                SpawnSpotForced("Crown", 1, TID_HATGAME+1, 0);

			// Correct the Z position if the player already has some hat
            z = 64.0;
            if (data_role[game_highnames[0]] > ROLE_NONE)
                z = 84.0;
            SetActorPosition(TID_HATGAME+1, GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0]), GetActorZ(TID_PLAYER+game_highnames[0])+z, 0);
        }
    }

    // Special Hats
    for (int i=0; i<MAXPLAYERS; i++)
    {
        // If the player left the game (or is dead), kill the hat
        if ((ThingCount(0, TID_HATROLE+i) > 0 && data_role[i] <= ROLE_NONE) || (GetActorProperty(TID_PLAYER+i, APROP_Health) <= 0) || (!PlayerInGame(i)))
            Thing_Remove(TID_HATROLE+i);

        // Check if the player logged in recently
        if (data_role[i] == ROLE_UNLOGGED && (PlayerIsLoggedIn(i) || GetCVar("doomware_unsafedb")))
		{
            Load_PlayerDB(i);

			// Give Buu342 his role if he doesn't have one
			if (StrCmp(GetPlayerAccountName(i), "buu342") == 0)
				data_role[i] = ROLE_BUU342;
				

			// Give a beta tester a role if they don't have one
			if (data_role[i] != ROLE_BETA && IsBetaTester(i))
				data_role[i] = ROLE_BETA;
		}

        // If they don't have a worthy role (or are dead), ignore them
        if (data_role[i] <= ROLE_NONE || (GetActorProperty(TID_PLAYER+i, APROP_Health) <= 0))
            continue;

		// Spawn the hat if it doesn't exist yet
		if (ThingCount(0, TID_HATROLE+i) == 0)
		{
			switch (data_role[i])
			{
				case ROLE_BUU342:
					SpawnSpotForced("Buu342Hat", 1, TID_HATROLE+i, 0);
					break;
				case ROLE_BETA:
					SpawnSpotForced("BetaHat", 1, TID_HATROLE+i, 0);
					break;
				case ROLE_ACHIEVER:
					SpawnSpotForced("AchieverHat", 1, TID_HATROLE+i, 0);
					break;
				case ROLE_REGULAR:
					SpawnSpotForced("RegularHat", 1, TID_HATROLE+i, 0);
					break;
			}
		}
		
		// Morph Buu342
		if (data_role[i] == ROLE_BUU342 && (game_status != STATUS_MINIGAME || (game_status == STATUS_MINIGAME && player_lostround[i])) && StrCmp(GetActorClass(TID_PLAYER+i), "Buu342Player") != 0)
			MorphActor(TID_PLAYER+i, "Buu342Player", 1, 0x7fffffff, MRF_NEWTIDBEHAVIOUR, "Nothing", "Nothing");

		// Update the hat position and visibility
		if (ThingCount(0, TID_HATROLE+i) != 0)
		{
			if (minigame_invisiblehats)
				SetActorProperty(TID_HATROLE+i, APROP_RenderStyle, STYLE_None);
			else
				SetActorProperty(TID_HATROLE+i, APROP_RenderStyle, STYLE_Normal);
			SetActorPosition(TID_HATROLE+i, GetActorX(TID_PLAYER+i), GetActorY(TID_PLAYER+i), GetActorZ(TID_PLAYER+i)+64.0, 0);
		}
    }

    // Restart the script
    delay(1);
    restart;
}


/*===================================================================================================
                                       Wacky Modifier Scripts
===================================================================================================*/

script "DoomWare_WackyMod_DoubleJump" (void)
{
    int counter = 0;

    // Execute while the player is ingame
    while (PlayerInGame(PlayerNumber()))
    {
        int lastzvel = GetActorVelZ(0);
        delay(1);

        // If the player is alive and can jump
        if (ClassifyActor(TID_PLAYER+PlayerNumber()) & ACTOR_ALIVE && GetActorProperty(TID_PLAYER+PlayerNumber(), APROP_JUMPZ) != 0.0)
        {
            // If the player pressed jump this frame
            if ((GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_JUMP) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_JUMP))
            {
                // Incrememnt the jump counter
                counter++;
                
                // Double jump if the counter is 2
                if (counter == 2)
                {
					ThrustThingZ(0, FixedMul(GetActorProperty(TID_PLAYER+PlayerNumber(), APROP_JumpZ), 5.0) >> 16, 0, 0);
                    SpawnSpotForced("GrenadeSmokeTrail", TID_PLAYER+PlayerNumber(), 0, 0);
                    PlaySound(TID_PLAYER+PlayerNumber(), "skeleton/swing");
                }
            } 
            else if (GetActorVelZ(0) == 0 && lastzvel == 0) // Otherwise, check they have no Z movement
                counter = 0;
        }
    }
}


/*===================================================================================================
                                              DECORATE
===================================================================================================*/

Script "DoomWare_Entity_MarkCleanup" (void) // Marks an entity for cleanup at round end. ACS so that I can use it in DECORATE
{
    Thing_ChangeTID(0, TID_REMOVE);
}

Script "DoomWare_Entity_CheckCleanup" (void) // In case it missed the first cleanup
{
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
        terminate;

    // Remove entities marked for deletion
    While (ThingCount(0, TID_REMOVE) > 0)
    {
        thing_remove(TID_REMOVE);
        delay(1);
    }
}


/*===================================================================================================
                                          Console Commands
===================================================================================================*/

Script "DoomWare_Console_ListPlayers" (void) // Lists all players in the server and their roles
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (playerInGame(i))
            HUDMessage(d:i, s:" - ", n:i+1; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
}

Script "DoomWare_Console_AssignRole" (int ply, int role) // Forcefully assigns a player a role
{
    data_role[ply] = role;
    HUDMessage(s:"Player ", n:ply+1, s:" was given role ", d:role; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
}

Script "DoomWare_Console_ForceEnd" (void) // Ends the current game
{
    game_over = OVER_FORCED;
}


/*===================================================================================================
                                            Miscellaneous
===================================================================================================*/

script "DoomWare_DoLightning" (void) // Halloween skybox lightning
{
    delay(random(SECOND*5, SECOND*15));
    ChangeSky("STSKY22", "");
    AmbientSound("world/thunder", 127);
    Light_ChangeToValue(256, 255);
    Light_ChangeToValue(23, 255);
    Light_ChangeToValue(24, 255);
    Light_ChangeToValue(44, 255);
    Light_ChangeToValue(2, 255);
    Light_ChangeToValue(19, 255);
    Light_ChangeToValue(17, 255);
    Light_ChangeToValue(256, 255);
    Light_ChangeToValue(20, 255);
    Light_ChangeToValue(20, 255);
    Light_ChangeToValue(21, 255);
    Light_ChangeToValue(22, 255);
    delay(5);
    ChangeSky("STSKY21", "");
    Light_ChangeToValue(256, 192);
    Light_ChangeToValue(23, 192);
    Light_ChangeToValue(24, 192);
    Light_ChangeToValue(44, 192);
    Light_ChangeToValue(2, 192);
    Light_ChangeToValue(19, 192);
    Light_ChangeToValue(17, 192);
    Light_ChangeToValue(256, 192);
    Light_ChangeToValue(20, 192);
    Light_ChangeToValue(20, 192);
    Light_ChangeToValue(21, 192);
    Light_ChangeToValue(22, 192);
    restart;
}

script "DoomWare_AchievementLog" (int plynum, int achievement) CLIENTSIDE // Log() doesn't work unless it's clientsided, thus this script...
{
    Log(n:plynum+1, s:" obtained the achievement \cv", s:achievement);
}

function int Calc_Speed(int xvel, int yvel) // Calculates an actor's speed from their X+Y velocity
{
    int vi = xvel >> 16;
    int vii = yvel >> 16;
    return vi*vi  + vii*vii;
}

function int Distance(int tid1, int tid2) // Calculates the distance between two actors
{
    int x, y, z, d;
    x = (GetActorX(tid1) - GetActorX(tid2)) >> 16;
    y = (GetActorY(tid1) - GetActorY(tid2)) >> 16;
    z = (GetActorZ(tid1) - GetActorZ(tid2)) >> 16;
    d = sqrt(x*x + y*y + z*z);
    return d;
}

Script "DoomWare_Entity_SetPlayerTranslation" (void) // Translate colors on morphed actors
{
    Thing_SetTranslation(TID_PLAYER+(ActivatorTID()-TID_EXTRA), -1);
    while (game_status != STATUS_WINLOSE)
        delay(1);
    thing_Remove(ActivatorTID());
}

function int Max(int a, int b) // Returns the largest number
{
    if (a > b)
        return a;
    return b;
}

function int Abs(int n) // Returns absolute value
{
	if (n < 0)
		return -n;
	return n;
}

function int AToI(str s) // Converts a string to an integer
{
    int start = 0;
    bool negative = false;
    int n = 0;
    int len = StrLen(s);
    
    // Check if there's a negative sign
    if (GetChar(s, 0) == '-')
    {
        negative = true;
        start++;
    }

    // Go through every character in the string
    for (int i=start; i<len; i++)
    {
        int char = GetChar(s, i);

        // Check that we are actually converting a number
        if (char < '0' || char > '9')
        {
            print(s:"ERROR, attempting to convert ", c:char, s:" to number!");
            continue;
        }

        // Add the number to our total
        n = n*10 + (char-'0');
    }

    if (negative)
        n = -n;

    return n;
}

function void SpawnSpotForcedEx(str classname, int spottid, int tid, int angle) // Spawn monsters with wacky modifiers
{
	str finalclass = classname;
	
	// Correct the monster name, if needed
	if (GetCVar("doomware_wackymodsmonsters"))
	{
		switch (game_wackymod)
		{
			case WACKYMOD_FLIGHT:
				finalclass = StrParam(s:finalclass, s:"_Flight");
				break;
			case WACKYMOD_RAGE:
				finalclass = StrParam(s:finalclass, s:"_Rage");
				break;
			case WACKYMOD_SPREAD:
				finalclass = StrParam(s:finalclass, s:"_Spread");
				break;
		}
	}
	
	// Spawn the monster
	SpawnSpotForced(finalclass, spottid, tid, angle);
	
	// Set other wackymods on the monster
	if (GetCVar("doomware_wackymodsmonsters"))
	{
		switch (game_wackymod)
		{
			case WACKYMOD_1HP:
				SetActorProperty(tid, APROP_Health, 1);
				break;
			case WACKYMOD_SPEED:
				SetActorProperty(tid, APROP_Speed, FixedMul(GetActorProperty(tid, APROP_Speed), 2.0));
				break;
		}
	}
}

function void SpawnSpotFacingForcedEx(str classname, int spottid, int tid) // Spawn monsters with wacky modifiers facing their spawn
{
	str finalclass = classname;
	
	// Correct the monster name, if needed
	if (GetCVar("doomware_wackymodsmonsters"))
	{
		switch (game_wackymod)
		{
			case WACKYMOD_FLIGHT:
				finalclass = StrParam(s:finalclass, s:"_Flight");
				break;
			case WACKYMOD_RAGE:
				finalclass = StrParam(s:finalclass, s:"_Rage");
				break;
			case WACKYMOD_SPREAD:
				finalclass = StrParam(s:finalclass, s:"_Spread");
				break;
		}
	}
	
	// Spawn the monster
	SpawnSpotFacingForced(finalclass, spottid, tid);
	
	// Set other wackymods on the monster
	if (GetCVar("doomware_wackymodsmonsters"))
	{
		switch (game_wackymod)
		{
			case WACKYMOD_1HP:
				SetActorProperty(tid, APROP_Health, 1);
				break;
			case WACKYMOD_SPEED:
				SetActorProperty(tid, APROP_Speed, FixedMul(GetActorProperty(tid, APROP_Speed), 2.0));
				break;
		}
	}	
}
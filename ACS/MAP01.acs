/*===========================================================================================================================================
    Welcome to DoomWare's ACS Code! This is where all the magic happens.
    After Beta 1.8, I went ahead and rewrote the entire core of the gamemode from scratch in an attempt to both make the code
    more stable, but more importantly to make it easier to read and modify. This has allowed me to add all sorts of new features
    really easily, as I didn't have to keep writing exceptions/rewriting entire blocks of code to implement new stuff.
	
	As of right now, the code can be a bit overwhelming and difficult to scroll through. This is because my workflow relies heavily on 
	Doom Builder's script editor, which doesn't allow for including ACS scripts. Therefore, it's all in one file until DoomWare is
	"officially" released. Enable code folding to make your life much less of a pain in the ass!

    DoomWare's Source Code should be pretty well commented, but if you want a better overview, or are interested in adding in more minigames,
    I highly recommend reading the Wiki on DoomWare's GitHub page!
    https://github.com/buu342/ACS-DoomWare/wiki

    Have fun!

    - Buu342
===========================================================================================================================================*/

#include "zcommon.acs"


/*===================================================================================================
                                           Definitions
===================================================================================================*/

// Don't Touch
#define SECOND 35 // Doom's internal tickrate
#define SAFETY "" // To prevent "BEGINNERS LUCK" from being the default text due to it being the first #define'd string


// Game selection

#define NUMBEROFGAMES        93 // Number Of minigames
#define NUMBEROFTIEBREAKERS  3  // Number Of 1v1 Tie Breakers
#define NUMBEROFTIEBREAKERSM 3  // Number Of Non-1v1 Tie Breakers
#define NUMBEROFWACKYMODS    10 // Number of wacky mods


// Debugging single minigames (-1 to not debug, provide a different number to force that minigame number to play)

#define DEBUG_GAME  -1
#define DEBUG_TIEB  -1
#define DEBUG_TIEBM -1
#define DEBUG_WACKY -1


// Game settings

#define MAXPLAYERS  16 // All minigames were designed with 16 players in mind! Change if you know what you're doing!
#define MAXTEAMS    2  // The maximum amount of teams. Changing this will require modifying quite a few if and switch statements!
#define MAXROUNDS   25 // How many rounds per game (Default 25)

#define BANNEDSOLOGAMES "11 26 40 42 69 83 85 87 88 90 93" // List of games banned during solo play


// Game Speedups

#define MAXSPEEDUPS 4 // How many times should the game speedup (Increase only if you know what you're doing!)

// Round number(s) to speedup in
#define SPEEDUP1 6  // default 6
#define SPEEDUP2 11 // default 11
#define SPEEDUP3 16 // default 16
#define SPEEDUP4 20 // default 20


// Game Status

#define STATUS_NOTSTARTED 0 // Waiting for players
#define STATUS_STARTING   1 // Game Initializing
#define STATUS_WACKYMOD   2 // Wacky modifier selection
#define STATUS_WAITING    3 // Waiting between minigames
#define STATUS_SPEEDUP    4 // The game is speeding up
#define STATUS_WINLOSE    5 // Announce the winners and losers
#define STATUS_MINIGAME   6 // We are playing a minigame
#define STATUS_GAMEOVER   7 // The game has ended
#define STATUS_TIEDETECT  8 // A tie has been detected
#define STATUS_TIEBREAK   9 // We are playing a tie breaker (1v1)
#define STATUS_TIEBREAKM 10 // We are playing a tie breaker (more than 1v1)


// Message ID's

#define MELEMENTS       48  // Number of reserved slots for menu elements

#define MSGID_CONSOLE   -1                        // Console only messages
#define MSGID_HSPLAYR   1                         // Highscore background
#define MSGID_HSBACK    2+MAXPLAYERS+1            // Highscore table player name (occupies MAXPLAYERS+1 numbers)
#define MSGID_CURSOR    3+MAXPLAYERS+1            // Menu Cursor
#define MSGID_MELEM     4+MAXPLAYERS+1            // Menu element (occopies 64 slots)
#define MSGID_MENU      5+MAXPLAYERS+1+MELEMENTS  // Menu background
#define MSGID_CENTER    6+MAXPLAYERS+1+MELEMENTS  // Centered messages (eg You Win!)
#define MSGID_CENTER2   7+MAXPLAYERS+1+MELEMENTS  // Centered messages below above (eg speedup hints)
#define MSGID_SCORE     8+MAXPLAYERS+1+MELEMENTS  // HUD Score background
#define MSGID_ROUND     9+MAXPLAYERS+1+MELEMENTS  // HUD Round background
#define MSGID_ROUND2    10+MAXPLAYERS+1+MELEMENTS // HUD Round counter
#define MSGID_LEADER    11+MAXPLAYERS+1+MELEMENTS // HUD Leader background
#define MSGID_SPREAD    12+MAXPLAYERS+1+MELEMENTS // HUD Spread
#define MSGID_LEADER2   13+MAXPLAYERS+1+MELEMENTS // HUD Leader name
#define MSGID_SCORE2    14+MAXPLAYERS+1+MELEMENTS // HUD score counter
#define MSGID_SCORE3    15+MAXPLAYERS+1+MELEMENTS // HUD score text
#define MSGID_ROUND3    16+MAXPLAYERS+1+MELEMENTS // HUD Round text
#define MSGID_VIEWHS    17+MAXPLAYERS+1+MELEMENTS // HUD Highscore reminder
#define MSGID_STFACE    18+MAXPLAYERS+1+MELEMENTS // STATUSBAR Face
#define MSGID_STBAR     19+MAXPLAYERS+1+MELEMENTS // STATUSBAR Extra
#define MSGID_TIMER     20+MAXPLAYERS+1+MELEMENTS // Timer on the HUD
#define MSGID_TIMER2    21+MAXPLAYERS+1+MELEMENTS // Timer on the HUD background
#define MSGID_CENTER3   22+MAXPLAYERS+1+MELEMENTS // Centered messages below CENTER2
#define MSGID_OBSERVE   23+MAXPLAYERS+1+MELEMENTS // Press # to observe this minigame
#define MSGID_MENUBIND  24+MAXPLAYERS+1+MELEMENTS // Press # to open the menu
#define MSGID_VIEWSP    25+MAXPLAYERS+1+MELEMENTS // View sprite
#define MSGID_WARNING   26+MAXPLAYERS+1+MELEMENTS // Warnings
#define MSGID_WACKYMOD  27+MAXPLAYERS+1+MELEMENTS // Wackymod reminder
#define MSGID_ACHIEVEM  28+MAXPLAYERS+1+MELEMENTS // Achievement notifications
#define MSGID_PLYHERE   29+MAXPLAYERS+1+MELEMENTS // You are Here


// Special TID's

#define TID_PLAYER    1337 // TID given to players (Occupies MAXPLAYERS amount of TID's)
#define TID_HATGAME   3337 // TID given to leader/winner hat (Occupies 2 TID's)
#define TID_EXTRA     4337 // TID given to extra objects during minigames (Occupies MAXPLAYERS amount of TID's)
#define TID_HATROLE   5337 // TID given to players with roles (Occupies MAXPLAYERS amount of TID's)
#define TID_AVOID     6337 // TID given to the AVOID object
#define TID_REMOVE    7337 // TID given to objects to be removed after a minigame ended


// Game Over Reasons

#define OVER_NONE       -1 // Game is not over
#define OVER_WINNER     0  // Because someone won
#define OVER_PLAYER     1  // Because of a lack of players
#define OVER_FORCED     2  // Because it was forced to end
#define OVER_JOIN       3  // Because someone joined during a solo game
#define OVER_WINNERSOLO 4  // Someone won during a solo game
#define OVER_WINNERRED  5  // Red team won
#define OVER_WINNERBLUE 6  // Blue team won


// Player Roles

#define ROLE_UNLOGGED   -1 // Player is not logged in
#define ROLE_NONE       0  // No role
#define ROLE_REGULAR    1  // Someone who played this game wayyyyy too much
#define ROLE_BETA       2  // Someone special <3
#define ROLE_BUU342     3  // The God himself
#define ROLE_ACHIEVER   4  // Someone who has unlocked all the achievements


// Music Durations (only change if you changed the sounds)

#define MUSICDUR_WAIT1 (SECOND*4)
#define MUSICDUR_WAIT2 (SECOND*3 + 25)
#define MUSICDUR_WAIT3 (SECOND*3 + 10)
#define MUSICDUR_WAIT4 (SECOND*2 + 30)
#define MUSICDUR_WAIT5 (SECOND*2 + 20)

#define MUSICDUR_SPEEDUP1 (SECOND*7 + 10)
#define MUSICDUR_SPEEDUP2 (SECOND*6 + 25)
#define MUSICDUR_SPEEDUP3 (SECOND*6)
#define MUSICDUR_SPEEDUP4 (SECOND*5 + 15)

#define MUSICDUR_WINLOSE (SECOND + 32)

#define MUSICDUR_GAMEOVER (SECOND*7)
#define MUSICDUR_TIEBREAK (SECOND*4 + 9)


// Achievements

#define ACHIEVE_ID_1WIN        0
#define ACHIEVE_ID_10WIN       1
#define ACHIEVE_ID_50WIN       2
#define ACHIEVE_ID_25POINTS    3
#define ACHIEVE_ID_1v1WIN      4
#define ACHIEVE_ID_MVMWIN      5
#define ACHIEVE_ID_501UPS      6
#define ACHIEVE_ID_100DEATH    7
#define ACHIEVE_ID_300POINTS   8
#define ACHIEVE_ID_WRONGDOOR   9
#define ACHIEVE_ID_LONGJUMP    10
#define ACHIEVE_ID_3FRAGS      11
#define ACHIEVE_ID_BULLETHELL  12
#define ACHIEVE_ID_KARTWIN     13
#define ACHIEVE_ID_ATST        14
#define ACHIEVE_ID_BOSS        15
#define ACHIEVE_ID_BADAIM      16
#define ACHIEVE_ID_FULLSERVER  17

#define ACHIEVE_NAME_1WIN        "Beginners Luck"
#define ACHIEVE_NAME_10WIN       "Just getting warmed up!"
#define ACHIEVE_NAME_50WIN       "Bingo Bango Bongo Bish Bash Bosh"
#define ACHIEVE_NAME_25POINTS    "Hoarder"
#define ACHIEVE_NAME_1v1WIN      "Fastest Gun in the West"
#define ACHIEVE_NAME_MVMWIN      "Darwinism"
#define ACHIEVE_NAME_501UPS      "Poor Kids in Africa Could Have Eaten Those"
#define ACHIEVE_NAME_100DEATH    "The Final Frontier"
#define ACHIEVE_NAME_300POINTS   "DoomWare veteran"
#define ACHIEVE_NAME_WRONGDOOR   "Colorblind"
#define ACHIEVE_NAME_LONGJUMP    "Mike Powell"
#define ACHIEVE_NAME_3FRAGS      "Point Man"
#define ACHIEVE_NAME_BULLETHELL  "Mushihimesama"
#define ACHIEVE_NAME_KARTWIN     "Tokyo Drifter"
#define ACHIEVE_NAME_ATST        "Dash Rendar"
#define ACHIEVE_NAME_BOSS        "Too Strong"
#define ACHIEVE_NAME_BADAIM      "Bad Aim"
#define ACHIEVE_NAME_FULLSERVER  "House party"

#define ACHIEVE_DESC_1WIN        "Win a single game"
#define ACHIEVE_DESC_10WIN       "Win 10 games"
#define ACHIEVE_DESC_50WIN       "Win 50 games"
#define ACHIEVE_DESC_25POINTS    "Finish a game with 25 points or more"
#define ACHIEVE_DESC_1v1WIN      "Win a 1v1 tiebreaker match"
#define ACHIEVE_DESC_MVMWIN      "Be the sole survivor of a non-1v1 tiebreaker match"
#define ACHIEVE_DESC_501UPS      "Collect 50 1-ups"
#define ACHIEVE_DESC_100DEATH    "Die 100 times"
#define ACHIEVE_DESC_300POINTS   "Earn a total of 300 points"
#define ACHIEVE_DESC_WRONGDOOR   "Enter the wrong door"
#define ACHIEVE_DESC_LONGJUMP    "Get the 1-Up in the sonic minigame"
#define ACHIEVE_DESC_3FRAGS      "Frag 3 players in a deathmatch minigame"
#define ACHIEVE_DESC_BULLETHELL  "Survive the bullet hell minigame"
#define ACHIEVE_DESC_KARTWIN     "Finish first in a kart race"
#define ACHIEVE_DESC_ATST        "Destroy an AT-ST"
#define ACHIEVE_DESC_BOSS        "Defeated the final boss"
#define ACHIEVE_DESC_BADAIM      "Hurt the imp in the apple minigame"
#define ACHIEVE_DESC_FULLSERVER  "Play on a full server"


// Wacky modifiers

#define WACKYMOD_NONE    0
#define WACKYMOD_BOSS    1
#define WACKYMOD_JUMP    2
#define WACKYMOD_FLIGHT  3
#define WACKYMOD_1HP     4
#define WACKYMOD_SPEED   5
#define WACKYMOD_INVERT  6
#define WACKYMOD_T1UPS   7
#define WACKYMOD_SPEEDUP 8
#define WACKYMOD_SPREAD  9
#define WACKYMOD_RAGE    10

#define WACKYMOD_NAME1  "Boss Round"
#define WACKYMOD_NAME2  "Double Jump"
#define WACKYMOD_NAME3  "Flight"
#define WACKYMOD_NAME4  "1 Health"
#define WACKYMOD_NAME5  "Sonic Speed"
#define WACKYMOD_NAME6  "Inverted Controls"
#define WACKYMOD_NAME7  "1Ups are worth Triple"
#define WACKYMOD_NAME8  "Max Game Speed"
#define WACKYMOD_NAME9  "Bullet Spread"
#define WACKYMOD_NAME10 "Double Fire Rate"


// Map Skins

#define MAPSKIN_NONE      0
#define MAPSKIN_HALLOWEEN 1
#define MAPSKIN_CHRISTMAS 2


// Miscellaneous

#define NUMOBSERVERS    8  // Size of the observers array. Increase if you need more.
#define TIMER_OFF       -1 // Not using the timer
#define TIMER_EARLY     -2 // Timer ended early


// Menu Text

#define WELCOME "\
Welcome to DoomWare, a fast paced competitive minigame wad. Every few seconds you are\n\
thrown into a new minigame with variying different goals. The longer you play, the\n\
faster and harder the game gets...\n\n\
Before you get started, make sure you have mouselook and jump bound, as you're going\n\
to need them. Also, make sure you have DoomWare specific binds setup as well (you\n\
should see them in 'DoomWare Settings->DoomWare Controls' in your ESC menu). You\n\
can alternatively bind them manually via '+dwscores' (highscore), '+dwobserve'\n\
(observation) and '+dwmenu' (this menu).\n\n\
You can navigate this menu either using your movement keys or mouse, and you can select\n\
buttons via your USE or ATTACK key. You can close this menu via your menu button.\n\n\
If you are having trouble reading this or any other text due to a large resolution, you\n\
can force HUD scaling in the options tab of this menu, DoomWare options in the ESC menu,\n\
or via the console command 'doomware_hudscale'.\n\n\
Good luck, and have fun!\
"

// Login Menu Text

#define LOGIN "You are not logged in.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
You must have an account at www.auth.zandronum.com, and then login by opening the\n\
console and typing in 'login username password'. If you do not login, your stats and\n\
achievemnts will not be tracked.\
"


// Game changelog

#define CHANGES "\
Version Beta 1.9675C\n\
What's new in the Beta?\n\n\
+ Added 'Survive (Rockets)' and 'Charge your Laz0r' to solo banlist\n\
+ Added Runescape blood splat\n\
+ Added two new wacky modifiers\n\
+ Added two new minigames to replace two merged games\n\
* Allowed 1v1 tiebreaker games in team games with 2 players\n\
* Buffed turkey slightly and fixed sound cutoff\n\
* Changed basketballs to rip through players\n\
* Color coded projectiles in team games\n\
* Fixed a bug where activators would get changed mid script\n\
* Fixed choose a side minigame not counting middle people\n\
* Fixed choose a side minigame not inverting controls\n\
* Fixed long-standing spelling mistake\n\
* Fixed random number hint not generating properly\n\
* Fixed wrong teleport TID on Bit Trip game\n\
* Gave Falcon Punch more forward momentum\n\
* Improved Boss battle string code\n\
* Made the explosive barrels shorter in Bit Trip arena\n\
* Made Flame objects' sound last longer\n\
* Made Flanders minigame not forcibly end\n\
- Removed aim lock from pushing stick\n\
- Removed team marker sprite\n\
"


/*===================================================================================================
                                        Global Variables
===================================================================================================*/

bool player_wonround[MAXPLAYERS];       // (Internal) Players put here have won the round (usually denoted by the green particle effect)
bool player_lostround[MAXPLAYERS];      // (Internal) Players in here have lost the round (usually denoted by the red particle effect)
bool player_midround[MAXPLAYERS];       // (Internal) All players are put in here at the start of each round.
bool player_viewingscore[MAXPLAYERS];   // (Internal) List of players looking at the highscore table
bool player_viewingmenu[MAXPLAYERS];    // (Internal) List of players looking at the DoomWare Menu
bool player_musicwaiting[MAXPLAYERS];   // (Internal) List of whether players are hearing the waiting/speedup music
bool player_musicwinlose[MAXPLAYERS];   // (Internal) List of whether players are hearing the win/lose music
bool player_musicgameover[MAXPLAYERS];  // (Internal) List of whether players are hearing the game over music
int  player_observe[MAXPLAYERS];        // (Internal) List of what camera players are observing
bool player_frozen[MAXPLAYERS];         // (Internal) List of what players have APROP_TOTALLYFROZEN
bool player_haswackyscript[MAXPLAYERS]; // (Internal) List of what players that have a wackymod script running
int  player_position[MAXPLAYERS][3];    // (Internal) List player's XYZ pos before a minigame starts
int  player_teleporter[MAXPLAYERS];     // (Internal) Helper array to keep track of randomized player spawns
int  player_frags[MAXPLAYERS];          // (Internal) List of each player's frags
str  player_viewsprite[MAXPLAYERS];     // List of player's view sprite (like in the clean your weapon minigame)
int  player_answer1[MAXPLAYERS];        // Variables for minigame stuff (like keeping track of laps in Kart races)
int  player_answer2[MAXPLAYERS][4];     // Variables for minigame stuff (like keeping track of cacodemon answers)

int  game_score[MAXPLAYERS];           // (Internal) The score of each PlayerNumber()
int  game_scoreteams[MAXTEAMS];        // (Internal) The score of each team
int  game_extrascoreteams[MAXTEAMS+1]; // (Internal) The extra score of each team (team members that disconnected)
int  game_highscores[MAXPLAYERS];      // (Internal) The global highscore table sorted by winner first
int  game_highnames[MAXPLAYERS];       // (Internal) The global highscore table of player names sorted by winner first
int  game_roundnum;                    // (Internal) A number containing the current round.
int  game_status;                      // (Internal) A number containing the status of the gamemode's logic.
int  game_speed;                       // (Internal) How fast is the game going
int  game_over;                        // (Internal) The reason the game ended
bool game_solo;                        // (Internal) Is someone playing alone?
int  game_wackymod;                    // (Internal) Wacky Modifier
int  game_skin;                        // (Internal) Map seasonal skin
bool game_teams;                       // (Internal) Whether a team game is happening

int  round_current[MAXROUNDS];      // (Internal) An array containing a list of all minigames to be played/that have been played
str  round_hints[MAXSPEEDUPS];      // (Internal) An array containing a list of all hints to be/that have been displayed.
bool round_winifmid;                // Allow a player to win if he is in the midround array (like in games where you don't do anything to win)
bool round_winifsuicide;            // Pass the player if he killed himself
int  round_noforceend;              // Prevent the game from ending prematurely (unless everyone lost). Useful so people can collect 1ups.
int  round_tiebreaker;              // (Internal) The number value of the tiebreaker round are we playing
bool round_is1vmtiebreaker;			// (Internal) Are we playing a 1VM Tiebreaker round?
int  round_observers[NUMOBSERVERS]; // (Internal) An array containing all the possible observer TID's
bool round_forceobservers;          // Does this round need observers to work? Only used for game_solo.

int  minigame_wincondition1;            // A generic global variable for minigames
int  minigame_wincondition2;            // A generic global variable for minigames
int  minigame_wincondition3;            // A generic global variable for minigames
int  minigame_timer;                    // (Internal) A timer that is displayed during the minigame
bool minigame_canmove;                  // (Internal) Used to signal that players can move in tiebreaker rounds
bool minigame_canobserve;               // (Internal) Can this minigame be observed?
bool minigame_fragpoints;               // Can you get points for frags?
bool minigame_invisiblehats;            // Should this minigame hide the player hats?
str  minigame_instruction1[MAXPLAYERS]; // Center text during minigame
str  minigame_instruction2[MAXPLAYERS]; // Center text below center text during minigame
str  minigame_instruction3[MAXPLAYERS]; // Center text below center text below center text during minigame

int data_points[MAXPLAYERS];    // (Internal) List of points each player has received in total
int data_wins[MAXPLAYERS];      // (Internal) List of wins each player has achieved in total
int data_deaths[MAXPLAYERS];    // (Internal) List of deaths each player suffered in total
int data_1ups[MAXPLAYERS];      // (Internal) List of 1Ups each player got in total
int data_role[MAXPLAYERS];      // (Internal) List of each player's role
int data_achieve[MAXPLAYERS];   // (Internal) Bit field each player's achievements
int data_bosskills[MAXPLAYERS]; // (Internal) List of each player's boss kills


/*===================================================================================================
                                DoomWare Server Logic Initialization
===================================================================================================*/

script "DoomWare_Server_Boot" OPEN // Called when the map starts. Waits for players to join
{
    // Initialize some global variables
    game_status = STATUS_NOTSTARTED;
    game_solo = false;
    game_wackymod = WACKYMOD_NONE;
    
    // Figure out the map skin
    if (!strcmp(GetCVarString("doomware_mode"), "halloween") || (GetCVar("doomware_automode") && GetTimeProperty(SystemTime(), TM_MONTH) == 9))
        game_skin = MAPSKIN_HALLOWEEN;
    else if (!strcmp(GetCVarString("doomware_mode"), "christmas") || (GetCVar("doomware_automode") && GetTimeProperty(SystemTime(), TM_MONTH) == 11))
        game_skin = MAPSKIN_CHRISTMAS;
    else
        game_skin = MAPSKIN_NONE;

    // Some nice elevator music
    if (game_skin == MAPSKIN_HALLOWEEN)
        SetMusic("D_WAIT2");
    else if (game_skin == MAPSKIN_CHRISTMAS)
        SetMusic("D_WAIT3");
    else
        SetMusic("D_WAIT");

    // Create a "thread" that continually updates the hats and handles the database
    ACS_NamedExecute("DoomWare_Server_Hats", 0);

    // Clean up all the globals
    ACS_NamedExecute("DoomWare_Server_InitGlobals", 0);

    // Create a "thread" to syncronize global variables for CLIENTSIDE scripts
    ACS_NamedExecute("DoomWare_Server_SyncGlobals", 0);

    // Initialize the map
    ACS_NamedExecute("DoomWare_Server_InitMap", 0);

    // Wait until we have enough players
    while (PlayerCount() < 2 && !game_solo)
        Delay(1);

    // Stop the music and mark the game's start
    game_status = STATUS_STARTING;
    SetMusic("");
    
    // Check if a team game is happening
    game_teams = ((GetTeamProperty(TEAM_BLUE, TPROP_NumPlayers) + GetTeamProperty(TEAM_BLUE, TPROP_NumPlayers)) > 0 && !game_solo);

    // Initialize the game's serverside logic
    ACS_NamedExecute("DoomWare_Server_Initialize", 0);
}

Script "DoomWare_Server_Initialize" (void) // Initializes the rest of the gamemode and creates "threads"
{
    // Initialize the hints
    ACS_NamedExecute("DoomWare_Server_InitHints", 0);

    // Select which games will be played from the collection
    ACS_NamedExecute("DoomWare_Server_InitRounds", 0);

    // Initialize the highscore table
    ACS_NamedExecute("DoomWare_Server_InitHighscores", 0);

    // Wipe the Observers array
    ACS_NamedExecute("DoomWare_Server_ClearObservers", 0);
    
    // Wait a bit so everyone knows the game is starting
    minigame_timer = GetCVar("doomware_gamestarttime")*SECOND; // Used for the HUD  timer
    while (minigame_timer > 0)
    {
        minigame_timer--;
        delay(1);
    }
    
    // Initialize wacky modifiers
    if (GetCVar("doomware_wackymods") && !game_solo)
        ACS_NamedExecuteWait("DoomWare_Server_InitWackymods", 0);

    // Create a "thread" that continually updates the highscores
    ACS_NamedExecute("DoomWare_Server_CalcHighscore", 0);

    // Create a "thread" that controls the game logic
    ACS_NamedExecute("DoomWare_Server_GameLogic", 0);
}

Script "DoomWare_Server_InitMap" (void) // Initializes the map
{
	int i;	
    Sector_SetCurrent(160, 300, 192, false);

    CreateTranslation(1, 168:191=112:127, 32:47=120:127, 16:31=112:119, 160:167=112:120);
    CreateTranslation(2, 168:191=96:111, 32:47=107:111, 16:31=102:106, 160:167=107:107);
    CreateTranslation(3, 168:191=192:207, 32:47=202:207, 16:31=198:203, 160:167=201:203);
    CreateTranslation(4, 168:191=80:95, 32:47=90:95, 16:31=86:92, 160:167=90:90);
    CreateTranslation(5, 168:191=208:223, 32:47=64:79, 16:31=48:63, 160:167=67:69);
    CreateTranslation(6, 96:111=112:127);
    CreateTranslation(10, 96:111=112:127);

    CreateTranslation(11, 112:127=80:95);
    CreateTranslation(12, 112:127=64:79);
    CreateTranslation(13, 112:127=199:207);
    CreateTranslation(14, 112:127=5:8);
    CreateTranslation(15, 112:127=176:191);
	CreateTranslation(16, 64:79=[50,50,50]:[0,0,0]); // Black Imp (Void)
	CreateTranslation(17, 64:79=80:95); // White Imp (Void)

    // Rotating spikes arena fog
    Sector_SetFade(150, 255, 106, 0);
    Sector_SetFade(151, 255, 106, 0);
    Sector_SetFade(152, 255, 106, 0);
    Sector_SetFade(153, 255, 106, 0);
    Sector_SetFade(154, 255, 106, 0);
    Sector_SetFade(155, 255, 106, 0);
    Sector_SetFade(156, 255, 106, 0);
    Sector_SetFade(157, 255, 106, 0);
    Sector_SetFade(158, 255, 106, 0);

    // Air is lava fog
    Sector_SetFade(148, 255, 128, 0);
    Sector_SetFade(149, 255, 128, 0);
    Sector_SetFade(253, 255, 128, 0);

    Thing_SetTranslation(326, 1);
    Thing_SetTranslation(327, 2);
    Thing_SetTranslation(329, 3);
    Thing_SetTranslation(330, 4);
    Thing_SetTranslation(331, 5);
    Thing_SetTranslation (108, 10);
    
	// VOID Map
	Scroll_Ceiling(956, 0, 64, 0); // A for loop doesn't work???
	Scroll_Ceiling(957, 0, 64, 0);
	Scroll_Ceiling(958, 0, 64, 0);
	Scroll_Ceiling(959, 0, 64, 0);
	Scroll_Ceiling(960, 0, 64, 0);
	Scroll_Ceiling(961, 0, 64, 0);
	Scroll_Ceiling(967, 32, -32, 0);
	Scroll_Ceiling(968, -32, -32, 0);
	Scroll_Ceiling(969, -32, 32, 0);
	Scroll_Ceiling(970, 32, 32, 0);
	Floor_Waggle(965, 32, 64, 32, 0);
	Ceiling_Waggle(937, 32, 64, 64, 0);
	Floor_Waggle(977, 32, 64, 32, 0);
	delay(10);
	Ceiling_Waggle(938, 32, 64, 64, 0);
	delay(10);
	Ceiling_Waggle(939, 32, 64, 64, 0);
	delay(10);
	Ceiling_Waggle(962, 32, 64, 64, 0);

    Ceiling_Waggle(109, 32, 64, 0, 0);
    Floor_Waggle(133, 32, 64, 0, 0);
    Floor_Waggle(254, 256, 24, 0, 0);

    Scroll_Floor(3, 300, 2, 240);
    Scroll_Ceiling(3, 300, 2, 90);
    Scroll_Ceiling(202, 100, 2, 90);
    Sector_SetColor(4, 255, 105, 0, 0);
    Sector_SetColor(5, 0, 0, 255, 0);
    Sector_SetColor(29, 0, 255, 0, 0);
    Sector_SetColor(43, 36, 146, 219, 0);
    Sector_SetDamage(29, 99999, MOD_SLIME);
    Sector_SetDamage(4, 99999, mod_lava);
    Sector_SetDamage(41, 99999, MOD_FALLING);
    Sector_SetFriction(11, 30);
    Sector_SetGravity(18, 0, 50);
    Sector_SetGravity(206, 0, 75);
    Ceiling_CrushAndRaise(179, 64, 100, 1);

    // Pyoro level gravity
    for (i=0; i<15; i++)
        Sector_SetGravity(222+i, 10, 0);

    Scroll_Floor(140, -64, 0, 2);
    Scroll_Floor(141, -55, -32, 2);
    Scroll_Floor(142, -32, -55, 2);
    Scroll_Floor(143, 0, -64, 2);
    Scroll_Floor(144, 32, -55, 2);
    Scroll_Floor(145, 55, -32, 2);
    Scroll_Floor(187, 64, 0, 2);
    Scroll_Floor(188, 55, 32, 2);
    Scroll_Floor(189, 32, 55, 2);
    Scroll_Floor(190, 0, 64, 2);
    Scroll_Floor(191, -32, 55, 2);
    Scroll_Floor(192, -55, 32, 2);

    thing_activate(22);
    thing_activate(37);
    thing_activate(67);
    SetActorState(577, "Deactivated");

    // Delay for the rotating spikes in event 119
    delay(SECOND/2);
    thing_activate(69);

    // Delay for the crushers in event 116
    Ceiling_CrushAndRaise(180, 64, 100, 1);
    delay(4);
    Ceiling_CrushAndRaise(181, 64, 100, 1);
    delay(4);
    Ceiling_CrushAndRaise(182, 64, 100, 1);
    
    // Bouncy arena walls
    if (GetCVar("doomware_bouncywalls"))
    {
        SetLineSpecial(255, 226, 255, 0, 255, 64);
        SetLineSpecial(254, 226, 255, 0, 254, 128);
        SetLineSpecial(253, 226, 255, 0, 253, 192);
        SetLineSpecial(252, 226, 255, 0, 252, 0);
    }
    
    // Red OpenGL lights
    SpawnSpotForced("RedPoint", 88, TID_REMOVE, 0.0);
    Thing_remove(88);
    Thing_ChangeTID(TID_REMOVE, 88);
        
    // Apply arena seasonal themes
    if (game_skin == MAPSKIN_HALLOWEEN)
    {
        SpawnSpotForced("OrangeTorch", 838, 0, 0);
        Thing_remove(838);
        SpawnSpotForced("OrangePoint", 147, TID_REMOVE, 0.0);
        Thing_remove(147);
        Thing_ChangeTID(TID_REMOVE, 147);
        ChangeSky("STSKY21", "");
        ChangeFloor(253, "WFLAVA1");
        ChangeFloor(256, "WFLAVA1");
        ChangeFloor(839, "FLATHLWN");
        ChangeFloor(856, "FLATHLWN");
        ChangeFloor(22, "TLITE6_8");
        ChangeFloor(693, "TLITE6_8");
        SetLineTexture(89, SIDE_BACK, TEXTURE_BOTTOM , "N_BRGR16");
        ACS_NamedExecute("DoomWare_DoLightning", 0);
    }
    else if (game_skin == MAPSKIN_CHRISTMAS)
    {
        SpawnSpotForced("WhiteTorch", 838, 0, 0);
        Thing_remove(838);
        SpawnSpotForced("WhitePoint", 147, TID_REMOVE, 0.0);
        Thing_remove(147);
        Thing_ChangeTID(TID_REMOVE, 147);
        ChangeSky("STSKY23", "");
        ChangeFloor(253, "SNOW");
        ChangeFloor(256, "SNOW");
        ChangeFloor(839, "FLATCHRS");
        ChangeFloor(856, "FLATCHRS");
        ChangeFloor(22, "TLITE6_9");
        ChangeFloor(693, "TLITE6_9");
        SetLineTexture(89, SIDE_BACK, TEXTURE_BOTTOM , "N_BRGR17");
        Light_ChangeToValue(256, 255);
        for (i=3; i<=10; i++)
        {
            SpawnSpotForced("SnowDropper", i, TID_REMOVE, 0);
            SetActorPosition(TID_REMOVE, GetActorX(TID_REMOVE), GetActorY(TID_REMOVE), GetActorZ(TID_REMOVE)+100.0, false);
            Thing_ChangeTID(TID_REMOVE, 0);
        }
    }
    else
    {
        SpawnSpotForced("BluePoint", 147, TID_REMOVE, 0.0);
        Thing_remove(147);
        Thing_ChangeTID(TID_REMOVE, 147);
    }
}

#define NUMBEROFHINTS 91
str temp_hint[NUMBEROFHINTS];
Script "DoomWare_Server_InitHints" (void) // Initializes the list of hints to display during speedup
{
    temp_hint[0]  = "This WAD was created by \cqB\csU\cdU\cq3\cs4\cd2\c-, he has a skull over his head.";
    temp_hint[1]  = "Sunglasses are an important accessory for reducing damage from the Sun.";
    temp_hint[2]  = "Can't access the scoreboard? Change the bind in the options (at the very bottom) or bind +dwscores.";
    temp_hint[3]  = "OpenGL > Software";
    temp_hint[4]  = "If this is your first time playing DoomWare, I am so sorry for you.";
    temp_hint[5]  = "Some of these hints are useless.";
    temp_hint[6]  = "This WAD has over 10000 lines of ACS Code, and 6000 of Decorate.";
    temp_hint[7]  = "There is a 1UP mushroom hidden in many minigames.";
    temp_hint[8]  = "1UP Mushrooms give you an extra point. Grab them!";
    temp_hint[9]  = "I've included the ZDaemon source code in this WAD.";
    temp_hint[10] = "The throwback minigames have anatomically correct HUDs made with ACS.";
    temp_hint[11] = "Dash Rendar > Han Solo";
    temp_hint[12] = "I probably have more hours in the RAGE Mod Toolkit than anyone has in the base game...";
    temp_hint[13] = "Anyone who recognizes most of the music is super cool.";
    temp_hint[14] = "This WAD was inspired by WarioWare, duh.";
    temp_hint[15] = "I think it's time to blow this scene, get everybody and the stuff together.";
    temp_hint[16] = "I don't remember hurting any priest... lately... that much...";
    temp_hint[17] = "This WAD is a celebration of video games and everything I love, including other Doom WADs.";
    temp_hint[18] = "If I were a vegetable, I would be a couch potato.";
    temp_hint[19] = "Fast reactions and adaptability are the only way of surviving this next round.";
    temp_hint[20] = StrParam(s:"There are currently ",d:NUMBEROFGAMES, s:" minigames in this WAD.");
    temp_hint[21] = "I am extremely thankful to some people for coming and testing this WAD so often. Love you guys <3";
    temp_hint[22] = "I tend to make spelling mistaeks.";
    temp_hint[23] = "Diddy Kong Racing's final boss is literally impossible.";
    temp_hint[24] = "This WAD should have free custom skins that you can change in the options.";
    temp_hint[25] = "Chasecam should be enabled in the server. Use it!";
    temp_hint[26] = "If at first you don't succeed, try and try a gun.";
    temp_hint[27] = "The only way to win is to be an asshole to the lead players. If you're the lead, oh dear...";
    temp_hint[28] = "Dumbledore kills Snape.";
    temp_hint[29] = "Spoiler, after round 25 the game says 'Game Over'.";
    temp_hint[30] = "Griffith did nothing wrong.";
    temp_hint[31] = "When the game speeds up it gets both faster and harder.";
    temp_hint[32] = "Wanna make suggestions for new minigames? Get in touch, or open an issue on GitHub!";
    temp_hint[33] = "Coming Soon: Complex DoomWare vs Ghouls vs Megaman vs Unholy bosses - Push + Jumpmaze edition.";
    temp_hint[34] = "This WAD encourages and rewards suicide, sometimes.";
    temp_hint[35] = "This WAD contains memes older than the average internet user.";
    temp_hint[36] = "Hissy Hogging was an inside job.";
    temp_hint[37] = "Press your jump button to jump.";
    temp_hint[38] = "I bet you can't spell Diarrhea.";
    temp_hint[39] = "If you can't read the scoreboard, stop playing Doom on an iPod. No one uses 320x200.";
    temp_hint[40] = "Watch those wrist rockets.";
    temp_hint[41] = "Boo!";
    temp_hint[42] = "Please don't sue me for using some music. You wouldn't hurt a pregnant man.";
    temp_hint[43] = "The Falador Massacre is a myth perpetrated by King Roald.";
    temp_hint[44] = "'0/5, bad map' - Anonymous @ doomworld.com/idgames";
    temp_hint[45] = "Fat people aren't real.";
    temp_hint[46] = "The racist jokes in this WAD are not racist.";
    temp_hint[47] = "Buying Girlfriend for 10k.";
    temp_hint[48] = "Need buddy to finish Shield of Arrav quest :(";
    temp_hint[49] = "Your ad here.";
    temp_hint[50] = "You lost the game.";
    temp_hint[51] = "Hey can I have a quote in your Doom thingy? - CougarMagnum";
    temp_hint[52] = "This WAD is ad free because no one likes headaches, just like Nurofen, eliminating them with ease!";
    temp_hint[53] = "A group of baboons is called a council.";
    temp_hint[54] = "Please stop asking me for feet pics, Jennifer.";
    temp_hint[55] = "This WAD may be sold to Korean gangsters.";
    temp_hint[56] = "Doom 3 is fun.";
    temp_hint[57] = "Still trying to figure out why the Major was a cyborg.";
    temp_hint[58] = "I finished Super Sonic Doom with a score of 2,282,450.";
    temp_hint[59] = "I beat Dark Souls 1 and 2.";
    temp_hint[60] = "Keikaku means plan.";
    temp_hint[61] = "*insert movie reference here*";
    temp_hint[62] = "Achievement Get!";
    temp_hint[63] = "ALL THESE SQUARES MAKE A CIRCLE.";
    temp_hint[64] = "I am hilarious and you will quote everything I say.";
    temp_hint[65] = "Some games have custom taunts. Use them!";
    temp_hint[66] = "Holding strafe and forward at the same time makes you move faster than just pressing forward.";
    temp_hint[67] = "Linguica is a Portuguese word so his keyboard is in Portuguese. Shut up and deal with it.";
    temp_hint[68] = "I am never detailing a keyboard ever again...";
    temp_hint[69] = "If you see this message, press F10 and Enter for a free point.";
    temp_hint[70] = "Alderaan shot first.";
    temp_hint[71] = "The 'reach the end' Shadows of the Empire minigame uses 32 polyobjects.";
    temp_hint[72] = "It only took me 8 years to finish Spacechem.";
    temp_hint[73] = "The player in first place has a rainbow icon above him. Go ruin his day.";
    temp_hint[74] = "So what do you think of Chubbs's man-boobies?";
    temp_hint[75] = "Died during a round? Press O to observe others playing, or bind +dwobserve.";
    temp_hint[76] = "One of my favorite shapes is the Great disnub dirhombidodecahedron.";
    temp_hint[77] = "Featuring Dante from the Devil May Cry series.";
    temp_hint[78] = "Players wearing Party Hats are wonderful beta testers :>";
    temp_hint[79] = "Players with a pink heart over their heads have played too much Doomware.";
    temp_hint[79] = "Players with a blue heart over their heads Unlocked all achievements. Wow!";
    temp_hint[80] = "You can scale the HUD using the DoomWare Menu, or the console command doomware_hudscale.";
    temp_hint[81] = "This WAD contains Berserk references.";
    temp_hint[82] = "You were always such a kidder, Steve.";
    temp_hint[83] = "There are hidden SOMEMONG's in inaccessible areas.";
    temp_hint[84] = "I want to paint my house in FIREBLU.";
    temp_hint[85] = StrParam(s:"Today's random number is: ", d:random(0xFFFFFFFF, 0x7FFFFFFF)); // Maximum negative and positive integer
    temp_hint[86] = "This WAD contains war crimes, domestic abuse, and taxes.";
    temp_hint[87] = "Chameleon Machine. Ride on now!";
    temp_hint[88] = "It's ok, Marphy Black isn't here, he can't hurt you.";
    temp_hint[89] = "I tried to sneak through the door man! Can't make it, can't make it, the shit's stuck!";
    temp_hint[90] = "I seem to be wounded, but I can keep going";
    
    // Shuffle the array of hints
    int i, j, k;
    for (i=0; i<NUMBEROFHINTS; i++)
    {
        j = random(i, NUMBEROFHINTS-1);
        k = temp_hint[i];
        temp_hint[i] = temp_hint[j];
        temp_hint[j] = k;
    }

    // Pick the first few hints
    for (i=0; i<MAXSPEEDUPS; i++)
        round_hints[i] = temp_hint[i];
}

bool temp_bannedrounds[NUMBEROFGAMES];
int temp_allrounds[NUMBEROFGAMES];
Script "DoomWare_Server_InitRounds" (void) // Initializes the list of minigames to play
{
    int i, j, k;
    int bancount = 0;
    int totalrounds = 0;
    game_roundnum = 1;
    game_speed = 0;
    game_over = OVER_NONE;
        
    // Initialize the banned games array
    for (i=0; i<NUMBEROFGAMES; i++)
        temp_bannedrounds[i] = false;

    // Get the banned minigames list
    if (GetCVarString("doomware_banlist") != "" || game_solo)
    {
        str banlist = GetCVarString("doomware_banlist");
        int strs = 0;
        int strl = 0;
        
        // If we're in solo play, ban deathmatch levels
        if (game_solo && StrCmp(BANNEDSOLOGAMES, ""))
            banlist = StrParam(s:banlist, s:" ", s:BANNEDSOLOGAMES);
        strl = StrLen(banlist);
            
        // Read the cvar and get the banlist
        for (i=0; i<strl; i++)
        {
            // If we found a space or reached EOL
            if (GetChar(banlist, i) == ' ' || i+1 == strl)
            {
                // If we're at EOL, increment i so that the math checks ount
                if (i+1 == strl)
                    i++;
                    
                // Get the minigame number from the string and increment our counters
                temp_bannedrounds[AToI(StrMid(banlist, strs, i-strs))-1] = true;
                bancount++;
                strs = i+1;
            }
        }
    }
    
    // If we banned too many games, ignore the ban list
    if (bancount >= NUMBEROFGAMES)
    {
        bancount = 0;
        for (i=0; i<NUMBEROFGAMES; i++)
            temp_bannedrounds[i] = false;
    }
        
    // Create a temporary array with all the rounds that aren't banned
    for (i=0; i<NUMBEROFGAMES; i++)
        if (!temp_bannedrounds[i])
            temp_allrounds[totalrounds++] = i+1;
    
    // If we have enough rounds to not have repeats
    if (!GetCVar("doomware_duplicates") && NUMBEROFGAMES-bancount >= MAXROUNDS)
    {
        // Shuffle the temp array
        for (i=0; i<totalrounds; i++)
        {
            j = random(i, totalrounds-1);
            k = temp_allrounds[i];
            temp_allrounds[i] = temp_allrounds[j];
            temp_allrounds[j] = k;
        }

        // Now copy the first MAXROUNDS elements onto our rounds array
        for (i=0; i<MAXROUNDS; i++)
            round_current[i] = temp_allrounds[i];
    }
    else 
    {
        // Otherwise just pick a bunch of games at random
        for (i=0; i<MAXROUNDS; i++)
            round_current[i] = temp_allrounds[random(0, totalrounds-1)];
    }
}

Script "DoomWare_Server_InitHighscores" (void) // Initializes the highscore table
{
    int i;
    for (i=0; i<MAXPLAYERS; i++)
    {
        game_highscores[i] = -1;
        game_highnames[i] = -1;
        game_score[i] = 0;
    }
}

Script "DoomWare_Server_InitGlobals" (void) // Initializes all the global variables
{
    for (int i=0; i< MAXPLAYERS; i++)
    {
        game_score[i] = 0;
        data_points[i] = 0;
        data_wins[i] = 0;
        data_deaths[i] = 0;
        data_1ups[i] = 0;
        data_role[i] = 0;
        data_achieve[i] = 0;
        data_bosskills[i] = 0;
        player_lostround[i] = 0;
        player_viewingmenu[i] = 0;
        minigame_instruction1[i] = "";
        minigame_instruction2[i] = "";
        minigame_instruction3[i] = "";
        player_viewsprite[i] = "";
        player_wonround[i] = false;
        player_midround[i] = false;
        player_lostround[i] = false;
    }

    SetCVar("__clientsync_round", 0);
    SetCVar("__clientsync_gamestatus", 0);
    SetCVar("__clientsync_gameover", 0);
    SetCVar("__clientsync_minigametimer", 0);
    SetCVar("__clientsync_highscore1", 0);
    SetCVar("__clientsync_highscore2", 0);
    SetCVar("__clientsync_canobserve", 0);
    SetCVar("__clientsync_canmove", 0);
    SetCVar("__clientsync_gamesolo", 0);
    SetCVar("__clientsync_wincondition1", 0);
    SetCVar("__clientsync_roundcurrent", 0);
    SetCVar("__clientsync_wackymod", 0);
    SetCVarString("__clientsync_highname", "");
    SetCVarString("__clientsync_speeduphint", "");

    SetCVarString("__clientsync_player_score", "");
    SetCVarString("__clientsync_player_loggedin", "");
    SetCVarString("__clientsync_player_datascore", "");
    SetCVarString("__clientsync_player_datawins", "");
    SetCVarString("__clientsync_player_datadeaths", "");
    SetCVarString("__clientsync_player_data1ups", "");
    SetCVarString("__clientsync_player_dataroles", "");
    SetCVarString("__clientsync_player_dataachieve", "");
    SetCVarString("__clientsync_player_databosskills", "");
    SetCVarString("__clientsync_player_checklost", "");
    SetCVarString("__clientsync_player_lostround", "");
    SetCVarString("__clientsync_player_viewingmenu", "");
    SetCVarString("__clientsync_player_instruction1", "");
    SetCVarString("__clientsync_player_instruction2", "");
    SetCVarString("__clientsync_player_instruction3", "");
    SetCVarString("__clientsync_player_viewsprite", "");
    
    // Get global stat data
    DB_NetworkStats("Wins", "wins");
    DB_NetworkStats("Points", "points");
    DB_NetworkStats("1Ups", "1ups");
    DB_NetworkStats("Deaths", "deaths");
    DB_NetworkStats("BossKills", "bosses");
}

Script "DoomWare_Server_InitWackymods" (void) // Initializes the wacky modifiers
{
    int wackymod = random(0, GetCVar("doomware_wackymodschance"));
    if (wackymod == 0 || DEBUG_WACKY != -1)
    {
        // Pick a wackymod at random
        if (DEBUG_WACKY == -1)
        {
            if (GetCVar("doomware_bossfight") && !game_teams)
                game_wackymod = 1+random(0, NUMBEROFWACKYMODS-1);
            else
                game_wackymod = 2+random(0, NUMBEROFWACKYMODS-2);
        }
        else
            game_wackymod = DEBUG_WACKY;
        game_status = STATUS_WACKYMOD;
        delay(SECOND*5);
        
        // If we got the max game speed modifier, then set the game speed
        if (game_wackymod == WACKYMOD_SPEEDUP)
            game_speed = 4;
        
        // If we got the boss fight, then change level
        if (game_wackymod == WACKYMOD_BOSS)
            ChangeLevel("MAP30", 0, 0, 0);
    }
}

int linealpha[4];
Script 255 (int lineid, int angle) // Arena wall bumping
{
    int linealpha_max = 75;
    int linealpha_speed = 5;
    int lineslot = 255-lineid;
    
    // Push the player
    ThrustThing(angle, 8);
    
    // If there's no other script running
    if (linealpha[lineslot] == 0)
    {
        // Change the line to FIREBLU
        linealpha[lineslot] = linealpha_max;
        setlinetexture(lineid, SIDE_FRONT, TEXTURE_MIDDLE, "FIREBLU1");
        setlinetexture(lineid, SIDE_BACK, TEXTURE_MIDDLE, "FIREBLU1");
        
        // Decrease the line alpha over time
        while (linealpha[lineslot] > 0)
        {
            linealpha[lineslot] = linealpha[lineslot]-linealpha_speed;
            TranslucentLine(lineid, linealpha[lineslot], 0);
            delay(1);
        }
        
        // Remove the texture entirely
        setlinetexture(lineid, SIDE_FRONT, TEXTURE_MIDDLE, "-");
        setlinetexture(lineid, SIDE_BACK, TEXTURE_MIDDLE, "-");    
        linealpha[lineslot] = 0;
    }
    else
        linealpha[lineslot] = linealpha_max;
}


/*===================================================================================================
                                DoomWare Client Logic Initialization
===================================================================================================*/

script "DoomWare_Client_Join" ENTER // Called when a player joins. Initializes the player and creates "threads"
{
    // Initialize the player's variables
    ACS_NamedExecuteAlways("DoomWare_Client_Initialize", 0);

    // Notify about what's new
    HUDMessage(s:CHANGES; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 10.0, 10.0, 0.1);

    // Start the HUD "thread"
    ACS_NamedExecuteAlways("DoomWare_Client_DrawHUD", 0);
    ACS_NamedExecuteAlways("DoomWare_Client_DrawMenu", 0);

    // Wait until we have enough players
    while (game_status == STATUS_NOTSTARTED || game_status == STATUS_STARTING)
        delay(1);

    // Start the main clientside logic "thread"
    ACS_NamedExecuteAlways("DoomWare_Client_GameLogic", 0);
}

Script "DoomWare_Client_Initialize" (void) // Initializes variables related to the player
{
    // Wipe the player's Inventory and score
    clearinventory();
    game_score[PlayerNumber()] = 0;

    // Assign each player a TID, starting at 1337
    Thing_ChangeTID(0, TID_PLAYER+PlayerNumber());

    // Clean up the database and variables for this player
    data_deaths[PlayerNumber()] = 0;
    data_1ups[PlayerNumber()] = 0;
    player_wonround[PlayerNumber()] = false;
    minigame_instruction1[PlayerNumber()] = "";
    minigame_instruction2[PlayerNumber()] = "";
    minigame_instruction3[PlayerNumber()] = "";
    player_viewsprite[PlayerNumber()] = "";
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
    {
        player_wonround[PlayerNumber()] = false;
        player_midround[PlayerNumber()] = false;
        player_lostround[PlayerNumber()] = true;
    }
    else
    {
        player_midround[PlayerNumber()] = true;
        player_lostround[PlayerNumber()] = false;
    }

    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_ACHIEVEM, CR_CYAN, 0, 0, 1.0);


    // Check the player's role or warn if they're not logged in
    if (!GetCVar("doomware_unsafedb") && playerIsLoggedIn(PlayerNumber()))
        Load_PlayerDB(PlayerNumber());
    else
        data_role[PlayerNumber()] = ROLE_UNLOGGED;

    // If the server is full, give the achievement
    if (PlayerCount() == MAXPLAYERS)
        for (int i=0; i<MAXPLAYERS; i++)
            Give_Achievement(i, ACHIEVE_ID_FULLSERVER);

    // Fail the player for this round if they joined late
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
        Player_Lose(PlayerNumber(), true);
}


/*===================================================================================================
                                     DoomWare Server Main Logic
===================================================================================================*/

Script "DoomWare_Server_GameLogic" (void) // Main game logic "thread"
{
    // Initialize some global variables
    int i;
    round_winifmid = false;
    round_winifsuicide = false;
    round_noforceend = false;
    round_forceobservers = false;
	round_is1vmtiebreaker = false;
    minigame_wincondition1 = 0;
    minigame_wincondition2 = 0;
    minigame_wincondition3 = 0;
    minigame_fragpoints = false;
    minigame_invisiblehats = false;
    minigame_timer = TIMER_OFF;
    for (i=0; i<MAXPLAYERS; i++)
    {
        player_midround[i] = PlayerInGame(i);
        player_wonround[i] = false;
        player_lostround[i] = false;
        Player_InvalidatePosition(i);
    }

    // Stop the game if a solo match has more than one person
    if (game_solo && PlayerCount() > 1)
        game_over = OVER_JOIN;

    // Stop the game if a non solo match has only one person
    if (PlayerCount() < 2 && !game_solo)
        game_over = OVER_PLAYER;

    // Check if the game's over
    if (game_roundnum > MAXROUNDS || game_over != OVER_NONE)
    {
        game_speed = 0;

        // Check for ties
        if (Should_TieBreak())
        {
            game_status = STATUS_TIEDETECT;
            HUDMessage(s:"Tie!"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
            delay(MUSICDUR_TIEBREAK);
            game_status = STATUS_WAITING;
        }
        else
        {
            // Figure out the game over reason if it doesn't exist yet
            if (game_over == OVER_NONE)
            {
                // If we're using teams
                if (game_teams)
                {
                    // Pick the winning team (TODO: expand this to work with more teams using a loop)
                    if (game_scoreteams[TEAM_RED] > game_scoreteams[TEAM_BLUE])
                        game_over = OVER_WINNERRED;
                    else
                        game_over = OVER_WINNERBLUE;
                }
                else
                {
                    // Pick if we have a solo winner
                    if (!game_solo)
                        game_over = OVER_WINNER;
                    else
                        game_over = OVER_WINNERSOLO;
                }
            }

            // Print game over and the score tally
            game_status = STATUS_GAMEOVER;
            HUDMessage(s:"Game Over"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
            if (game_teams && !game_solo)
            {
                str printscore = "Final score tally:";
                
                // Iterate through all players to construct the string
                for (i=0; i<PlayerCount(); i++)
                {
                    printscore = StrParam(s:printscore, s:"\n");
                    
                    // Print player info, based on their team
                    switch (GetPlayerInfo(game_highnames[i], PLAYERINFO_TEAM))
                    {
                        case TEAM_RED:
                            printscore = StrParam(s:printscore, s:"\cgTEAM RED: ");
                            break;
                        case TEAM_BLUE:
                            printscore = StrParam(s:printscore, s:"\chTEAM BLUE: ");
                            break;
                        default:
                            break;
                    }
                    printscore = StrParam(s:printscore, d:game_highscores[i], s:" - ", n:game_highnames[i]+1);
                }
                HUDMessage(s:printscore; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
            }

            // Wait for the music to finish, then update the databases and restart the level
            delay(MUSICDUR_GAMEOVER);
            ACS_NamedExecute("DoomWare_Server_UpdateDB", 0);
            NamedScriptWait("DoomWare_Server_UpdateDB");
            ChangeLevel("map01", 0, 0, 0);
        }
    }

    // Wait a bit to play the round starting music (or warn that the game is speeding up)
    if (Should_Speedup() == true && game_roundnum <= MAXROUNDS)
    {
        game_speed++;
        game_status = STATUS_SPEEDUP;
        switch (game_roundnum)
        {
            case SPEEDUP1: delay(MUSICDUR_SPEEDUP1); break;
            case SPEEDUP2: delay(MUSICDUR_SPEEDUP2); break;
            case SPEEDUP3: delay(MUSICDUR_SPEEDUP3); break;
            case SPEEDUP4: delay(MUSICDUR_SPEEDUP4); break;
        }
    }
    else
    {
        game_status = STATUS_WAITING;

        // Calculate a tiebreaker beforehand to help lagging players
		if (game_roundnum > MAXROUNDS)
		{
			if (Is_1v1_TieBreaker())
			{
				if (DEBUG_TIEB > 0)
					round_tiebreaker = DEBUG_TIEB;
				else
					round_tiebreaker = random(1, NUMBEROFTIEBREAKERS);
			}
			else
			{
				if (DEBUG_TIEBM > 0)
					round_tiebreaker = DEBUG_TIEBM;
				else
					round_tiebreaker = random(1, NUMBEROFTIEBREAKERSM);
				round_is1vmtiebreaker = true;
			}
		}

        // Wait until the music is done playing
        switch (game_speed)
        {
            case 0: delay(MUSICDUR_WAIT1); break;
            case 1: delay(MUSICDUR_WAIT2); break;
            case 2: delay(MUSICDUR_WAIT3); break;
            case 3: delay(MUSICDUR_WAIT4); break;
            case 4: delay(MUSICDUR_WAIT5); break;
        }
    }

    // If not a tiebreaker
    str gametoplay;
    if (game_roundnum <= MAXROUNDS)
    {
        // Select the minigame to play
        game_status = STATUS_MINIGAME;
        if (DEBUG_GAME > 0)
            round_current[game_roundnum-1] = DEBUG_GAME;
        gametoplay = StrParam(s:"DoomWare_Server_Minigame", d:round_current[game_roundnum-1]);
    }
    else
    {
        minigame_canmove = false;

        if (Is_1v1_TieBreaker())
        {
            game_status = STATUS_TIEBREAK;
            gametoplay = StrParam(s:"DoomWare_Server_TieBreaker", d:round_tiebreaker);
        }
        else
        {
            game_status = STATUS_TIEBREAKM;
            gametoplay = StrParam(s:"DoomWare_Server_TieBreakerM", d:round_tiebreaker);
        }
        
        // Auto fail anyone who isn't in first place
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (game_score[i] != game_highscores[0])
            {
                player_lostround[i] = true;
                player_midround[i] = false;
            }
        }
    }
    ACS_NamedExecute(gametoplay, 0);

    // Wait until the minigame is over
    NamedScriptWait(gametoplay);

    // Stop any music
    SetMusic("");

    // Cleanup entities marked for death and clear the observers array
    ACS_NamedExecute("DoomWare_Entity_Cleanup", 0);
    ACS_NamedExecute("DoomWare_Server_ClearObservers", 0);

    // Announce the winners
    game_status = STATUS_WINLOSE;
    delay(MUSICDUR_WINLOSE-(7*game_speed));
    game_roundnum++;

    // Restart this script
    restart;
}

Script "DoomWare_Server_GameWait" (int time) // Sets a minigame timer
{
    int time_passed;
    minigame_timer = time;
    while (time_passed < time)
    {
        delay(1);
        time_passed++;
        minigame_timer--;

        // Stop if everyone has already passed/died
        if (No_MidRound_Array() && !round_noforceend)
        {
            if (time - time_passed < SECOND)
                delay(time - time_passed);
            else
            {
                minigame_timer = TIMER_EARLY;
                delay(SECOND);
            }
            break;
        }
    }
    minigame_timer = TIMER_OFF;
}

Script "DoomWare_Server_TeleportPlayers" (int tid, int telesector, int fog) // Teleports all players to an arena
{
    int i;
    
    // Randomize the destinations if we're not using telesector
    if (telesector == 0)
    {
        for (i=0; i<MAXPLAYERS; i++)
            player_teleporter[i] = tid+i;

        int j, k;
        for (i=0; i<MAXPLAYERS; i++)
        {
            j = random(i, MAXPLAYERS-1);
            k = player_teleporter[i];
            player_teleporter[i] = player_teleporter[j];
            player_teleporter[j] = k;
        }
    }

    // Teleport everyone
    for (i=0; i<MAXPLAYERS; i++)
    {
        // Don't bother if the player doesn't exist or they're not tied for first place (during a tiebreaker round)
        if (!PlayerInGame(i) || (game_status == STATUS_TIEBREAKM && !game_teams && game_score[i] != game_highscores[0]))
            continue;

        // Get the player's position
        Player_SavePosition(i);

        // Teleport them
        if (!telesector)
        {
            Thing_Move(TID_PLAYER+i, player_teleporter[i], !fog); // Move to an individual TID
        }
        else
        {
            TeleportInSector(2, 1, tid, fog, TID_PLAYER+i);  // Move them using a single TID
            TeleportInSector(17, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(19, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(20, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(21, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(22, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(23, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(24, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(25, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(39, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(44, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(691, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(692, 1, tid, fog, TID_PLAYER+i);
            TeleportInSector(693, 1, tid, fog, TID_PLAYER+i);
        }
    }

    // Reduce everyone's speed and fix their angles
    delay(1);
    if (fog)
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            // Don't bother if the player doesn't exist or they're not tied for first place
            if (!PlayerInGame(i) || (game_status == STATUS_TIEBREAKM && game_score[i] != game_highscores[0]))
                continue;

            SetActorPitch(TID_PLAYER+i, 0.0);
            if (telesector)
                SetActorAngle(TID_PLAYER+i, GetActorAngle(tid));
            else
                SetActorAngle(TID_PLAYER+i, GetActorAngle(player_teleporter[i]));
            SetActorVelocity(TID_PLAYER+i, 0.0, 0.0, 0.0, false, false);
        }
    }

    // Retry for anyone who was not teleported due to telefragging prevention
    for (i=0; i<MAXPLAYERS; i++)
    {
        // Don't bother if the player doesn't exist or they're not tied for first place
        if (!PlayerInGame(i) || (game_status == STATUS_TIEBREAKM && game_score[i] != game_highscores[0]))
            continue;

        while (Distance(TID_PLAYER+i, 1) < 512 && game_status == STATUS_MINIGAME)
        {
            if (!telesector)
            {
                Thing_Move(TID_PLAYER+i, player_teleporter[i], !fog); // Move to an individual TID
            }
            else
            {
                TeleportInSector(2, 1, tid, fog, TID_PLAYER+i);  // Move them using a single TID
                TeleportInSector(17, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(19, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(20, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(21, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(22, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(23, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(24, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(25, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(39, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(44, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(691, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(692, 1, tid, fog, TID_PLAYER+i);
                TeleportInSector(693, 1, tid, fog, TID_PLAYER+i);
            }
            delay(1);

            if (fog)
            {
                SetActorPitch(TID_PLAYER+i, 0.0);
                if (telesector)
                    SetActorAngle(TID_PLAYER+i, GetActorAngle(tid));
                else
                    SetActorAngle(TID_PLAYER+i, GetActorAngle(player_teleporter[i]));
                SetActorVelocity(TID_PLAYER+i, 0.0, 0.0, 0.0, false, false);
            }
        }
    }
}

Script "DoomWare_Server_TeleportSingle" (int plynum, int dest) // Teleports a single player
{
    Player_SavePosition(plynum);
    Thing_Move(TID_PLAYER+plynum, dest, false);
    SetActorPitch(TID_PLAYER+plynum, 0.0);
    SetActorAngle(TID_PLAYER+plynum, GetActorAngle(dest));
}

Script "DoomWare_Server_ReturnPlayers" (int fog) // Returns all players to the lobby
{
    for (int i=0; i<MAXPLAYERS; i++)
    {
        // Don't teleport the player if they're not ingame or if their return position is invalid
        if (!PlayerInGame(i) || (player_position[i][0] == 0xFFFFFFFF && player_position[i][1] == 0xFFFFFFFF && player_position[i][2] == 0xFFFFFFFF))
            continue;

        // Move the player back to their original spot
        SetActorPosition(TID_PLAYER+i, player_position[i][0], player_position[i][1], player_position[i][2], fog);

        // If for some reason they're not at the spawn, force them back to the center
        while (Distance(TID_PLAYER+i, 1) > 512)
        {
            SetActorPosition(TID_PLAYER+i, GetActorX(1), GetActorY(1), GetActorZ(1), fog);
            delay(1);
        }
    }
}

Script "DoomWare_Server_UpdateDB" (void) // Updates the Database at the end of the game
{
    int i;

    // Don't update if it was a solo game
    if (game_solo)
        terminate;

    // Check for people who have played too much DoomWare
    for (i=0; i<MAXPLAYERS; i++)
        if ((GetCVar("doomware_unsafedb") || playerIsLoggedIn(i)) && playerInGame(i) && data_role[i] == ROLE_NONE)
            if ((GetCVar("doomware_unsafedb") && GetDBEntry("Points", StrParam(n:i+1) + game_score[i] >= 300)) || GetDBEntry("Points", getPlayerAccountName(i)) + game_score[i] >= 300)
                data_role[i] = ROLE_REGULAR;

    // Begin the Database Transaction
    BeginDBTransaction();

    for (i=0; i<MAXPLAYERS; i++)
    {
        if ((PlayerIsLoggedIn(i) || GetCVar("doomware_unsafedb")) && playerInGame(i))
        {
            str plyname = getPlayerAccountName(i);
            if (GetCVar("doomware_unsafedb"))
                plyname = StrParam(n:i+1);
            
            // Log the wins
            SetDBEntry("Wins", plyname, data_wins[i]);

            // Log the total points
            incrementDBEntry("Points", plyname, game_score[i]);

            // Log the number of deaths
            SetDBEntry("Deaths", plyname, data_deaths[i]);

            // Log the number of 1ups caught
            SetDBEntry("1Ups", plyname, data_1ups[i]);

            // Log the achievements
            SetDBEntry("Achievements", plyname, data_achieve[i]);

            // Log the player's roles
            SetDBEntry("Role", plyname, data_role[i]);
        }
    }

    // Update the Database
    EndDBTransaction();
    delay(1);
}

function void Load_PlayerDB(int plynum) // Loads a player's database data
{
    str plyname = getPlayerAccountName(plynum);
    if (GetCVar("doomware_unsafedb"))
        plyname = StrParam(n:plynum+1);
    BeginDBTransaction();
    data_points[plynum] = GetDBEntry("Points", plyname);
    data_wins[plynum] = GetDBEntry("Wins", plyname);
    data_deaths[plynum] = GetDBEntry("Deaths", plyname);
    data_1ups[plynum] = GetDBEntry("1Ups", plyname);
    data_role[plynum] = GetDBEntry("Role", plyname);
    data_achieve[plynum] = GetDBEntry("Achievements", plyname);
    data_bosskills[plynum] = GetDBEntry("BossKills", plyname);
    EndDBTransaction();
}

Script "DoomWare_Entity_Cleanup" (void) // Cleans up entities with ThingID TID_REMOVE
{
    // Remove entities marked for deletion
    While (ThingCount(0, TID_REMOVE) > 0)
    {
        thing_remove(TID_REMOVE);
        delay(1);
    }
}


/*===================================================================================================
                                     DoomWare Client Main Logic
===================================================================================================*/

Script "DoomWare_Client_Death" DEATH // Called when a player dies
{
	int plynum = PlayerNumber();
		
	// Win or lose the player
    if ((game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM))
    {
        if (!round_winifsuicide)
        {
            Player_Lose(PlayerNumber(), false);
            data_deaths[PlayerNumber()]++;
            if (data_deaths[PlayerNumber()] == 100)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_100DEATH);
        }
        else
            Player_Win(PlayerNumber());
    }
	
	// Invalidate the player teleport position to prevent them from being re-teleported to the arena (because they respawn there)
    Player_InvalidatePosition(PlayerNumber());

    // Spawn a spoopy ghost
    if (game_skin == MAPSKIN_HALLOWEEN)
        SpawnSpotForced("SpoopyGhost", TID_PLAYER+PlayerNumber(), TID_REMOVE, 0);
	
    // Remove the player's TID if they're dead (to prevent corpses from emitting effects)
    if (GetActorProperty(TID_PLAYER+PlayerNumber(), APROP_HEALTH) <= 0)
        Thing_ChangeTID(TID_PLAYER+PlayerNumber(), 0);
}

Script "DoomWare_Client_Disconnect" (int gone) DISCONNECT // Called when the player leaves
{
    // Wipe all messages
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_SCORE, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_ROUND, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_LEADER, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_SPREAD, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWHS, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR, CR_WHITE, 0.5, 0.3, 1);
    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSBACK, CR_WHITE, 0.5, 0.3, 1);
	
	// If the player was in a team, save his score
	// We can't get their team in DISCONNECT scripts, so we'll have to figure it out later
	if (game_teams)
		game_extrascoreteams[MAXTEAMS] += game_score[gone];

    // Reset that player's score and data
    game_score[gone] = 0;
    data_points[gone] = 0;
    data_wins[gone] = 0;
    data_deaths[gone] = 0;
    data_1ups[gone] = 0;
    data_role[gone] = ROLE_UNLOGGED;
    data_achieve[gone] = 0;
    data_bosskills[gone] = 0;
    player_haswackyscript[gone] = false;

    // Stop the game if there aren't enough players
    if (game_status != STATUS_NOTSTARTED)
    {
        // End the game if we ran out of players
        if (PlayerCount() < 2 && !game_solo)
            game_over = OVER_PLAYER;

        // Force change map if there are no players
        if (PlayerCount() == 0)
            ChangeLevel("map01", 0, 0, 0);
    }
}

Script "DoomWare_Client_Respawn" RESPAWN // Called when a player respawns
{
    thing_changetid(0, TID_PLAYER+PlayerNumber());
    player_observe[PlayerNumber()] = 0;
    clearinventory();
    Player_SetWackymod(PlayerNumber());
}

Script "DoomWare_Client_GameLogic" (void) // Main client gamemode logic "thread"
{
    str extra = "";
    if (game_skin == MAPSKIN_HALLOWEEN)
        extra = "Halloween/";
    else if (game_skin == MAPSKIN_CHRISTMAS)
        extra = "Christmas/";
        
    // Set player wackymods
    Player_SetWackyMod(PlayerNumber());
    
    // Announce Win/Lose
    if (game_status == STATUS_WINLOSE)
    {        
        // Reset the player
        if (game_wackymod != WACKYMOD_1HP)
            SetActorProperty(TID_PLAYER+PlayerNumber(), APROP_Health, 100);
        player_answer1[PlayerNumber()] = 0;
        player_answer2[PlayerNumber()][0] = 0;
        player_answer2[PlayerNumber()][1] = 0;
        player_answer2[PlayerNumber()][2] = 0;
        player_answer2[PlayerNumber()][3] = 0;
        player_viewsprite[PlayerNumber()] = "";
        ClearInventory();
        fadeto(0, 0, 0, 0.0, 0.0);
        setplayerproperty(1, 0, prop_invulnerability);
        setplayerproperty(1, 0, prop_frozen);
        if (game_wackymod != WACKYMOD_FLIGHT)
            setplayerproperty(1, 0, PROP_FLY);

        // Check if player lost
        if (Check_Player_Lost(PlayerNumber()))
        {
            // Play music depending on the speed
            if (player_musicwinlose[PlayerNumber()] == false && GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_speed)
                {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Fail"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Fail", d:game_speed+1), 127); break;
                }
                player_musicwinlose[PlayerNumber()] = true;
            }
        }
        else
        {
            // Play music depending on the speed
            if (player_musicwinlose[PlayerNumber()] == false)
            {
                if (GetUserCVar(PlayerNumber(), "doomware_music"))
                {
                    switch (game_speed)
                    {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Win"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Win", d:game_speed+1), 127); break;
                    }
                }
                game_score[PlayerNumber()]++;
                player_musicwinlose[PlayerNumber()] = true;
                if (data_points[PlayerNumber()]+game_score[PlayerNumber()] >= 300)
                    Give_Achievement(PlayerNumber(), ACHIEVE_ID_300POINTS);
            }
        }
    }

    // Check if a tiebreaker has started
    if (game_status == STATUS_TIEDETECT && player_musicgameover[PlayerNumber()] == false && GetUserCVar(PlayerNumber(), "doomware_music"))
    {
        // Play the tie warning music
        LocalAmbientSound("DoomWare/TieBreaker", 127);
        player_musicgameover[PlayerNumber()] = true;
    }

    // Check if the game's over
    if (game_status == STATUS_GAMEOVER)
    {
        // Play the game over music
        if (player_musicgameover[PlayerNumber()] == false)
        {
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
                LocalAmbientSound("DoomWare/GameOver", 127);
            player_musicgameover[PlayerNumber()] = true;

            // Give the achievement if the player's score is 25 or more
            if (game_score[PlayerNumber()] >= 25)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_25POINTS);
        }

        // If the game ended normally
        if (game_over == OVER_WINNER || game_over == OVER_WINNERRED || game_over == OVER_WINNERBLUE)
        {
            // Award the winner with a BFG
            if (!CheckInventory("BFG9000") && (game_teams && ((game_over == OVER_WINNERRED && GetPlayerInfo(PlayerNumber(), PLAYERINFO_TEAM) == TEAM_RED) || (game_over == OVER_WINNERBLUE && GetPlayerInfo(PlayerNumber(), PLAYERINFO_TEAM) == TEAM_BLUE))) || (!game_teams && game_score[PlayerNumber()] == game_highscores[0]))
            {
                GiveInventory("BFG9000", 1000);
                GiveInventory("Cell", 1000);
                SetWeapon("BFG9000");
                data_wins[PlayerNumber()]++;
                switch (data_wins[PlayerNumber()])
                {
                    case 1:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_1WIN);
                        break;
                    case 10:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_10WIN);
                        break;
                    case 50:
                        Give_Achievement(PlayerNumber(), ACHIEVE_ID_50WIN);
                        break;
                }
            }
        }
    }

    // Play Waiting/Speedup music
    if (player_musicwaiting[PlayerNumber()] == false)
    {
        // Check if the game is speeding up
        if (game_status == STATUS_SPEEDUP)
        {
            // Play the speedup music, depending on the speed
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_roundnum)
                {
                    case SPEEDUP1: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup"), 127); break;
                    case SPEEDUP2: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup2"), 127); break;
                    case SPEEDUP3: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup3"), 127); break;
                    case SPEEDUP4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Speedup4"), 127); break;
                }
            }
            player_musicwaiting[PlayerNumber()] = true;
            player_musicgameover[PlayerNumber()] = false;
        }
        else if (game_status == STATUS_WAITING)
        {
            // Play the waiting music
            if (GetUserCVar(PlayerNumber(), "doomware_music"))
            {
                switch (game_speed)
                {
                    case 0: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Intro"), 127); break;
                    case 1:
                    case 2:
                    case 3:
                    case 4: LocalAmbientSound(StrParam(s:"DoomWare/", s:extra, s:"Intro", d:game_speed+1), 127); break;
                }
            }
            player_musicwaiting[PlayerNumber()] = true;
            player_musicgameover[PlayerNumber()] = false;
        }
        fadeto(0, 0, 0, 0.0, 0.0); // Pokemon HUD brutefix
    }

    // Play a minigame
    str gametoplay;
    if (game_status == STATUS_MINIGAME)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_Minigame", d:round_current[game_roundnum-1]);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Play a 1v1 Tiebreaker
    if (game_status == STATUS_TIEBREAK)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_TieBreaker", d:round_tiebreaker);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Play a non 1v1 Tiebreaker
    if (game_status == STATUS_TIEBREAKM)
    {
        player_frags[PlayerNumber()] = PlayerFrags();
        player_musicwaiting[PlayerNumber()] = false;
        player_musicwinlose[PlayerNumber()] = false;
        gametoplay = StrParam(s:"DoomWare_Client_TieBreakerM", d:round_tiebreaker);

        // Delay a tick to ensure that minigame winconditions are set correctly
        delay(1);
        ACS_NamedExecuteAlways(gametoplay, 0);
    }

    // Wait until the round's over
    int fragsmade = 0;
    while (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
    {
        // Give a 1Up if we got a frag
        if (player_frags[PlayerNumber()] < PlayerFrags() && minigame_fragpoints)
        {
            GiveInventory("1up", 1);
            fragsmade++;
            player_frags[PlayerNumber()] = PlayerFrags();

            // Award an achievement if we got 3 frags
            if (fragsmade >= 3)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_3FRAGS);
        }

        // Give points if we ate a 1UP
        if (CheckInventory("1up") > 0)
        {
            if (game_wackymod == WACKYMOD_T1UPS)
            {
                game_score[PlayerNumber()]+=3;
                data_1ups[PlayerNumber()]+=3;
            }
            else
            {
                game_score[PlayerNumber()]++;
                data_1ups[PlayerNumber()]++;
            }
            TakeInventory("1up", 1000);
            SpawnSpotForced("1UPText", PlayerNumber()+TID_PLAYER, 0, 0);
            LocalAmbientSound("DoomWare/1Up", 127);
            if (data_1ups[PlayerNumber()] == 50)
                Give_Achievement(PlayerNumber(), ACHIEVE_ID_501UPS);
        }
        delay(1);
    }

    // Clear out the minigame instructions
    minigame_instruction1[PlayerNumber()] = "";
    minigame_instruction2[PlayerNumber()] = "";
    minigame_instruction3[PlayerNumber()] = "";

    delay(1);
    if (PlayerInGame(PlayerNumber()) && !PlayerIsSpectator(PlayerNumber())) // Unless the player disconnected, restart the script
        restart;
}

Script "DoomWare_Client_DrawHUD" (void) CLIENTSIDE // HUD drawing "thread"
{
    // Make sure only the person who called it actually sees the HUD
    if (ConsolePlayerNumber() != PlayerNumber())
        terminate;

    int plynum = ConsolePlayerNumber();
    SetActivator(TID_PLAYER+plynum);

    // Open the menu if this is the player's first time joining
    if (GetUserCVar(plynum, "__doomware_firstjoin") == true)
    {
        SetUserCVar(plynum, "__doomware_firstjoin", false);
        RequestScriptPuke(999);
    }

    // Initialize the hud
    int w = GetScreenWidth();
    int h = GetScreenHeight();
    str hudsprite;
    if (GetUserCVar(plynum, "doomware_hudscale"))
    {
        w = 800;
        h = 600;
    }
    SetHudSize(w, h, true);
    w = w << 16;
    h = h << 16;

    bool remind_login = true;
    bool playedwackysound = false;
    int hud_toppos  = 0.0;
    int hud_botpos  = h+64.0;
    int hud_spindex = 0;
    int hud_time    = 0;
    int wackymod_time = 0;
    int lasttimertime   = -1;
    if (GetCvar("__clientsync_gamestatus") <= STATUS_STARTING)
        hud_toppos = -95.0;

    while (1)
    {
        w = GetScreenWidth();
        h = GetScreenHeight();
        if (GetUserCVar(plynum, "doomware_hudscale"))
        {
            w = 800;
            h = 600;
        }
        SetHudSize(w, h, true);
        w = w << 16;
        h = h << 16;

        // Obtain the value of all global variables
        int syncdata_gamestatus = GetCvar("__clientsync_gamestatus");
        int syncdata_gameover = GetCvar("__clientsync_gameover");
        int syncdata_highscore1 = GetCvar("__clientsync_highscore1");
        int syncdata_highscore2 = GetCvar("__clientsync_highscore2");
        int syncdata_wincondition1 = GetCvar("__clientsync_wincondition1");
        int syncdata_wackymod = GetCvar("__clientsync_wackymod");
        str syncdata_highname = GetCVarString("__clientsync_highname");
        str syncdata_insctruction1 = Unpack_CVar_Array_String("__clientsync_player_instruction1");
        str syncdata_insctruction2 = Unpack_CVar_Array_String("__clientsync_player_instruction2");
        str syncdata_insctruction3 = Unpack_CVar_Array_String("__clientsync_player_instruction3");
        str syncdata_hint = GetCVarString("__clientsync_speeduphint");
        str syncdata_gamesolo = GetCvar("__clientsync_gamesolo");
        str syncdata_roundnum = GetCvar("__clientsync_round");
        str syncdata_canobserve = GetCvar("__clientsync_canobserve");
        str syncdata_timer = GetCvar("__clientsync_minigametimer");
        str syncdata_roundcurrent = GetCvar("__clientsync_roundcurrent");
        str syncdata_teams = GetCvar("__clientsync_teams");

        int syncdata_score = Unpack_CVar_Array("__clientsync_player_score");
        str syncdata_checklost = Unpack_CVar_Array("__clientsync_player_checklost");
        str syncdata_lostround = Unpack_CVar_Array("__clientsync_player_lostround");
        str syncdata_loggedin = Unpack_CVar_Array("__clientsync_player_loggedin");
        str syncdata_viewsprite = Unpack_CVar_Array_String("__clientsync_player_viewsprite");

        /*==============================
                 Center Text
        ==============================*/

        // Move the top of the HUD stuff downwards if game is ready
        if (syncdata_gamestatus >= STATUS_STARTING && hud_toppos < 0)
        {
            // Make some sounds
            if (hud_toppos == -92.0 && GetUserCVar(plynum, "doomware_huddynamic") && GetUserCVar(plynum, "doomware_hudsounds"))
                AmbientSound("DoomWare/HUDMove", 127);

            // Move the hud
            if (GetUserCVar(plynum, "doomware_huddynamic"))
                hud_toppos += 1.0;
            else
                hud_toppos = 0;
        }

        SetFont("DW_FONT4");
        if (syncdata_gamestatus == STATUS_NOTSTARTED) // State that we're waiting for players
        {
            HUDMessage(s:"Waiting for Players"; HUDMSG_PLAIN, MSGID_CENTER, CR_PURPLE, w/2, FixedMul(h, 0.25), 1);
            SetFont("DW_FONT5");
            HUDMessage(s:"\n\nOr Press ", k:"+dwscores", s:" to start a game by yourself"; HUDMSG_PLAIN, MSGID_CENTER2, CR_PURPLE, w/2, FixedMul(h, 0.25) + 4.0, 1);
            HUDMessage(s:"\n\n\n\nWarning: Most Minigames are designed with 2+ players in mind and stats won't be tracked!"; HUDMSG_PLAIN, MSGID_CENTER3, CR_RED, w/2, FixedMul(h, 0.25) + 4.0, 1);
        }
        else if (syncdata_gamestatus == STATUS_STARTING) // We're ready to go
        {
            int waittime = ((FixedDiv(syncdata_timer, SECOND)*100)&0xFFFF0000) >> 16;
            int waittens = waittime/1000;
            int waitones = (waittime/100)%10;
            int waittenths = (waittime/10)%10;
            int waithundredths = waittime%10;
            HUDMessage(s:"READY TO PLAY!"; HUDMSG_PLAIN, MSGID_CENTER, CR_PURPLE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(d:waittens, d:waitones, s:":", d:waittenths, d:waithundredths; HUDMSG_PLAIN, MSGID_CENTER2, CR_PURPLE, w/2, FixedMul(h, 0.25)+18.0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
        }
        else if (syncdata_gamestatus == STATUS_WACKYMOD) // Wacky modifier selection
        {
            HUDMessage(s:"WACKY MODIFIER"; HUDMSG_PLAIN, MSGID_CENTER, CR_BLUE, w/2, FixedMul(h, 0.25), 1);
            
            // Play roulette sound
            if (!playedwackysound && GetUserCVar(plynum, "doomware_hudsounds"))
            {
                AmbientSound("DoomWare/WackyMod", 127);
                playedwackysound = true;
            }
            
            // Roulette animation
            if (wackymod_time < (SECOND*2 + 15))
                HUDMessage(s:(WACKYMOD_NAME1+random(0,NUMBEROFWACKYMODS-1)); HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);
            else if (wackymod_time > (SECOND*3+17) || (wackymod_time%14 > 7))
                HUDMessage(s:(WACKYMOD_NAME1+(syncdata_wackymod-1)); HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);
            else 
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_BLACK, 0, 0, 1);
                
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
            wackymod_time++;
        }
        else if (syncdata_gamestatus == STATUS_SPEEDUP)
        {
            // Announce the speedup, and select a hint from the pile
            HUDMessage(s:"Speed Up"; HUDMSG_PLAIN, MSGID_CENTER, CR_BLUE, w/2, FixedMul(h, 0.25), 1);
            SetFont("DW_FONT5");
            HUDMessage(s:syncdata_hint; HUDMSG_PLAIN, MSGID_CENTER2, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.25) + 12.0 + 0.1, 1);

            // Do animation stuff for the HIUD
            hud_time += 1;
            if (hud_time > SECOND/4)
            {
                hud_time = 0;
                hud_spindex = (hud_spindex + 1)%2;
            }
        }
        else if (syncdata_gamestatus == STATUS_WINLOSE)
        {
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_GREEN, 0.5, 0.3, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);

            // Do animation stuff for the HIUD
            hud_time += 1;
            if (hud_time > SECOND/4)
            {
                hud_time = 0;
                hud_spindex = (hud_spindex + 1)%3;
            }

            // Check if player lost
            if (syncdata_checklost == 1)
                HUDMessage(s:"You Failed!"; HUDMSG_PLAIN, MSGID_CENTER, CR_RED, w/2, FixedMul(h, 0.25), 1);
            else
                HUDMessage(s:"You Won!"; HUDMSG_PLAIN, MSGID_CENTER, CR_GREEN, w/2, FixedMul(h, 0.25), 1);
        }
        else if (syncdata_gamestatus == STATUS_TIEDETECT)
        {
            HUDMessage(s:"Game Over"; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\nThere is a tie, initializing Tie Breaker round."; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);
        }
        else if (syncdata_gamestatus == STATUS_GAMEOVER)
        {
            HUDMessage(s:"Game Over"; HUDMSG_PLAIN, MSGID_CENTER, CR_WHITE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_GREEN, 0.5, 0.3, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_GREEN, 0.5, 0.3, 1);

            // State why the game ended
            switch (syncdata_gameover)
            {
                case OVER_WINNER:
                    HUDMessage(s:"\n\nThe winner is ", s:syncdata_highname, s:" with ", d:syncdata_highscore1, s:" points"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERRED:
                    HUDMessage(s:"\n\nRED Team Victory!"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERBLUE:
                    HUDMessage(s:"\n\n\chBLUE Team\cg Victory!"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 0.3, 1);
                    break;
                case OVER_WINNERSOLO:
                    if (syncdata_score != 1)
                        HUDMessage(s:"\n\nYou scored ", d:syncdata_score, s:" points"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    else
                        HUDMessage(s:"\n\nYou scored 1 point"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_PLAYER:
                    HUDMessage(s:"\n\nThere are not enough players"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_FORCED:
                    HUDMessage(s:"\n\nThe game was forcefully ended"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
                case OVER_JOIN:
                    HUDMessage(s:"\n\nA new player has entered the game"; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
                    break;
            }
        }
        else if (syncdata_gamestatus == STATUS_MINIGAME || syncdata_gamestatus == STATUS_TIEBREAK || syncdata_gamestatus == STATUS_TIEBREAKM)
        {
            HUDMessage(s:syncdata_insctruction1; HUDMSG_PLAIN, MSGID_CENTER, CR_ORANGE, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\n", s:syncdata_insctruction2; HUDMSG_PLAIN, MSGID_CENTER2, CR_RED, w/2, FixedMul(h, 0.25), 1);
            HUDMessage(s:"\n\n\n\n", s:syncdata_insctruction3; HUDMSG_PLAIN, MSGID_CENTER3, CR_RED, w/2, FixedMul(h, 0.25), 1);
        }
        else
        {
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER2, CR_BLACK, 0, 0, 1);
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CENTER3, CR_BLACK, 0, 0, 1);
        }


        /*==============================
                 HUD Animation
        ==============================*/

        if (syncdata_gamestatus == STATUS_WINLOSE && GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (syncdata_checklost == 0)
                hudsprite = StrParam(s:"WIN", d:(hud_spindex+1));
            else
                hudsprite = "FAIL";
        }
        else if (syncdata_gamestatus == STATUS_SPEEDUP && GetUserCVar(plynum, "doomware_huddynamic"))
        {
            if (hud_spindex == 0)
                hudsprite = "SPED";
            else
                hudsprite = "OFF";
        }
        else
            hudsprite = "OFF";


        /*==============================
               Leader and Spread
        ==============================*/

        if (syncdata_gamesolo == 0)
        {
            // Background
            SetFont(StrParam(s:"HUD2", s:hudsprite));
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_LEADER2, CR_PURPLE, w/2, hud_toppos + 0.1, 1);

            if (syncdata_gamestatus > STATUS_STARTING)
            {
                // If the player is in a team
                if (syncdata_teams)
                {
                    int myteamscore = 0;
                    switch (GetPlayerInfo(ConsolePlayerNumber(), PLAYERINFO_TEAM))
                    {
                        case TEAM_BLUE:
                            myteamscore = syncdata_highscore1;
                            break;
                        case TEAM_RED:
                            myteamscore = syncdata_highscore2;
                            break;
                    }
                    
                    // Leading team
                    SetFont("DW_FONT1");
                    if (syncdata_highscore1 == syncdata_highscore2)
                        HUDMessage(s:"Teams are tied"; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);
                    else if (syncdata_highscore1 > syncdata_highscore2)
                        HUDMessage(s:"Blue Team"; HUDMSG_PLAIN, MSGID_LEADER, CR_BLUE, w/2, hud_toppos+46.0, 1);
                    else
                        HUDMessage(s:"Red Team"; HUDMSG_PLAIN, MSGID_LEADER, CR_RED, w/2, hud_toppos+46.0, 1);

                    // Spread
                    SetFont("DW_FONT3");
                    if (syncdata_highscore1 == myteamscore)
                    {
                        if (syncdata_highscore1 >= syncdata_highscore2)
                            HUDMessage(s:"+", d:(syncdata_highscore1-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                        else
                            HUDMessage(s:"-", d:(syncdata_highscore2-syncdata_highscore1); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                    }
                    else
                    {
                        if (syncdata_highscore2 >= syncdata_highscore1)
                            HUDMessage(s:"+", d:(syncdata_highscore2-syncdata_highscore1); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                        else
                            HUDMessage(s:"-", d:(syncdata_highscore1-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                    }
                }
                else
                {
                    // Leading player
                    SetFont("DW_FONT1");
                    if (syncdata_highscore1 == syncdata_highscore2)
                        HUDMessage(s:"There are multiple leaders"; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);
                    else
                        HUDMessage(s:syncdata_highname; HUDMSG_PLAIN, MSGID_LEADER, CR_ORANGE, w/2, hud_toppos+46.0, 1);

                    // Spread
                    SetFont("DW_FONT3");
                    if (syncdata_highscore1 <= syncdata_score)
                        HUDMessage(s:"+", d:(syncdata_score-syncdata_highscore2); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                    else
                        HUDMessage(s:"-", d:(syncdata_highscore1-syncdata_score); HUDMSG_PLAIN, MSGID_SPREAD, CR_ORANGE, w/2, hud_toppos+77.0, 1);
                }
                
                // Remind people that they can view the highscore table
                if (GetUserCVar(plynum, "doomware_hudshowbinds"))
                    HUDMessage(s:"\n\n\nPress ", k:"+dwscores", s:" to view the Highscore table"; HUDMSG_PLAIN, MSGID_VIEWHS, CR_ORANGE, w/2, hud_toppos+64.0 + 0.1, 1);
                else
                    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWHS, CR_ORANGE, w/2, hud_toppos+64.0 + 0.1, 1);
            }
        }


        /*==============================
                     Score
        ==============================*/

        int x_start = 64.0;
        if (GetUserCVar(plynum, "doomware_hudscale") && GetUserCVar(plynum, "doomware_hudwide"))
            x_start = -48.0;
        SetFont(StrParam(s:"HUD1", s:hudsprite));
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_SCORE2, CR_PURPLE, x_start + 0.1, hud_toppos + 0.1, 1);
        SetFont("HUD1SCOR");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_SCORE3, CR_PURPLE, x_start+32.0 + 0.1, hud_toppos + 9.0 + 0.1, 1);
        if (syncdata_gamestatus > STATUS_STARTING)
        {
            SetFont("DW_FONT1");
            HUDMessage(d:syncdata_score; HUDMSG_PLAIN, MSGID_SCORE, CR_YELLOW, x_start+64.0, hud_toppos+46.0, 1);
            if (GetUserCVar(plynum, "doomware_hudshowbinds"))
            {
                SetFont("DW_FONT3");
                HUDMessage(s:"Press ", k:"+dwmenu", s:" to open the menu"; HUDMSG_PLAIN, MSGID_MENUBIND, CR_YELLOW, x_start+64.0 + 0.4, hud_toppos + 68.0 + 0.1, 1);
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MENUBIND, CR_YELLOW, 0.0, 0.0, 1);
        }


        /*==============================
                     Round
        ==============================*/

        SetFont(StrParam(s:"HUD1", s:hudsprite));
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_ROUND2, CR_PURPLE, w-x_start + 0.2, hud_toppos + 0.1, 1);
        SetFont("HUD1RND");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_ROUND3, CR_PURPLE, w-x_start-32.0 + 0.2, hud_toppos + 9.0 + 0.1, 1);
        if (GetUserCVar(plynum, "doomware_hudshowbinds") && syncdata_canobserve && syncdata_lostround)
        {
            SetFont("DW_FONT3");
            HUDMessage(s:"Press ", k:"+dwobserve", s:" to observe the game"; HUDMSG_PLAIN, MSGID_OBSERVE, CR_CYAN, w-x_start-64.0 + 0.4, hud_toppos + 68.0 + 0.1, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_OBSERVE, CR_CYAN, 0.0, 0.0, 1);
        SetFont("DW_FONT1");
        if (syncdata_gamestatus > STATUS_STARTING)
        {
            if (syncdata_roundnum <= MAXROUNDS)
                HUDMessage(d:syncdata_roundnum; HUDMSG_PLAIN, MSGID_ROUND, CR_GREEN, w-x_start-64.0, hud_toppos+46.0, 1);
            else
                HUDMessage(d:MAXROUNDS; HUDMSG_PLAIN, MSGID_ROUND, CR_GREEN, w-x_start-64.0, hud_toppos+46.0, 1);
        }


        /*==============================
                     Timer
        ==============================*/

        if (syncdata_gamestatus != STATUS_STARTING)
        {
            if (GetUserCVar(plynum, "doomware_huddynamic"))
            {
                if (syncdata_timer != TIMER_EARLY && syncdata_timer <= 0 && hud_botpos < h+64.0)
                    hud_botpos += 4.0;
                else if (syncdata_timer > 0 && hud_botpos > h)
                    hud_botpos -= 4.0;

                // In case people decide to resize the hud midway through the round
                if (hud_botpos < h)
                    hud_botpos = h;
            }
            else
            {
                if (syncdata_timer > 0)
                    hud_botpos = h;
                else
                    hud_botpos = h+64.0;
            }

            SetHudSize(w>>16, h>>16, false);
            if (syncdata_timer == TIMER_EARLY)
                SetFont("HUDCLK2");
            else
                SetFont("HUDCLK1");

            if (hud_botpos != h+64.0)
                HUDMessage(s:"a"; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER2, CR_GREEN, w/2, hud_botpos + 0.2, 1);
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_TIMER2, CR_GREEN, 0.0, 0.0, 1);
            SetFont("DW_FONT2");
            int time = ((FixedDiv(syncdata_timer, SECOND)*100)&0xFFFF0000) >> 16;
            int oldtime = ((FixedDiv(lasttimertime, SECOND)*100)&0xFFFF0000) >> 16;
            int tens = time/1000;
            int ones = (time/100)%10;
            int oldones = (oldtime/100)%10;
            int tenths = (time/10)%10;
            int hundredths = time%10;
            if (syncdata_timer > 0)
            {
                HUDMessage(d:tens, d:ones, s:":", d:tenths, d:hundredths; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER, CR_RED, w/2, hud_botpos - 16.0 + 0.2, 1);

                // Play some ticking sounds when there's 3, 2, 1 seconds left
                if (GetUserCvar(plynum, "doomware_hudsounds") && tens == 0)
                {
                    if (ones == 2 && oldones == 3)
                        AmbientSound("DoomWare/Clock3", 127);
                    if (ones == 1 && oldones == 2)
                        AmbientSound("DoomWare/Clock2", 127);
                    if (ones == 0 && oldones == 1)
                        AmbientSound("DoomWare/Clock1", 127);
                }
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_TIMER, CR_RED, w/2, hud_botpos + 0.2, 1);
        }

        /*==============================
                Wacky Mod Notice
        ==============================*/

        int extray = 0.0;
        SetFont("DW_FONT5");
        
        // Wacky Modifier
        if (syncdata_wackymod != WACKYMOD_NONE && syncdata_gamestatus > STATUS_WACKYMOD)
        {
            if (remind_login)
                extray = 16.0;
            HUDMessage(s:"Wacky Modifier: ", s:(WACKYMOD_NAME1+(syncdata_wackymod-1)); HUDMSG_PLAIN, MSGID_WACKYMOD, CR_CYAN, w/2 + 0.4, h + 0.2, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_WACKYMOD, CR_CYAN, w/2, h + 0.2, 1);
            

        /*==============================
                    Warnings
        ==============================*/
        
        SetFont("DW_FONT5");
        if (PlayerCount() > MAXPLAYERS)// Warn that we have too many players
            HUDMessage(s:"WARNING! TOO MANY PLAYERS! MAX: ", d:MAXPLAYERS; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2, h-extray + 0.2, 1);
        else if (remind_login == true && GetUserCVar(plynum, "doomware_loginwarn")) // Remind players to login
        {
            HUDMessage(s:"You are not logged in, your stats will not be tracked!\nPress ", k:"+use", s:" to dismiss this message."; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2 + 0.4, h-extray + 0.2, 1);

            // Allow players to dismiss that message
            if (GetPlayerInput(plynum, MODINPUT_BUTTONS) & BT_USE || syncdata_loggedin)
                remind_login = false;
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_WARNING, CR_RED, w/2, h + 0.2, 1);


        /*==============================
            Player position observing
        ==============================*/
        
        if (CheckPlayerCamera(plynum) != TID_PLAYER+plynum && (ClassifyActor(TID_PLAYER+plynum) & ACTOR_ALIVE))
        {
            int camtid = CheckPlayerCamera(plynum);
            int plyx = GetActorX(TID_PLAYER+plynum)-GetActorX(camtid);
            int plyy = GetActorY(TID_PLAYER+plynum)-GetActorY(camtid);
            int plyz = GetActorZ(TID_PLAYER+plynum);
            int dist, xScale, yScale;
            
            // Get the player's angle and distance
            int vang = VectorAngle(plyx, plyy);
            int angle = (vang - GetActorAngle(camtid) + 1.0) % 1.0;
            if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(plyy, sin(vang));
            else dist = FixedDiv(plyx, cos(vang));

            // Scale the cursor
            if (GetUserCVar(plynum, "doomware_hudwide"))
            {
                xScale = 1072;
                yScale = 603;
            }
            else
            {
                xScale = 800;
                yScale = 600;
            }
            SetHudSize(xScale, yScale, 0);

            // If the player is inside our horizontal view
            if ((angle < 0.23 || angle > 0.85) && dist < 1024.0)
            {
                // And our vertical view
                if (GetActorPitch(camtid) >= -0.5 && GetActorPitch(camtid) <= 0.5)
                {
                    // Get the player angles
                    int pitch = VectorAngle(dist, plyz - (GetActorZ(camtid) + GetActorViewHeight(camtid)));
                    pitch += FixedMul(GetActorPitch(camtid), 1.2) % 1.0;

                    // If the player is in our view (taking into account angles)
                    if ((xScale/2) * sin(angle) != 0 && cos(angle) != 0 && (xScale/2) * sin(pitch) != 0 && cos(pitch) != 0)
                    {
                        // Finalize the x and y positions
                        plyx = xScale/2 - ((xScale/2) * sin(angle) / cos(angle));
                        plyy = yScale/2 - ((xScale/2) * sin(pitch) / cos(pitch));
                        SetFont("YOUHA0");
                        HudMessage(c:'A'; HUDMSG_ALPHA, MSGID_PLYHERE, CR_WHITE, plyx << 16, plyy << 16, 1);
                    }
                }
            }
        }
        else
            HudMessage(s:""; HUDMSG_ALPHA, MSGID_PLYHERE, CR_WHITE, 0.0, 0.0, 1);


        /*==============================
            Extra Minigame Elements
        ==============================*/

        if (syncdata_gamestatus == STATUS_MINIGAME && GetCVar("screenblocks") < 11)
        {
            int status_w = 320;
            int status_h = 200;
            if (!GetCVar("st_scale"))
            {
                status_w = GetScreenWidth();
                status_h = GetScreenHeight();
            }
            SetHudSize(status_w, status_h, true);
            status_w = (status_w << 16)/2 + 0.4;
            status_h = (status_h << 16)-200.0 + 0.1;
            hud_time +=1;
            if (hud_time >= 20)
            {
                hud_spindex = random(1, 4);
                hud_time = 0;
            }
            switch(syncdata_roundcurrent)
            {
                case 6:
                    SetFont("C7BAR1");
                    if (GetActorProperty(TID_PLAYER+ConsolePlayerNumber(), APROP_Health) <= 0)
                        SetFont("C7BAR2");
                    hudmessage(s:"a"; HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, status_w, status_h, 1);
                    break;
                case 7:
                    SetFont("SMBAR");
                    hudmessage(s:"a"; HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, status_w, status_h, 1);

                    if (hud_spindex < 3)
                    {
                        SetFont(StrParam(s:"SMFACE", d:hud_spindex));
                        hudmessage(s:"A"; HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, status_w, status_h, 1);
                    }
                    else
                        hudmessage(s:""; HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, status_w, status_h, 1);
                    break;
                case 14:
                    if (hud_spindex < 3)
                        SetFont("MMBAR1");
                    else
                        SetFont("MMBAR2");
                    hudmessage(s:"a"; HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, status_w, status_h, 1);
                    break;
                case 43:
                    SetFont("CHEXHUD");
                    hudmessage(s:"a"; HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, status_w, status_h, 1);

                    if (hud_spindex < 3)
                    {
                        SetFont(StrParam(s:"CHEXFAC", d:hud_spindex));
                        hudmessage(s:"A"; HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, status_w, status_h, 1);
                    }
                    else
                        hudmessage(s:""; HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, status_w, status_h, 1);
                    break;
            }
        }
        else
        {
            hudmessage(s:"";HUDMSG_PLAIN, MSGID_STBAR, cR_ORANGE, 0.5, 0.5, 1);
            hudmessage(s:"";HUDMSG_PLAIN, MSGID_STFACE, cR_ORANGE, 0.5, 0.5, 1);
        }
        
        // Rope tug line texture
        if (syncdata_gamestatus == STATUS_TIEBREAK)
            Line_SetTextureOffset(27, 3.0*syncdata_wincondition1, NO_CHANGE, SIDE_FRONT, 10);

        // View sprite
        if (StrCmp(syncdata_viewsprite, "") != 0)
        {
            if (syncdata_wincondition1 == 1337)
                SetHudSize(320, 200, false);
            else if (syncdata_wincondition1 == 1338)
                SetHudSize(20, 18, false);
            else
                SetHudSize(640, 400, false);
            SetFont(syncdata_viewsprite);
            HUDMessage(s:"A"; HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD, MSGID_VIEWSP, CR_WHITE, 0.5, 0.9, 1);
        }
        else
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_VIEWSP, CR_WHITE, 160.0, 120.0, 1);


        SetHudSize(w>>16, h>>16, true);

        lasttimertime = syncdata_timer;

        if (PlayerInGame(plynum))
            delay(1);
        else
            break;
    }
}


/*===================================================================================================
										Minigame Functions
===================================================================================================*/

function void Check_LMS(void) // Check if only one player is alive, and make him win if so
{
    int i;
    
    // Decide on how to check for LMS depending on whether we're playing a team game or not
    if (game_teams)
    {
        int redalive = 0;
        int bluealive = 0;
        
        // Iterate through all players and check if they haven't lost the round
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (player_midround[i])
            {
                switch(GetPlayerInfo(i, PLAYERINFO_TEAM))
                {
                    case TEAM_RED:
                        redalive++;
                        break;
                    case TEAM_BLUE:
                        bluealive++;
                        break;
                    default:
                        break;
                }
            } 
        }
        
        // If one team has no members, and at least one team has a member alive
        if ((redalive == 0 || bluealive == 0) && !(bluealive == 0 && redalive == 0))
        {
            // Iterate through all players again, and win them if they're alive
            for (i=0; i<MAXPLAYERS; i++)
			{
                if (player_midround[i])
				{
                    Player_Win(i);
					if (round_is1vmtiebreaker)
						Give_Achievement(i, ACHIEVE_ID_MVMWIN);
				}
			}
        }
    }
    else
    {
        int alivecount = 0;
        int winid = -1;
        
        // Iterate through all players and check if they haven't lost the round
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (player_midround[i])
            {
                winid = i;
                alivecount++;
            }
        }

        // If only one person is alive, make them win
        if (alivecount == 1)
		{
            Player_Win(winid);
			if (round_is1vmtiebreaker)
				Give_Achievement(winid, ACHIEVE_ID_MVMWIN);
		}
    }
}

function void Check_WonRoundItem(void) // Makes players with WonRoundItem in their inventory win
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (CheckActorInventory(TID_PLAYER+i, "WonRoundItem") > 0)
            Player_Win(i);
}

function void Check_FailRoundItem(void) // Makes players with FailRoundItem in their inventory lose
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (CheckActorInventory(TID_PLAYER+i, "FailRoundItem") > 0)
            Player_Lose(i, false);
}

function bool Should_Speedup(void) // Return true/false if we are speeding up
{
    if (game_wackymod == WACKYMOD_SPEEDUP)
        return false;
    switch (game_roundnum)
    {
        case SPEEDUP1: break;
        case SPEEDUP2: break;
        case SPEEDUP3: break;
        case SPEEDUP4: break;
        default: return false; break;
    }
    return true;
}

function bool Should_TieBreak(void) // Return true/false if we should initialize a tiebreaker round
{        
    // Don't check if we were in a solo game or it was forcefully ended
    if (game_solo || game_over == OVER_FORCED)
        return false;
    
    // If we're not playing a team game, then just check if the top 2 players are tied
    if (!game_teams)
        return (game_highscores[0] == game_highscores[1]);
    
    // Return whether or not the team scores match
    return (game_scoreteams[TEAM_BLUE] == game_scoreteams[TEAM_RED]); // TODO: Expand this for more than 2 teams using a loop
}

function bool Is_1v1_TieBreaker(void) // Return true/false if we are playing a 1v1 tiebreaker
{
    return (((PlayerCount() == 2 && game_teams) || !game_teams) && game_highscores[0] == game_highscores[1] && game_highscores[0] != game_highscores[2]);
}

function bool No_MidRound_Array(void) // Return whether everyone has passed/failed
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (player_midround[i] != false && PlayerInGame(i))
            return false;
    return true;
}


/*===================================================================================================
                                          Player Functions
===================================================================================================*/

function void Player_Win(int plynum) // Make a player win
{
    if (player_midround[plynum] == true)
    {
		int active = ActivatorTID();
		SetActivatorToPlayer(plynum);
        LocalAmbientSound("DoomWare/Check", 127);
        SpawnSpotForced("WonRoundEffect", TID_PLAYER+plynum, 0, 0);
        player_wonround[plynum] = true;
        player_midround[plynum] = false;
            
		// Reset the activator to prevent problems
		if (active < TID_PLAYER)
			SetActivator(0, AAPTR_NULL);
		else
			SetActivatorToPlayer(active-TID_PLAYER);
    }
}

function void Player_Lose(int plynum, bool silent) // Make a player lose
{
    if (player_midround[plynum] == true)
    {
        // Make the sound + effects
        if (!silent)
        {
			int active = ActivatorTID();
            SetActivatorToPlayer(plynum);
            LocalAmbientSound("DoomWare/Failure", 127);
            SpawnSpotForced("FailedRoundEffect", TID_PLAYER+plynum, 0, 0);
            
			// Reset the activator to prevent problems
			if (active < TID_PLAYER)
				SetActivator(0, AAPTR_NULL);
			else
				SetActivatorToPlayer(active-TID_PLAYER);
        }
        player_lostround[plynum] = true;
        player_midround[plynum] = false;

        // If in a 1v1 tiebreaker, make the other player win
        if (game_status == STATUS_TIEBREAK)
        {
            if (plynum == game_highnames[0])
            {
                Player_Win(game_highnames[1]);
                Give_Achievement(game_highnames[1], ACHIEVE_ID_1v1WIN);
            }
            else if (plynum == game_highnames[1])
            {
                Player_Win(game_highnames[0]);
                Give_Achievement(game_highnames[0], ACHIEVE_ID_1v1WIN);
            }
        }
    }
}

function void Player_SetWackymod(int plynum) // Sets the wacky modifier on a player
{
	// Set team items
	if (game_teams)
	{
		switch (GetPlayerInfo(plynum, PLAYERINFO_TEAM))
		{
			case TEAM_BLUE:
				GiveActorInventory(TID_PLAYER+plynum, "BlueTeamItem", 1);
				break;
			case TEAM_RED:
				GiveActorInventory(TID_PLAYER+plynum, "RedTeamItem", 1);
				break;
		}
	}
	
    // Enable wacky mod    
    if (game_wackymod != WACKYMOD_NONE && game_status != STATUS_WACKYMOD)
    {
        switch (game_wackymod)
        {
            case WACKYMOD_JUMP:
                if (!player_haswackyscript[plynum])
                {
                    ACS_NamedExecuteAlways("DoomWare_WackyMod_DoubleJump", 0);
                    player_haswackyscript[plynum] = true;
                }
                break;
            case WACKYMOD_FLIGHT:
                setplayerproperty(1, 1, PROP_FLY);
                break;
            case WACKYMOD_SPEED:
                setplayerproperty(1, 1, PROP_SPEED);
                break;
            case WACKYMOD_INVERT:
                SetActorProperty(TID_PLAYER+plynum, APROP_Speed, -1.0);
                break;
            case WACKYMOD_1HP:
                SetActorProperty(TID_PLAYER+plynum, APROP_Health, 1);
                break;
            case WACKYMOD_SPREAD:
                GiveActorInventory(TID_PLAYER+plynum, "PowerSpread", 1);
                break;
            case WACKYMOD_RAGE:
                GiveActorInventory(TID_PLAYER+plynum, "PowerDoubleFiringSpeed", 1);
                break;
        }
    }    
}

function void Player_SavePosition(int plynum) // Stores the player's position
{
    player_position[plynum][0] = GetActorX(TID_PLAYER+plynum);
    player_position[plynum][1] = GetActorY(TID_PLAYER+plynum);
    player_position[plynum][2] = GetActorZ(TID_PLAYER+plynum);
}

function void Player_InvalidatePosition(int plynum) // Clears the stored player's position
{
    player_position[plynum][0] = 0xFFFFFFFF;
    player_position[plynum][1] = 0xFFFFFFFF;
    player_position[plynum][2] = 0xFFFFFFFF;
}

function bool Check_Player_Won(int plynum) // Returns true/false if this player won the round
{
    return (player_wonround[plynum] || (player_midround[plynum] && round_winifmid));
}

function bool Check_Player_Lost(int plynum) // Returns true/false if this player lost the round
{
    return (player_lostround[plynum] || (player_midround[plynum] && !round_winifmid));
}

function void Player_Morph(int plynum, str class) // Morphs the player into the provided class
{
    UnMorphActor(TID_PLAYER+plynum, true);
    SpawnSpotForced("PlayerTranslator", TID_PLAYER+plynum, TID_EXTRA+plynum, 0);
    Thing_SetTranslation(TID_EXTRA+plynum, -1);
    MorphActor(TID_PLAYER+plynum, class, 1, minigame_timer, MRF_NEWTIDBEHAVIOUR, "Nothing", "Nothing");
    if (game_wackymod == WACKYMOD_INVERT && GetActorProperty(0, APROP_Speed) > 0)
        SetActorProperty(0, APROP_Speed, -GetActorProperty(0, APROP_Speed));
}

function void Player_FreezeTotally(int who) // Totally freezes the player without messing with other freezes
{
    SetPlayerProperty(who, 1, PROP_TOTALLYFROZEN);

    if (who == 0)
        player_frozen[PlayerNumber()] = true;
    else
        for (int i=0; i<MAXPLAYERS; i++)
            player_frozen[i] = true;
}

function void Player_UnFreezeTotally(int who) // Totally unfreezes the player without messing with other freezes
{
    int i;
    if (who == 0 && !player_viewingmenu[PlayerNumber()])
        SetPlayerProperty(who, 0, PROP_TOTALLYFROZEN);
    else if (who == 1)
         for (i=0; i<MAXPLAYERS; i++)
            if (!player_viewingmenu[i])
                SetPlayerProperty(who, 0, PROP_TOTALLYFROZEN);

    if (who == 0)
        player_frozen[PlayerNumber()] = false;
    else
        for (i=0; i<MAXPLAYERS; i++)
            player_frozen[i] = false;
}

function void Give_Achievement(int plynum, int achievement) // Gives the player an achievement
{
	int active = ActivatorTID();
	str name = "";
	
	if (!PlayerInGame(plynum))
		return;
	
    if ((PlayerIsLoggedIn(plynum) || GetCVar("doomware_unsafedb")) && game_status != STATUS_NOTSTARTED && !game_solo && (data_achieve[plynum] & (1<<achievement)) == 0)
    {
        data_achieve[plynum] = data_achieve[plynum] | (1<<achievement);
        switch(achievement)
        {
            case ACHIEVE_ID_1WIN:       name = ACHIEVE_NAME_1WIN; Break;
            case ACHIEVE_ID_10WIN:      name = ACHIEVE_NAME_10WIN; Break;
            case ACHIEVE_ID_50WIN:      name = ACHIEVE_NAME_50WIN; Break;
            case ACHIEVE_ID_25POINTS:   name = ACHIEVE_NAME_25POINTS; Break;
            case ACHIEVE_ID_1V1WIN:     name = ACHIEVE_NAME_1V1WIN; Break;
            case ACHIEVE_ID_MVMWIN:     name = ACHIEVE_NAME_MVMWIN; Break;
            case ACHIEVE_ID_501UPS:     name = ACHIEVE_NAME_501UPS; Break;
            case ACHIEVE_ID_100DEATH:   name = ACHIEVE_NAME_100DEATH; Break;
            case ACHIEVE_ID_300POINTS:  name = ACHIEVE_NAME_300POINTS; Break;
            case ACHIEVE_ID_WRONGDOOR:  name = ACHIEVE_NAME_WRONGDOOR; Break;
            case ACHIEVE_ID_LONGJUMP:   name = ACHIEVE_NAME_LONGJUMP; Break;
            case ACHIEVE_ID_3FRAGS:     name = ACHIEVE_NAME_3FRAGS; Break;
            case ACHIEVE_ID_BULLETHELL: name = ACHIEVE_NAME_BULLETHELL; Break;
            case ACHIEVE_ID_KARTWIN:    name = ACHIEVE_NAME_KARTWIN; Break;
            case ACHIEVE_ID_ATST:       name = ACHIEVE_NAME_ATST; Break;
            case ACHIEVE_ID_BOSS:       name = ACHIEVE_NAME_BOSS; Break;
            case ACHIEVE_ID_BADAIM:     name = ACHIEVE_NAME_BADAIM; Break;
            case ACHIEVE_ID_FULLSERVER: name = ACHIEVE_NAME_FULLSERVER; Break;
            default: break;
        }
        ACS_NamedExecuteAlways("DoomWare_AchievementLog", 0, plynum, name); // We can't do Log() serverside, so this is a workaround

        // Notify the achievement got received
        SetActivatorToPlayer(plynum);
        SpawnSpotForced("ConfettiEffect", TID_PLAYER+plynum, 0, 0);
        SetFont("DW_FONT1");
        if (game_status != STATUS_NOTSTARTED && name != "")
        {
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            str hudsprite;
            if (GetUserCVar(PlayerNumber(), "doomware_hudscale"))
            {
                w = 800;
                h = 600;
            }
            SetHudSize(w, h, true);
            w = w << 16;
            h = h << 16;
            HUDMessage(s:"Achievement Unlocked!\n", s:name; HUDMSG_FADEOUT, MSGID_ACHIEVEM, CR_CYAN, w/2 + 0.4, FixedMul(h, 0.8) + 0.2, 1.0, 1.0);
            if (GetUserCvar(PlayerNumber(), "doomware_hudsounds"))
                LocalAmbientSound("DoomWare/Achievement", 127);
        }
		
		// Reset the activator to prevent problems
		if (active < TID_PLAYER)
			SetActivator(0, AAPTR_NULL);
		else
			SetActivatorToPlayer(active-TID_PLAYER);
        
        // Give the achiever role if this person unlocked all the achievements
        if (data_achieve[plynum] == 0x3FFFF && data_role[plynum] != ROLE_BETA && data_role[plynum] != ROLE_BUU342)
            data_role[plynum] = ROLE_ACHIEVER;
    }
}


/*===================================================================================================
                                         Variable Networking
===================================================================================================*/

Script "DoomWare_Server_SyncGlobals" (void) // Global variable networking "thread".
{
    /*
        Why on earth are global variables not synced between the server and
        CLIENTSIDE scripts??? Pretty much every single game engine I've worked on
        At least gives me the option of marking a variable as "Syncable" to the
        client...
    */
    str leadname = StrParam(n:(game_highnames[0]+1));
    Player_SetCVar("__clientsync_round", game_roundnum);
    Player_SetCVar("__clientsync_gamestatus", game_status);
    Player_SetCVar("__clientsync_gameover", game_over);
    Player_SetCVar("__clientsync_minigametimer", minigame_timer);
    Player_SetCVar("__clientsync_wincondition1", minigame_wincondition1);
    Player_SetCVarString("__clientsync_highname", leadname);
    Player_SetCVarString("__clientsync_speeduphint", round_hints[game_speed-1]);
    Player_SetCVar("__clientsync_canobserve", minigame_canobserve);
    Player_SetCVar("__clientsync_canmove", minigame_canmove);
    Player_SetCVar("__clientsync_gamesolo", game_solo);
    Player_SetCVar("__clientsync_roundcurrent", round_current[game_roundnum-1]);
    Player_SetCVar("__clientsync_wackymod", game_wackymod);
    Player_SetCVar("__clientsync_teams", game_teams);
    
    // Sync the team scores, or the top 2 scores if we're not in a team mode
    if (game_teams)
    {
        Player_SetCVar("__clientsync_highscore1", game_scoreteams[TEAM_BLUE]);
        Player_SetCVar("__clientsync_highscore2", game_scoreteams[TEAM_RED]);
    }
    else
    {
        Player_SetCVar("__clientsync_highscore1", game_highscores[0]);
        Player_SetCVar("__clientsync_highscore2", game_highscores[1]);
    }

    // Pack player data
    Pack_Global_Array("__clientsync_player_score");
    Pack_Global_Array("__clientsync_player_loggedin");
    Pack_Global_Array("__clientsync_player_datascore");
    Pack_Global_Array("__clientsync_player_datawins");
    Pack_Global_Array("__clientsync_player_datadeaths");
    Pack_Global_Array("__clientsync_player_data1ups");
    Pack_Global_Array("__clientsync_player_dataroles");
    Pack_Global_Array("__clientsync_player_dataachieve");
    Pack_Global_Array("__clientsync_player_databosskills");
    Pack_Global_Array("__clientsync_player_checklost");
    Pack_Global_Array("__clientsync_player_lostround");
    Pack_Global_Array("__clientsync_player_viewingmenu");
    Pack_Global_Array("__clientsync_player_instruction1");
    Pack_Global_Array("__clientsync_player_instruction2");
    Pack_Global_Array("__clientsync_player_instruction3");
    Pack_Global_Array("__clientsync_player_viewsprite");

    delay(1);
    restart;
}

function void DB_NetworkStats(str namespace, str cvarname) // Updates the global stats variables to network to clients
{
    int stat_t = 0;
    int stat_g = 0;
    int stat_n = "Multiple Players";
    int res = GetDBEntries(namespace);
    int c = CountDBResults(res);
    if (c != 0)
    {
        FreeDBResults(res);
        res = SortDBEntries(namespace, c, 0, true);
        if (GetDBResultValue(res, 0) != GetDBResultValue(res, 1))
            stat_n = GetDBResultKeyString(res, 0);
        for (int i=0; i<c; i++)
            stat_g += GetDBResultValue(res, i);
        stat_t = GetDBResultValue(res, 0);
        
        Player_SetCVar(StrParam(s:"__clientsync_stats_t_", s:cvarname), stat_t);
        Player_SetCVar(StrParam(s:"__clientsync_stats_g_", s:cvarname), stat_g);
        Player_SetCVarString(StrParam(s:"__clientsync_stats_n_", s:cvarname), stat_n);
    }
    FreeDBResults(res);
}

function void Player_SetCVar(str cvar, int value) // Efficient SetCVar function
{
    if (GetCVar(cvar) != value)
        SetCVar(cvar, value);
}

function void Player_SetCVarString(str cvar, str value) // Efficient SetCVarString function
{
    if (StrCmp(GetCVarString(cvar), value))
        SetCVarString(cvar, value);
}

function void Pack_Global_Array(str cvar) // Replacement for Get/SetUserCVar
{
    /*
        Since GetUserCVar is broken on Zandronum, instead I fill everyone's data into a single
        string and make it a server cvar. A new line represents a different player, so the data
        in line 3 of the string corresponds to the data of PlayerNumber() == 3
    */
    int i;
    str final = "";
    
    /* 
        Super ugly hack!
        Strings in ACS are pretty much just integers that point to a string table. This means that
        You can do string comparisons in a switch statement! Literally O(1) string comparisons!
    */
    switch (cvar)
    {
        case "__clientsync_player_score":         for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:game_score[i], s:"\n"); break;
        case "__clientsync_player_loggedin":      for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:(PlayerIsLoggedIn(i) || GetCVar("doomware_unsafedb")), s:"\n"); break;
        case "__clientsync_player_datascore":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_points[i], s:"\n"); break;
        case "__clientsync_player_datawins":      for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_wins[i], s:"\n"); break;
        case "__clientsync_player_datadeaths":    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_deaths[i], s:"\n"); break;
        case "__clientsync_player_data1ups":      for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_1ups[i], s:"\n"); break;
        case "__clientsync_player_dataroles":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_role[i], s:"\n"); break;
        case "__clientsync_player_dataachieve":   for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_achieve[i], s:"\n"); break;
        case "__clientsync_player_databosskills": for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:data_bosskills[i], s:"\n"); break;
        case "__clientsync_player_checklost":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:Check_Player_Lost(i), s:"\n"); break;
        case "__clientsync_player_lostround":     for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:player_lostround[i], s:"\n"); break;
        case "__clientsync_player_viewingmenu":   for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, d:player_viewingmenu[i], s:"\n"); break;
        case "__clientsync_player_instruction1":  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction1[i], s:"\n"); break;
        case "__clientsync_player_instruction2":  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction2[i], s:"\n"); break;
        case "__clientsync_player_instruction3":  for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:minigame_instruction3[i], s:"\n"); break;
        case "__clientsync_player_viewsprite":    for (i=0; i< MAXPLAYERS; i++) final = StrParam(s:final, s:player_viewsprite[i], s:"\n"); break;
    }

    if (StrCmp(GetCVarString(cvar), final))
        SetCVarString(cvar, final);
}

function int Unpack_CVar_Array(str cvar) // Retrieve the value of a Pack_Global_Array CVar and convert it to int.
{
    str data = GetCVarString(cvar);
    int datalen = StrLen(data);

    int start = 0;
    int linecount = 0;

    for (int i=0; i<datalen; i++)
    {
        if (GetChar(data, i) == '\n')
        {
            if (linecount == ConsolePlayerNumber())
            {
                data = StrMid(data, start, i-start);
                break;
            }
            else
            {
                start = i+1;
                linecount++;
            }

        }
    }
    return AToI(data);
}

function str Unpack_CVar_Array_String(str cvar) // Retrieve the value of a Pack_Global_Array CVar and convert it to string.
{
    str data = GetCVarString(cvar);
    int datalen = StrLen(data);

    int start = 0;
    int linecount = 0;

    for (int i=0; i<datalen; i++)
    {
        if (GetChar(data, i) == '\n')
        {
            if (linecount == ConsolePlayerNumber())
            {
                data = StrMid(data, start, i-start);
                break;
            }
            else
            {
                start = i+1;
                linecount++;
            }

        }
    }
    return data;
}


/*===================================================================================================
                                           Highscore table
===================================================================================================*/

// This is using a number rather than a named script to make binding the puke easier
Script 257 (void) NET // Highscore table bind
{
    // Start a solo match if the game hasn't started
    if (game_status == STATUS_NOTSTARTED && PlayerCount() == 1)
        game_solo = true;

    // Don't open the highscore table if it's a solo game or if not ready
    if (game_solo || game_status == STATUS_STARTING)
        terminate;

    // Toggle the scoreboard visibility
    if (player_viewingscore[PlayerNumber()] == false)
        player_viewingscore[PlayerNumber()] = true;
    else
        player_viewingscore[PlayerNumber()] = false;

    // Draw the scoreboard
    ACS_NamedExecuteAlways("DoomWare_Client_DrawHighscore", 0);
}

int lastteamscore[MAXTEAMS];
script "DoomWare_Server_CalcHighscore" (void) // A "thread" which continually updates the highscore table
{
	while (1)
	{
		int i, j;

		// Fill the highscore list with the players that are ingame
		for (i=0; i<MAXPLAYERS; i++)
		{
			game_highscores[i] = game_score[i];
			game_highnames[i] = i;

			if (PlayerInGame(i) == false)
			{
				game_highscores[i] = -1;
				game_highnames[i] = -1;
			}
		}

		// Order the list based on who has the highest score
		for (i=0; i<MAXPLAYERS; i++)
		{
			for (j=1; j<MAXPLAYERS-i; j++)
			{
				int temp_value;
				if (game_highscores[j-1] < game_highscores[j])
				{
					temp_value = game_highscores[j-1];
					game_highscores[j-1] = game_highscores[j];
					game_highscores[j] = temp_value;

					temp_value = game_highnames[j-1];
					game_highnames[j-1] = game_highnames[j];
					game_highnames[j] = temp_value;
				}
			}
		}
		
		// Update team scores
		game_scoreteams[TEAM_BLUE] = game_extrascoreteams[TEAM_BLUE];
		game_scoreteams[TEAM_RED] = game_extrascoreteams[TEAM_RED];
		if (game_teams)
		{    
			for (j=0; j<PlayerCount(); j++)
			{
				int team = GetPlayerInfo(game_highnames[j], PLAYERINFO_TEAM);
				game_scoreteams[team] += game_highscores[j];
			}
		}
		
		// If a player disconnected, fix the score (hacky, because we can't get player teams in DISCONNECT scripts)
		if (game_extrascoreteams[MAXTEAMS] != 0)
		{
			for (i=0; i<MAXTEAMS; i++)
			{
				if (lastteamscore[i] > game_scoreteams[i])
				{
					game_extrascoreteams[i] += game_extrascoreteams[MAXTEAMS];
					game_extrascoreteams[MAXTEAMS] = 0;
					break;
				}
			}
		}
		
		// Store the team's last score
		for (i=0; i<MAXTEAMS; i++)
			lastteamscore[i] = game_scoreteams[i];

		// Restart this script
		delay(1);
    }
}

Script "DoomWare_Client_DrawHighscore" (void) // Draws the highscore table for the activator
{
	str extrascore = "";
    int i;
    if (player_viewingscore[PlayerNumber()] == true)
    {
        int hud_y_counter = 0;
		bool hasextrascore = false;
		
		// Check extra team score
		for (i=0; i<MAXTEAMS; i++)
		{
			if (game_extrascoreteams[i] != 0)
			{
				str col = "";
				switch(i)
				{
					case TEAM_BLUE:
						col = "\chBlue: ";
						break;
					case TEAM_RED:
						col = "\cgRed: ";
						break;
				}
				extrascore = StrParam(s:extrascore, s:" ", s:col, d:game_extrascoreteams[i]);
				hasextrascore = true;
			}
		}
		
		// If we're displaying extra score and we've got a full game, move the names up a bit
		if (hasextrascore && PlayerCount() == MAXPLAYERS)
			hud_y_counter = -6;

        // Initialize the GUI
        SetHudSize(800, 600, false);

        // Draw the background
        SetFont("SCRBRDB");
        HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_HSBACK, CR_ORANGE, 400.0, 300.0, 1);

        // Draw each player's score
        SetFont("DW_FONT3");
        for (i=0; i<MAXPLAYERS; i++)
        {
            // If the player is ingame
            if (game_highscores[i] != -1)
            {
                int color = CR_ORANGE;
                
                // Switch the color if the player is in a team
                switch (GetPlayerInfo(game_highnames[i], PLAYERINFO_TEAM))
                {
                    case TEAM_RED:
                        color = CR_RED;
                        break;
                    case TEAM_BLUE:
                        color = CR_BLUE;
                        break;
                }
                
                // Draw the person's name and move the y position lower
                HUDMessage(d:game_highscores[i], s:" ", n:game_highnames[i]+1; HUDMSG_PLAIN, MSGID_HSPLAYR+i, color, 400.0, 216.0+hud_y_counter, 1);
                hud_y_counter +=13.0;
            }
            else
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 200.0+hud_y_counter, 1);
        }
		
		// Draw extra team score
		if (hasextrascore)
			HUDMessage(s:"Extra score:", s:extrascore; HUDMSG_PLAIN, MSGID_HSPLAYR+MAXPLAYERS, CR_ORANGE, 400.0, 210.0+208.0, 1);
        SetHudSize(0, 0, false);

        // Restart the script to keep drawing the scoreboard
        delay(1);
        if (PlayerInGame(PlayerNumber())) // Unless the player disconnected
            restart;
    }
    else
    {
        // Overwrite the scoreboard with blank if it's not being viewed anymore
        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSBACK, CR_ORANGE, 0.5, 0.5, 1);
        for (i=0; i<MAXPLAYERS+1; i++)
            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_HSPLAYR+i, CR_ORANGE, 400.0, 200.0+hud_y_counter, 1);
    }
}


/*===================================================================================================
                                           Observer System
===================================================================================================*/

function void Add_Observer(int TID) // Adds a camera to the observers list
{
    if (!game_solo || (game_solo && round_forceobservers))
    {
        minigame_canobserve = true;
        for (int i=0; i<NUMOBSERVERS; i++)
            if (round_observers[i] == -1)
            {
                round_observers[i] = TID;
                break;
            }
    }
}

function void Force_Observe(int plynum) // Forces a player to observe a camera in the above list
{
    player_observe[PlayerNumber()]++;
    ChangeCamera(round_observers[0], 0, 0);
}

Script "DoomWare_Server_ClearObservers" (void) // Clears the observers list
{
    int i;

    // Disable minigame observation
    for (i=0; i<NUMOBSERVERS; i++)
        round_observers[i] = -1;
    minigame_canobserve = false;

    // Remove everyone's observation
    for (i=0; i<MAXPLAYERS; i++)
        player_observe[i] = 0;
    ChangeCamera(0, 1, 0);
}

Script 988 (void) NET // Observe minigame bind
{
    if (game_status > STATUS_STARTING)
    {
        if (minigame_canobserve == true && player_lostround[PlayerNumber()])
        {
            if (round_observers[player_observe[PlayerNumber()]] != -1)
            {
                player_observe[PlayerNumber()]++;
                ChangeCamera(round_observers[player_observe[PlayerNumber()]-1], 0, 0);
            }
            else
            {
                ChangeCamera(0, 0, 0);
                player_observe[PlayerNumber()] = 0;
            }
        }
    }
}


/*===================================================================================================
                                            DoomWare Menu
===================================================================================================*/

Script 999 (void) NET // Menu toggle bind
{
    // Toggle the scoreboard visibility
    if (player_viewingmenu[PlayerNumber()] == false)
    {
        player_viewingmenu[PlayerNumber()] = true;
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
    }
    else
    {
        player_viewingmenu[PlayerNumber()] = false;

        // Unfreeze the player (as long as the game lets them)
        if (!player_frozen[PlayerNumber()])
            SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
    }
}

Script "DoomWare_Client_DrawMenu" (void) CLIENTSIDE // Draws the DoomWare menu for the activator
{
    // Make sure only the person who called it actually opens the menu
    if (ConsolePlayerNumber() != PlayerNumber())
        terminate;

    SetActivator(TID_PLAYER+ConsolePlayerNumber());

    // Initialize a bunch of variables
    int i;
    int x = GetScreenWidth() / 2;
    int y = GetScreenHeight() / 2;
    int x_sensitivity = 1.0;
    int y_sensitivity = 1.0;
    int dx;
    int dy;
    int tab = 1;
    int plynum = ConsolePlayerNumber();
    bool menu_wasopen = false;
    
    // Initialize global top stats variables
    int topstat_wins = GetCVar("__clientsync_stats_t_wins");
    int topstat_score = GetCVar("__clientsync_stats_t_points");
    int topstat_1ups = GetCVar("__clientsync_stats_t_1ups");
    int topstat_deaths = GetCVar("__clientsync_stats_t_deaths");
    int topstat_bosskills = GetCVar("__clientsync_stats_t_bosses");
    int topstat_g_wins = GetCVar("__clientsync_stats_g_wins");
    int topstat_g_score = GetCVar("__clientsync_stats_g_points");
    int topstat_g_1ups = GetCVar("__clientsync_stats_g_1ups");
    int topstat_g_deaths = GetCVar("__clientsync_stats_g_deaths");
    int topstat_g_bosskills = GetCVar("__clientsync_stats_g_bosses");
    str topstat_n_wins = GetCVarString("__clientsync_stats_n_wins");
    str topstat_n_score = GetCVarString("__clientsync_stats_n_points");
    str topstat_n_1ups = GetCVarString("__clientsync_stats_n_1ups");
    str topstat_n_deaths = GetCVarString("__clientsync_stats_n_deaths");
    str topstat_n_bosskills = GetCVarString("__clientsync_stats_n_bosses");

    // Start the menu drawing loop
    while (1)
    {
        int menuopen = Unpack_CVar_Array("__clientsync_player_viewingmenu");
        if (menuopen == 1)
        {
            menu_wasopen = true;
            bool changedtab = false;
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            bool moving_mouse = true;

            if (GetUserCVar(plynum, "doomware_hudscale"))
            {
                w = 800;
                h = 600;
            }
            SetHUDSize(w, h, true);

            w = w << 16;
            h = h << 16;

            // Get input
            dx = FixedMul(x_sensitivity, GetPlayerInput(plynum, INPUT_YAW)) / 24;
            dy = FixedMul(y_sensitivity, GetPlayerInput(plynum, INPUT_PITCH)) / 12;
            if (dy == 0)
            {
                dy = -GetPlayerInput(plynum, INPUT_FORWARDMOVE) / 1200;
                moving_mouse = false;
            }

            // Move the mouse
            x -= dx;
            if (moving_mouse && !GetCVar("invertmouse"))
                y -= dy;
            else
                y += dy;

            // Prevent the mouse from escaping
            if (x < 0)
                x = 0;
            if (x > w>>16)
                x = w>>16;
            if (y < 0)
                y = 0;
            if (y > h>>16)
                y = h>>16;

            // Allow changing tabs
            if ((y <= (h/2-220.0)>>16 && y >= (h/2-240.0)>>16) && (x >= (w/2 - 318.00)>>16 && x <= (w/2 + 318.00)>>16))
            {
                int input = GetPlayerInput(plynum, INPUT_BUTTONS);
                int oldinput = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
                if (!(oldinput & (BT_USE|BT_ATTACK)) && (input & (BT_USE|BT_ATTACK)))
                {
                    int oldtab = tab;
                    tab = 1+((x-(((w/2)-318.0)>>16))/106);
                    if (tab != oldtab)
                    {
                        changedtab = true;
                        if (GetUserCVar(plynum, "doomware_hudsounds"))
                            AmbientSound("DoomWare/MenuTab", 127);
                    }

                    if (tab == 6)
                        RequestScriptPuke(999);
                }
            }

            // Draw the mouse
            SetFont("CURSOR");
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_CURSOR, CR_WHITE, (x<<16)+2.0+0.1, (y<<16)+2.0+0.1, 1);

            // Handle each tab
            switch(tab)
            {
                case 1:
                    SetFont("DW_FONT3");
                    HUDMessage(s:WELCOME; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2-322.0 + 0.1, h/2 + 28.0 + 0.1, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
                case 2:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"                                    ", s:CHANGES,
                        s:"\n\n\nCurrent number of minigames: ", d:NUMBEROFGAMES,
                        s:"\nCurrent number of tie breakers (1v1): ", d:NUMBEROFTIEBREAKERS,
                        s:"\nCurrent number of tie breakers (non 1v1): ", d:NUMBEROFTIEBREAKERSM,
                        s:"\nCurrent number of wackymods: ", d:NUMBEROFWACKYMODS;
                        HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2-312.0 + 0.1, h/2 - 200.0 + 0.1, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
                case 3:
                    SetFont("DW_FONT3");
                    int syncdata_loggedin = Unpack_CVar_Array("__clientsync_player_loggedin");
                    
                    // Print global and top stats
                    HUDMessage(s:"\ckGlobal Stats\c-\n\n",
                        s:"Games Played\n", d:topstat_g_wins,
                        s:"\n\nPoints Given\n", d:topstat_g_score,
                        s:"\n\n1-Ups Collected\n", d:topstat_g_1ups,
                        s:"\n\nTotal Deaths\n", d:topstat_g_deaths,
                        s:"\n\nBosses Defeated\n", d:topstat_g_bosskills,
                        s:"\n\n\n\ckThese stats update\n\ckon map start\c-"
                        ; HUDMSG_PLAIN, MSGID_MELEM+2, CR_WHITE, w/2-220.0 + 0.4, h/2 - 200.0 + 0.1, 1);
                    HUDMessage(s:"\ckTop Stats\c-\n\n",
                        s:"Game Wins\n", s:topstat_n_wins, s:" (", d:topstat_wins, s:")",
                        s:"\n\nPoints Received\n", s:topstat_n_score, s:" (", d:topstat_score, s:")",
                        s:"\n\n1-Ups Collected\n", s:topstat_n_1ups, s:" (", d:topstat_1ups, s:")",
                        s:"\n\nTotal Deaths\n", s:topstat_n_deaths, s:" (", d:topstat_deaths, s:")",
                        s:"\n\nBosses Defeated\n", s:topstat_n_bosskills, s:" (", d:topstat_bosskills, s:")",
                        s:"\n\n\n\ckThese stats update\n\ckon map start\c-"
                        ; HUDMSG_PLAIN, MSGID_MELEM+1, CR_WHITE, w/2+220.0 + 0.4, h/2 - 200.0 + 0.1, 1);
                    
                    // Display player stats based on whether they're logged in or not
                    if (syncdata_loggedin >= 1)
                    {
                        int syncdata_score = Unpack_CVar_Array("__clientsync_player_score");
                        int syncdata_totalpoints = Unpack_CVar_Array("__clientsync_player_datascore");
                        int syncdata_wins = Unpack_CVar_Array("__clientsync_player_datawins");
                        int syncdata_deaths = Unpack_CVar_Array("__clientsync_player_datadeaths");
                        int syncdata_1ups = Unpack_CVar_Array("__clientsync_player_data1ups");
                        int syncdata_role = Unpack_CVar_Array("__clientsync_player_dataroles");
                        int syncdata_achieve = Unpack_CVar_Array("__clientsync_player_dataachieve");
                        int syncdata_bosskills = Unpack_CVar_Array("__clientsync_player_databosskills");
                        str role;
                        switch (syncdata_role)
                        {
                            case ROLE_NONE:
                                role = "None";
                                break;
                            case ROLE_REGULAR:
                                role = "\cgVeteran\c-";
                                break;
                            case ROLE_ACHIEVER:
                                role = "\cnOver Achiever\c-";
                                break;
                            case ROLE_BETA:
                                role = "\cfBeta Tester\c-";
                                break;
                            case ROLE_BUU342:
                                role = "\cqG\csO\cdD";
                                break;
                        }
                        HUDMessage(s:"\ckYour Stats\c-\n\n",
                            s:"Game Wins\n", d:syncdata_wins,
                            s:"\n\nPoints Received\n", d:(syncdata_score + syncdata_totalpoints),
                            s:"\n\n1-Ups Collected\n", d:syncdata_1ups,
                            s:"\n\nTotal Deaths\n", d:syncdata_deaths,
                            s:"\n\nBosses Defeated\n", d:syncdata_bosskills,
                            s:"\n\nRank\n", s:role
                            ; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.4, h/2 - 200.0 + 0.1, 1);

                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_1WIN,       ACHIEVE_NAME_1WIN,       ACHIEVE_DESC_1WIN, "ACH_WINO", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_10WIN,      ACHIEVE_NAME_10WIN,      ACHIEVE_DESC_10WIN, "ACH_WINT", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_50WIN,      ACHIEVE_NAME_50WIN,      ACHIEVE_DESC_50WIN, "ACH_WINH", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_25POINTS,   ACHIEVE_NAME_25POINTS,   ACHIEVE_DESC_25POINTS, "ACH_25PN", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_1v1WIN,     ACHIEVE_NAME_1v1WIN,     ACHIEVE_DESC_1v1WIN, "ACH_1V1W", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_MVMWIN,     ACHIEVE_NAME_MVMWIN,     ACHIEVE_DESC_MVMWIN, "ACH_MVMW", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_501UPS,     ACHIEVE_NAME_501UPS,     ACHIEVE_DESC_501UPS, "ACH_1UPF", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_100DEATH,   ACHIEVE_NAME_100DEATH,   ACHIEVE_DESC_100DEATH, "ACH_DEDH", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_300POINTS,  ACHIEVE_NAME_300POINTS,  ACHIEVE_DESC_300POINTS, "ACH_300P", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_WRONGDOOR,  ACHIEVE_NAME_WRONGDOOR,  ACHIEVE_DESC_WRONGDOOR, "ACH_COLR", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_LONGJUMP,   ACHIEVE_NAME_LONGJUMP,   ACHIEVE_DESC_LONGJUMP, "ACH_1UPS", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_3FRAGS,     ACHIEVE_NAME_3FRAGS,     ACHIEVE_DESC_3FRAGS, "ACH_3FRG", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BULLETHELL, ACHIEVE_NAME_BULLETHELL, ACHIEVE_DESC_BULLETHELL, "ACH_BULL", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_KARTWIN,    ACHIEVE_NAME_KARTWIN,    ACHIEVE_DESC_KARTWIN, "ACH_KART", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_ATST,       ACHIEVE_NAME_ATST,       ACHIEVE_DESC_ATST, "ACH_ATST", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BOSS,       ACHIEVE_NAME_BOSS,       ACHIEVE_DESC_BOSS, "ACH_BOSS", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_BADAIM,     ACHIEVE_NAME_BADAIM,     ACHIEVE_DESC_BADAIM, "ACH_AIMB", plynum, x, y, w, h);
                        Handle_Menu_Achievement(syncdata_achieve, ACHIEVE_ID_FULLSERVER, ACHIEVE_NAME_FULLSERVER, ACHIEVE_DESC_FULLSERVER, "ACH_FULL", plynum, x, y, w, h);
                    }
                    else
                    {
                        HUDMessage(s:"\ckYour Stats\n\n", s:LOGIN; HUDMSG_PLAIN, MSGID_MELEM, CR_RED, w/2 + 0.4, h/2 - 200.0 + 0.1, 1);

                        // Clear unused elements
                        if (changedtab)
                            for (i=3; i<MELEMENTS; i++)
                                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    }
                    break;
                case 4:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"Click the switch to toggle the console command"; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.0, h/2 - 200.0 + 0.1, 1);
                    Handle_Menu_Option(0, "doomware_hudscale", "Force large HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(1, "doomware_hudwide", "Widescreen large HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(2, "doomware_hudsounds", "Allow the HUD to emit sound effects", plynum, x, y, w, h);
                    Handle_Menu_Option(3, "doomware_huddynamic", "Allow the HUD to move dynamically", plynum, x, y, w, h);
                    Handle_Menu_Option(4, "doomware_hudshowbinds", "Show your binds on the game HUD", plynum, x, y, w, h);
                    Handle_Menu_Option(5, "doomware_loginwarn", "Warn you that you're not logged in", plynum, x, y, w, h);
                    Handle_Menu_Option(6, "doomware_music", "Enable DoomWare music (such as winning/losing)", plynum, x, y, w, h);
                    Handle_Menu_Option(7, "doomware_invertfly", "Invert Y axis on flight controls", plynum, x, y, w, h);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);

                    //Handle_Menu_Option(6, "doomware_joinmenu", "Open this menu upon connecting to a game", PlayerNumber(), x, y, w, h);
                    break;
                case 5:
                    SetFont("DW_FONT3");
                    HUDMessage(s:"\cgA wad by \cqB\csu\cdu\cq3\cs4\cd2\c-\n\n",
                        s:"Based on the Nintendo game series WarioWare, all rights reserved\n",
                        s:"Credit for all used assets are provided within the wad's data\n\n",
                        s:"\cvPlease report any bugs you encounter to:\n",
                        s:"\cvbuu342@hotmail.com\n",
                        s:"\cvAlternatively, bugs can be reported on the Doomworld or Zandronum\n",
                        s:"\cvDoomWare thread.\n",
                        s:"\cvOr use the GitHub page!\n",
                        s:"https://github.com/buu342/ACS-DoomWare"; HUDMSG_PLAIN, MSGID_MELEM, CR_WHITE, w/2 + 0.4, h/2 + 0.0, 1);

                    // Clear unused elements
                    if (changedtab)
                        for (i=1; i<MELEMENTS; i++)
                            HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                    break;
            }

            // Draw the background
            SetFont(StrParam(s:"MENU", d:tab));
            HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MENU, CR_WHITE, w/2+0.0, h/2+0.0, 1);
        }
        else
        {
            if (menu_wasopen)
            {
                for (i=0; i<MELEMENTS; i++)
                    HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+i, CR_WHITE, 0.0, 0.0, 1);
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MENU, CR_WHITE, 0.0, 0.0, 0);
                HUDMessage(s:""; HUDMSG_PLAIN, MSGID_CURSOR, CR_WHITE, 0.0, 0.0, 0);
                menu_wasopen = false;
                tab = 1;
            }
        }

        // Restart the script to keep drawing the menu
        delay(1);

        if (!PlayerInGame(plynum))
            terminate;
    }
}

function void Handle_Menu_Option(int number, str command, str desc, int plynum, int mouse_x, int mouse_y, int w, int h) // Handles drawing and clicking of menu options 
{
    int x = w/2-312.0 + 0.1;
    int y = h/2-180.0 + (number)*48.0 + 0.1;
    int oldbutton = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
    int button = GetPlayerInput(plynum, INPUT_BUTTONS);

    // Draw the button
    if (GetUserCVar(plynum, command))
        SetFont("SOTESCHY");
    else
        SetFont("SOTESCHN");
    HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MELEM+(number+1)*2, CR_WHITE, x, y, 1);
    SetFont("DW_FONT3");
    HUDMessage(s:command, s:"\n", s:desc; HUDMSG_PLAIN, MSGID_MELEM+1+(number+1)*2, CR_GOLD, x + 48.0, y + 5.0, 1);

    // Handle the button clicking
    if ((mouse_x >= x>>16 && mouse_x <= (x+32.0)>>16) && (mouse_y >= y>>16 && mouse_y <= (y+32.0)>>16)) // If the mouse is within the button's bounds
        if (!oldbutton & (BT_ATTACK|BT_USE) && button & (BT_ATTACK|BT_USE)) // If the player has pressed the button
        {
            // toggle the command
            SetUserCVar(plynum, command, !GetUserCVar(plynum, command));

            // Play a sound
            if (GetUserCVar(plynum, "doomware_hudsounds"))
                AmbientSound("DoomWare/MenuSwitch", 127);
        }
}

function void Handle_Menu_Achievement(int achieve_data, int number, str name, str desc, str sprite, int plynum, int mouse_x, int mouse_y, int w, int h) // Handles the drawing of the achievements
{
    int x = w/2-312.0 + (number%9)*70.0 + 0.1;
    int y = h/2+98.0 + (number/9)*70.0 + 0.1;
    int oldbutton = GetPlayerInput(plynum, INPUT_OLDBUTTONS);
    int button = GetPlayerInput(plynum, INPUT_BUTTONS);
    int unlocked = achieve_data & (1<<(number));

    // Show the achievement sprite if unlocked
    if (unlocked)
        SetFont(sprite);
    else
        SetFont("ACH_NONE");
    HUDMessage(s:"A"; HUDMSG_PLAIN, MSGID_MELEM+3+number*2, CR_WHITE, x, y, 1);
    SetFont("DW_FONT3");

    // Handle the button clicking
    if ((mouse_x >= x>>16 && mouse_x <= (x+64.0)>>16) && (mouse_y >= y>>16 && mouse_y <= (y+64.0)>>16)) // If the mouse is within the button's bounds
    {
        if (unlocked)
            HUDMessage(s:name, s:"\n", s:desc; HUDMSG_PLAIN, MSGID_MELEM+3+number*2+1, CR_GOLD, w/2 + 0.4, h/2+72.0, 1);
        else
            HUDMessage(s:"???", s:"\n", s:"This achievement is locked"; HUDMSG_PLAIN, MSGID_MELEM+3+number*2+1, CR_RED, w/2 + 0.4, h/2+72.0, 1);
    }
    else
    {
        HUDMessage(s:""; HUDMSG_PLAIN, MSGID_MELEM+3+number*2+1, CR_WHITE, w/2 + 0.0, h/2+64.0, 1);
    }
}


/*===================================================================================================
                                                Hats
===================================================================================================*/

#define BETATESTERSIZE 9
str BetaTesterList[BETATESTERSIZE];
function bool IsBetaTester(int plynum) // Returns true/false if the player is a beta tester
{
    BetaTesterList[0] = "asriel";
    BetaTesterList[1] = "margsabl";
    BetaTesterList[2] = "marcaek";
    BetaTesterList[3] = "doomer9000";
    BetaTesterList[4] = "deanyktru";
    BetaTesterList[5] = "dsparil";
    BetaTesterList[6] = "flambeau";
    BetaTesterList[7] = "dastan";
    BetaTesterList[8] = "combinebobnt";

    for (int i=0; i<BETATESTERSIZE; i++)
        if (!StrCmp(BetaTesterList[i], GetPlayerAccountName(i)))
            return true;
    return false;
}

Script "DoomWare_Server_Hats" (void) // A "thread" that handles all the player hats
{
    int z;

    // If not a solo game
    if (!game_solo)
    {
        // Leader hat (if there is a leader and not a team game)
        if (!game_teams && game_highscores[0] > game_highscores[1] && game_status != STATUS_GAMEOVER && !(GetActorProperty(TID_PLAYER+0, APROP_Health) <= 0))
        {
            if (ThingCount(0, TID_HATGAME) == 0)
                SpawnSpotForced("LeaderHat", 1, TID_HATGAME, 0);

            z = 64.0;
            if (data_role[game_highnames[0]] > ROLE_NONE)
                z = 84.0;
            SetActorPosition(TID_HATGAME, GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0]), GetActorZ(TID_PLAYER+game_highnames[0])+z, 0);
            if (minigame_invisiblehats)
                SetActorProperty(TID_HATGAME, APROP_RenderStyle, STYLE_None);
            else
                SetActorProperty(TID_HATGAME, APROP_RenderStyle, STYLE_Normal);
        }
        else if (ThingCount(0, TID_HATGAME) > 0)
            Thing_Remove(TID_HATGAME);

        // Winner hat (at the end of the game)
        if (game_status == STATUS_GAMEOVER && game_over == OVER_WINNER)
        {
            if (ThingCount(0, TID_HATGAME+1) == 0)
                SpawnSpotForced("Crown", 1, TID_HATGAME+1, 0);

            z = 64.0;
            if (data_role[game_highnames[0]] > ROLE_NONE)
                z = 84.0;
            SetActorPosition(TID_HATGAME+1, GetActorX(TID_PLAYER+game_highnames[0]), GetActorY(TID_PLAYER+game_highnames[0]), GetActorZ(TID_PLAYER+game_highnames[0])+z, 0);
        }
    }

    // Special Hats
    // TODO: Look into optimizing this loop
    for (int i=0; i<MAXPLAYERS; i++)
    {
        // If the player left the game (or is dead), kill the hat
        if ((ThingCount(0, TID_HATROLE+i) > 0 && data_role[i] <= ROLE_NONE) || (GetActorProperty(TID_PLAYER+i, APROP_Health) <= 0) || (!PlayerInGame(i)))
            Thing_Remove(TID_HATROLE+i);

        // Check if the player logged in recently
        if (data_role[i] == ROLE_UNLOGGED && (PlayerIsLoggedIn(i) || GetCVar("doomware_unsafedb")))
            Load_PlayerDB(i);

        // Give Buu342 his role if he doesn't have one
        if (StrCmp(GetPlayerAccountName(i), "buu342") == 0)
            data_role[i] = ROLE_BUU342;

        // Give a beta tester a role if they don't have one
        if (IsBetaTester(i))
            data_role[i] = ROLE_BETA;

        // If they don't have a worthy role (or are dead), ignore them
        if (data_role[i] <= ROLE_NONE || (GetActorProperty(TID_PLAYER+i, APROP_Health) <= 0))
            continue;

        switch (data_role[i])
        {
            case ROLE_BUU342:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("Buu342Hat", 1, TID_HATROLE+i, 0);
                if ((game_status != STATUS_MINIGAME || (game_status == STATUS_MINIGAME && player_lostround[i])) && StrCmp(GetActorClass(TID_PLAYER+i), "Buu342Player") != 0)
                    MorphActor(TID_PLAYER+i, "Buu342Player", 1, 0x7fffffff, MRF_NEWTIDBEHAVIOUR, "Nothing", "Nothing");
            case ROLE_BETA:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("BetaHat", 1, TID_HATROLE+i, 0);
            case ROLE_ACHIEVER:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("AchieverHat", 1, TID_HATROLE+i, 0);

                SetActorPosition(TID_HATROLE+i, GetActorX(TID_PLAYER+i), GetActorY(TID_PLAYER+i), GetActorZ(TID_PLAYER+i)+64.0, 0);
                if (minigame_invisiblehats)
                    SetActorProperty(TID_HATROLE+i, APROP_RenderStyle, STYLE_None);
                else
                    SetActorProperty(TID_HATROLE+i, APROP_RenderStyle, STYLE_Normal);
                break;
            case ROLE_REGULAR:
                if (ThingCount(0, TID_HATROLE+i) == 0)
                    SpawnSpotForced("RegularHat", 1, TID_HATROLE+i, 0);
        }
    }

    // Restart the script
    delay(1);
    restart;
}


/*===================================================================================================
                                           Wacky Modifiers
===================================================================================================*/

script "DoomWare_WackyMod_DoubleJump" (void)
{
    int counter = 0;

    // Execute while the player is ingame
    while (PlayerInGame(PlayerNumber()))
    {
        int lastzvel = GetActorVelZ(0);
        delay(1);

        // If the player is alive and can jump
        if (ClassifyActor(TID_PLAYER+PlayerNumber()) & ACTOR_ALIVE && GetActorProperty(TID_PLAYER+PlayerNumber(), APROP_JUMPZ) != 0.0)
        {
            // If the player pressed jump this frame
            if ((GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_JUMP) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_JUMP))
            {
                // Incrememnt the jump counter
                counter++;
                
                // Double jump if the counter is 2
                if (counter == 2)
                {
                    ThrustThingZ(0, 40, 0, 0);
                    SpawnSpotForced("GrenadeSmokeTrail", TID_PLAYER+PlayerNumber(), 0, 0);
                    PlaySound(TID_PLAYER+PlayerNumber(), "skeleton/swing");
                }
            } 
            else if (GetActorVelZ(0) == 0 && lastzvel == 0) // Otherwise, check they have no Z movement
                counter = 0;
        }
    }
}


/*===================================================================================================
                                              DECORATE
===================================================================================================*/

Script "DoomWare_Entity_MarkCleanup" (void) // Marks an entity for cleanup at round end. ACS so that I can use it in DECORATE
{
    Thing_ChangeTID(0, TID_REMOVE);
}

Script "DoomWare_Entity_CheckCleanup" (void) // In case it missed the first cleanup
{
    if (game_status == STATUS_MINIGAME || game_status == STATUS_TIEBREAK || game_status == STATUS_TIEBREAKM)
        terminate;

    // Remove entities marked for deletion
    While (ThingCount(0, TID_REMOVE) > 0)
    {
        thing_remove(TID_REMOVE);
        delay(1);
    }
}


/*===================================================================================================
                                          Console Commands
===================================================================================================*/

Script "DoomWare_Console_ListPlayers" (void) // Lists all players in the server and their roles
{
    for (int i=0; i<MAXPLAYERS; i++)
        if (playerInGame(i))
            HUDMessage(d:i, s:" - ", n:i+1; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
}

Script "DoomWare_Console_AssignRole" (int ply, int role) // Forcefully assigns a player a role
{
    data_role[ply] = role;
    HUDMessage(s:"Player ", n:ply+1, s:" was given role ", d:role; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
}

Script "DoomWare_Console_ForceEnd" (void) // Ends the current game
{
    game_over = OVER_FORCED;
}


/*===================================================================================================
                                            Miscellaneous
===================================================================================================*/

script "DoomWare_DoLightning" (void) // Halloween skybox lightning
{
    delay(random(SECOND*5, SECOND*15));
    ChangeSky("STSKY22", "");
    AmbientSound("world/thunder", 127);
    Light_ChangeToValue(256, 255);
    Light_ChangeToValue(23, 255);
    Light_ChangeToValue(24, 255);
    Light_ChangeToValue(44, 255);
    Light_ChangeToValue(2, 255);
    Light_ChangeToValue(19, 255);
    Light_ChangeToValue(17, 255);
    Light_ChangeToValue(256, 255);
    Light_ChangeToValue(20, 255);
    Light_ChangeToValue(20, 255);
    Light_ChangeToValue(21, 255);
    Light_ChangeToValue(22, 255);
    delay(5);
    ChangeSky("STSKY21", "");
    Light_ChangeToValue(256, 192);
    Light_ChangeToValue(23, 192);
    Light_ChangeToValue(24, 192);
    Light_ChangeToValue(44, 192);
    Light_ChangeToValue(2, 192);
    Light_ChangeToValue(19, 192);
    Light_ChangeToValue(17, 192);
    Light_ChangeToValue(256, 192);
    Light_ChangeToValue(20, 192);
    Light_ChangeToValue(20, 192);
    Light_ChangeToValue(21, 192);
    Light_ChangeToValue(22, 192);
    restart;
}

script "DoomWare_AchievementLog" (int plynum, int achievement) CLIENTSIDE // Log() doesn't work unless it's clientsided, thus this script...
{
    Log(n:plynum+1, s:" obtained the achievement \cv", s:achievement);
}

function int Calc_Speed(int xvel, int yvel) // Calculates an actor's speed from their X+Y velocity
{
    int vi = xvel >> 16;
    int vii = yvel >> 16;
    return vi*vi  + vii*vii;
}

function int Distance(int tid1, int tid2) // Calculates the distanc between two actors
{
    int x, y, z, d;
    x = GetActorX(tid1) - GetActorX(tid2) >> 16;
    y = GetActorY(tid1) - GetActorY(tid2) >> 16;
    z = GetActorZ(tid1) - GetActorZ(tid2) >> 16;
    d = sqrt( x*x + y*y + z*z );
    return d;
}

Script "DoomWare_Entity_SetPlayerTranslation" (void) // Translate colors on morphed actors
{
    Thing_SetTranslation(TID_PLAYER+(ActivatorTID()-TID_EXTRA), -1);
    while (game_status != STATUS_WINLOSE)
        delay(1);
    thing_Remove(ActivatorTID());
}

function int Max(int a, int b) // Returns the largest number
{
    if (a > b)
        return a;
    return b;
}

function int AToI(str s) // Converts a string to an integer
{
    int start = 0;
    bool negative = false;
    int n = 0;
    int len = StrLen(s);
    
    // Check if there's a negative sign
    if (GetChar(s, 0) == '-')
    {
        negative = true;
        start++;
    }

    // Go through every character in the string
    for (int i=start; i<len; i++)
    {
        int char = GetChar(s, i);

        // Check that we are actually converting a number
        if (char < '0' || char > '9')
        {
            print(s:"ERROR, attempting to convert ", c:char, s:" to number!");
            continue;
        }

        // Add the number to our total
        n = n*10 + (char-'0');
    }

    if (negative)
        n = -n;

    return n;
}


/*===================================================================================================
                                       Minigames (Clientside)
===================================================================================================*/

Script "DoomWare_Client_Minigame1" (void) // The Floor/Air Is Lava
{
    // Pick the minigame based on the selected win condition
    if (minigame_wincondition1 == 0)
        minigame_instruction1[PlayerNumber()] = "The Floor is Lava";
    else
        minigame_instruction1[PlayerNumber()] = "The Air is Lava";
        
    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        // If the air is lava and the player isn't underwater, kill 'em
        if (minigame_wincondition1 == 2 && GetActorZ(0) > -44.0 && !Check_Player_Lost(PlayerNumber()))
            Thing_damage(0, 10000, MOD_LAVA);
        delay(1);
    }
}

Script "DoomWare_Client_Minigame2" (void) // Survive (Cyberdemon)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame3" (void) // Survive (ghouls)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame4" (void) // Survive (Archviles)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame5" (void) // Stop/Don't Stop Moving
{
    if (minigame_wincondition1 == 0)
    {
        if (game_speed != 4)
            minigame_instruction1[PlayerNumber()] = "Stop Moving";
        else
            minigame_instruction1[PlayerNumber()] = "Don't Not Stop Moving";
    }
    else
    {
        if (game_speed != 4)
            minigame_instruction1[PlayerNumber()] = "Don't Stop Moving";
        else
            minigame_instruction1[PlayerNumber()] = "Don't Not Keep Moving";    
    }
    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame6" (void) // Reach the End (Corridor 7)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Morph the player into the Corridor 7 soldier
    str class = "C7Player";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        GiveInventory("C7Gun", 1);
        SetWeapon("C7Gun");
        delay(1);
    }
    
    // Make sure he can't be harmed
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    setplayerproperty(1, 0, prop_invulnerability); // Must be first or you can't unmorph
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame7" (void) // Kill Ned Flanders
{
    minigame_instruction1[PlayerNumber()] = "Kill Ned Flanders";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into Homer and give him a shotgun
    str class = "SimpsonsPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        GiveInventory("SimpsonsShotgun", 1);
        SetWeapon("SimpsonsShotgun");
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame8" (void) // Destroy a Barrel
{
    minigame_instruction1[PlayerNumber()] = "Destroy a Barrel";

    // Make the player invincible and give him a Mace
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("MaceWeapon", 1);
    SetWeapon("MaceWeapon");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame9" (void) // Shoot one of the targets
{
    minigame_instruction1[PlayerNumber()] = "Shoot one of the targets";

    // Make the player invincible and give him a Railgun
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame10" (void) // Evade the Kamikazi
{
    minigame_instruction1[PlayerNumber()] = "Evade the Kamikazi";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame11" (void) // Survive (super Shotgun)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give the player a super shotgun
    GiveInventory("SuperShotgun", 1);
    SetWeapon("SuperShotgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame12" (void) // Blow/Don't Blow Your Brains Out
{
	if (minigame_wincondition1 == 0)
		minigame_instruction1[PlayerNumber()] = "Blow Your Brains Out";
	else
		minigame_instruction1[PlayerNumber()] = "Don't Blow Your Brains Out";

    // Give the player a suicide pistol
    GiveInventory("Suicide", 1);
    SetWeapon("Suicide");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame13" (void) // Enter the door
{
    // Display the correct text based on which minigame we're playing
    if (minigame_wincondition1 == 0)
        minigame_instruction1[PlayerNumber()] = "Enter the \cjNo Key\ci Door";
    else if (minigame_wincondition1 == 1)
        minigame_instruction1[PlayerNumber()] = "Enter the \chBlue Key\ci Door";
    else if (minigame_wincondition1 == 2)
        minigame_instruction1[PlayerNumber()] = "Enter the \cgRed Key\ci Door";
    else if (minigame_wincondition1 == 3)
        minigame_instruction1[PlayerNumber()] = "Enter the \ckYellow Key\ci Door";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame14" (void) // Meet The Worm
{
    minigame_instruction1[PlayerNumber()] = "Meet the Worm";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into massmouth and give him the Ray Gun
    str class = "MassMouthPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        GiveInventory("Raygun", 1);
        SetWeapon("Raygun");
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame15" (void) // Reach The End (Swapping Boxes)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    minigame_instruction2[PlayerNumber()] = "Boxes swap to the music";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame16" (void) // Touch the sky
{
    minigame_instruction1[PlayerNumber()] = "Touch the sky";
    minigame_instruction2[PlayerNumber()] = "Spam your \chjump\cg button";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        // Let players jump more
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_JUMP) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_JUMP) )
            ThrustThingZ(0, 20, 0, 0);

        // Make them win if they hit the sky
        if (GetActorZ(0) > 195.0)
            Player_Win(PlayerNumber());

        // Continue the loop
        delay(1);
    }
}

Script "DoomWare_Client_Minigame17" (void) // Finish a lap (Ancient Lake DDKR)
{
    minigame_instruction1[PlayerNumber()] = "Finish a lap";
    minigame_instruction2[PlayerNumber()] = "Hold \cdShoot\cg To Accelerate";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into a kart and freeze him
    str class = "KartPlayer";
    if (game_wackymod == WACKYMOD_SPEED)
        class = "KartPlayerSpeed";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        setplayerproperty(0, 1, PROP_TOTALLYFROZEN);
        delay(1);
    }

    // Wait for the countdown
    LocalAmbientSound("DoomWare/KartStart", 127);
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame18" (void) // Equip/Don't Equip Weapon
{
    str wep;
    int ticcount = 0; // Needed to fix a bug where players would auto win for some reason

    // Give the player everything
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("ChainsawFake", 1); // Fake weapons that have no ammo (because some people can't switch weapons without ammo)
    GiveInventory("PistolFake", 1);
    GiveInventory("SuperShotgunFake", 1);
    GiveInventory("ChaingunFake", 1);
    GiveInventory("RocketLauncherFake", 1);
    GiveInventory("PlasmaRifleFake", 1);
    GiveInventory("BFG9000Fake", 1);
    GiveInventory("Fist", 1);
    SetWeapon("Fist");
    delaY(1);
    SetWeapon("Fist");

    Switch(minigame_wincondition1%10)
    {
        case 1:
            minigame_instruction1[PlayerNumber()] = "Equip your Chainsaw";
            wep = "ChainsawFake";
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = "Equip your Pistol";
            wep = "PistolFake";
            break;
        case 3:
            minigame_instruction1[PlayerNumber()] = "Equip your Super Shotgun";
            wep = "SuperShotgunFake";
            break;
        case 4:
            minigame_instruction1[PlayerNumber()] = "Equip your Chaingun";
            wep = "ChaingunFake";
            break;
        case 5:
            minigame_instruction1[PlayerNumber()] = "Equip your Rocket Launcher";
            wep = "RocketLauncherFake";
            break;
        case 6:
            minigame_instruction1[PlayerNumber()] = "Equip your Plasma Gun";
            wep = "PlasmaRifleFake";
            break;
        case 7:
            minigame_instruction1[PlayerNumber()] = "Equip your BFG9000";
            wep = "BFG9000Fake";
            break;
    }
	if (minigame_wincondition1 >= 10)
		minigame_instruction1[PlayerNumber()] = StrParam(s:"Don't ", s:minigame_instruction1[PlayerNumber()]);
    Delay(SECOND);

    // Award (or fail) players if they got the right weapon
    while (game_status == STATUS_MINIGAME)
    {
        if (!StrIcmp(GetWeapon(), wep))
            ticcount++;
        if (ticcount == 5) // If they held the weapon for 5 ticks
		{
			if (minigame_wincondition1 < 10)
				Player_Win(PlayerNumber());
			else
				Player_Lose(PlayerNumber(), false);
		}
        delay(1);
    }
}

Script "DoomWare_Client_Minigame19" (void) // Swim Up
{
    minigame_instruction1[PlayerNumber()] = "Swim to the surface";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (GetActorZ(0) > 332.0)
            Player_Win(PlayerNumber());
        delay(1);
    }
}

Script "DoomWare_Client_Minigame20" (void) // Reach the end (Factory)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame21" (void) // Survive (Grenades)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame22" (void) // Collect 10 Rings
{
    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into Sonic
    str class = "SonicPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        TeleportInSector(43, 436, 396, false);
        int num = CheckInventory("WonRoundItem");
        if (num < 10)
            minigame_instruction1[PlayerNumber()] = StrParam(s:"Collect ", d:(10-num), s:" Rings");
        else
            minigame_instruction1[PlayerNumber()] = "Finished!";
        delay(1);
    }

    // Set him back to normal
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame23" (void) // Stay Off/On The Ground
{
	if (minigame_wincondition1 == 0)
		minigame_instruction1[PlayerNumber()] = "Stay Off The Ground";
	else
		minigame_instruction1[PlayerNumber()] = "Stay On The Ground";

    // Make the players invincible and give them a rocket launcher
    GiveInventory("RocketLauncher2", 2);
    SetWeapon("RocketLauncher2");
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame24" (void) // Grab a balloon
{
    minigame_instruction1[PlayerNumber()] = "Grab a balloon";
	
    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into Spider-Man
    str class = "SpiderManPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame25" (void) // Shoot the target (popup)
{
    minigame_instruction1[PlayerNumber()] = "Shoot the target";

    // Make the player invincible and give him a Railgun
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame26" (void) // Survive (Boxing)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give the player a boxing glove
    GiveInventory("BoxingGlove", 1);
    SetWeapon("BoxingGlove");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame27" (void) // Survive (Terry)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame28" (void) // Finish a lap (E1M1)
{
    minigame_instruction1[PlayerNumber()] = "Finish a lap";
    minigame_instruction2[PlayerNumber()] = "Hold \cdShoot\cg To Accelerate";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into a kart and freeze him
    str class = "KartPlayer";
    if (game_wackymod == WACKYMOD_SPEED)
        class = "KartPlayerSpeed";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        setplayerproperty(0, 1, PROP_TOTALLYFROZEN);
        delay(1);
    }

    // Wait for the countdown
    LocalAmbientSound("DoomWare/KartStart", 127);
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame29" (void) // Duck Hunt
{
    minigame_instruction1[PlayerNumber()] = "Shoot A Duck";

    GiveInventory("NESZapper", 1);
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame30" (void) // Dive Into The Water
{
    minigame_instruction1[PlayerNumber()] = "Dive Into The Water";

    // Prevent winning during teleportation
    delay(2);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Check if the player managed to get in the water
    while (game_status == STATUS_MINIGAME)
    {
        if (GetActorZ(0) < 50.0 && ClassifyActor(0) & ACTOR_ALIVE)
            Player_Win(PlayerNumber());
        delay(1);
    }
}

Script "DoomWare_Client_Minigame31" (void) // Reach The End (Rocks)
{
    minigame_instruction1[PlayerNumber()] = "Reach The End";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame32" (void) // Reach The End (Ice)
{
    minigame_instruction1[PlayerNumber()] = "Reach The End";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame33" (void) // Survive (Romero)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame34" (void) // Survive (Hoth)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into a snow speeder and make him fly
    str class = "SnowSpeederPlayer";
    if (game_wackymod == WACKYMOD_SPEED)
        class = "SnowSpeederPlayerSpeed";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        setplayerproperty(1, 1, PROP_FLY );
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (!player_lostround[PlayerNumber()])
        {
            // Allow for air controls
            if (GetUserCVar(PlayerNumber(), "doomware_invertfly"))
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*2 , 0, 0);
            else
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*-2 , 0, 0);
        }
        delay(1);
    }

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    setplayerproperty(1, 0, PROP_FLY );
}

Script "DoomWare_Client_Minigame35" (void) // Climb the Colossus
{
    minigame_instruction1[PlayerNumber()] = "Climb the Colossus";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame36" (void) // Get On The Colored Circle
{
    minigame_instruction1[PlayerNumber()] = "Get On The Colored Circle";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Force the player to look at the screen
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame37" (void) // Swim Down
{
    minigame_instruction1[PlayerNumber()] = "Swim";
    minigame_instruction2[PlayerNumber()] = "Spam your \ccUse key\cg to dive deeper";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Turn the player into a submarine
    str class = "SubmarinePlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }
    delay(1);

    // Give players control
    while (game_status == STATUS_MINIGAME)
    {
        // Allow players to dive with their Use key
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_USE) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_USE) )
            ThrustThingZ(0, 8, 1, 1);
        delay(1);
    }

    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame38" (void) // Repeat the pattern
{
    minigame_instruction1[PlayerNumber()] = "Watch";

    // Freeze the player and make him invulnerable
    setplayerproperty(1, 1, PROP_FROZEN );
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the pattern is done showing
    while (minigame_canmove == false)
        delay(1);

    // Give the player a RailGun
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        str ans = "Your Answer = ";
        for (int i=0; i<4; i++)
            if (player_answer2[PlayerNumber()][i] != -1)
            {
                str color;
                switch (player_answer2[PlayerNumber()][i])
                {
                    case 0:
                        color = "\cd";
                        break;
                    case 1:
                        color = "\cm";
                        break;
                    case 2:
                        color = "\cg";
                        break;
                    case 3:
                        color = "\ch";
                        break;
                    case 4:
                        color = "\cj";
                        break;
                    case 5:
                        color = "\ci";
                        break;
                }
                ans = StrParam(s:ans, s:color, d:(i+1), s:"\c-");
            }
        minigame_instruction2[PlayerNumber()] = ans;
        delay(1);
    }
}

Script "DoomWare_Client_Minigame39" (void) // Storm the Beach
{
    minigame_instruction1[PlayerNumber()] = "Storm the beach";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame40" (void) // Survive (Dark Corridors)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give the player a shotgun
    GiveInventory("Shotgun", 1);
    SetWeapon("Shotgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame41" (void) // Go to the Light
{
    minigame_instruction1[PlayerNumber()] = "Go to the Light";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame42" (void) // Survive (Rockets)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a rocket launcher and make him invulnerable
    GiveInventory("RocketLauncher2", 2);
    GiveInventory("RocketBox", 20);
    SetWeapon("RocketLauncher2");
    delay(10); // To prevent losing invulnerability during teleportation
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame43" (void) // Zorch a Flemoid
{
    minigame_instruction1[PlayerNumber()] = "Zorch a Flemoid";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into Spider-Man
    str class = "FredPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame44" (void) // Reach the End (Void)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame45" (void) // Finish a lap (Rainbow Road)
{
    minigame_instruction1[PlayerNumber()] = "\crF\cgi\cin\cki\cfs\cdh \cna \cvl\cha\ctp";
    minigame_instruction2[PlayerNumber()] = "Hold \cdShoot\cg To Accelerate";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into a kart and freeze him
    str class = "KartPlayer";
    if (game_wackymod == WACKYMOD_SPEED)
        class = "KartPlayerSpeed";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        setplayerproperty(0, 1, PROP_TOTALLYFROZEN);
        delay(1);
    }

    // Wait for the countdown
    LocalAmbientSound("DoomWare/KartStart", 127);
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame46" (void) // Reach The End (Bigger Swapping Boxes)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    minigame_instruction2[PlayerNumber()] = "Boxes swap to the music";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame47" (void) // Survive (Banana)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame48" (void) // Survive (Spike)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame49" (void) // Math
{
    // Choose the game instructions based on wincondition3
    switch (minigame_wincondition3)
    {
        case 0:
            minigame_instruction1[PlayerNumber()] = StrParam(i:minigame_wincondition1, s:" + ", i:minigame_wincondition2);
            break;
        case 1:
            minigame_instruction1[PlayerNumber()] = StrParam(i:minigame_wincondition1, s:" - ", i:minigame_wincondition2);
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = StrParam(i:minigame_wincondition1, s:" x ", i:minigame_wincondition2);
            break;
    }

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Make the player frozen+invulnerable and give him a railgun
    setplayerproperty(1, 2, prop_invulnerability);
    setplayerproperty(1, 1, PROP_FROZEN );
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        str ans = "Your Answer = ";
        for (int i=0; i<2; i++)
            if (player_answer2[PlayerNumber()][i] != -1)
                ans = StrParam(s:ans, d:player_answer2[PlayerNumber()][i]);
        minigame_instruction2[PlayerNumber()] = ans;
        delay(1);
    }
}

Script "DoomWare_Client_Minigame50" (void) // Survive (Bullet Hell)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    delay(1);
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame51" (void) // Clean your Weapon
{
    minigame_instruction1[PlayerNumber()] = "Clean your weapon";
    minigame_instruction2[PlayerNumber()] = "Spam \cdShoot\cg";
    player_viewsprite[PlayerNumber()] = "PPISA0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            str sprite = "AFKLMNOPFFGHHJJJHHJJJHHFFFFQRSRSRSRSRSRSRSRSRSQFFFFFFHHJJJQRSRSRSQFFFKLMMNOPPFA";
            if (player_answer1[PlayerNumber()] < 78)
                player_answer1[PlayerNumber()]++;
            player_viewsprite[PlayerNumber()] = StrParam(s:"PPIS", c:GetChar(sprite, player_answer1[PlayerNumber()]), s:"0");
            Switch (player_answer1[PlayerNumber()])
            {
                case 4:
                case 71: LocalAmbientSound("DoomWare/CleanCock1", 127); break;
                case 5:
                case 73: LocalAmbientSound("DoomWare/CleanCock2", 127); break;
                case 6:
                case 74: LocalAmbientSound("DoomWare/CleanCock3", 127); break;
                case 7:
                case 75: LocalAmbientSound("DoomWare/CleanCock4", 127); break;
                case 13:
                case 18:
                case 55: LocalAmbientSound("DoomWare/CleanSpray", 127); break;
                case 28:
                case 30:
                case 32:
                case 34:
                case 36:
                case 38:
                case 40:
                case 42:
                case 44:
                case 59:
                case 61:
                case 63: LocalAmbientSound("DoomWare/CleanRub1", 127); break;
                case 29:
                case 31:
                case 33:
                case 35:
                case 37:
                case 39:
                case 41:
                case 43:
                case 45:
                case 60:
                case 62:
                case 64: LocalAmbientSound("DoomWare/CleanRub2", 127); break;
                case 78: Player_Win(PlayerNumber()); break;
            }
        }

        delay(1);
    }
}

Script "DoomWare_Client_Minigame52" (void) // Gib a Turkey
{
    minigame_instruction1[PlayerNumber()] = "Gib a Turkey";

    // Make the player invincible and give him a fast fist
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("FastFist", 1);
    SetWeapon("FastFist");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame53" (void) // Drink
{
    minigame_instruction1[PlayerNumber()] = "Drink";
    minigame_instruction2[PlayerNumber()] = "Spam \cdshoot\cg";
    player_viewsprite[PlayerNumber()] = "TNT2A0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            str sprite = "ABCDEFGHIJKLMNOOONMMMNOOONMMMNOOONMLKJIHGF";
            if (player_answer1[PlayerNumber()] < 41)
            {
                player_answer1[PlayerNumber()]++;
                Switch (player_answer1[PlayerNumber()])
                {
                    case 16:
                    case 24: LocalAmbientSound("DoomWare/Gulp", 127); break;
                    case 32: LocalAmbientSound("DoomWare/Gulp", 127); Player_Win(PlayerNumber()); break;
                    case 41: LocalAmbientSound("DoomWare/DrinkAh", 127); break;
                }
            }
            player_viewsprite[PlayerNumber()] = StrParam(s:"DRNK", c:GetChar(sprite, player_answer1[PlayerNumber()]), s:"0");
        }

        delay(1);
    }
}

Script "DoomWare_Client_Minigame54" (void) // Survive (Chilli)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame55" (void) // Hit the Real Barrel
{
    minigame_instruction1[PlayerNumber()] = "Hit the Real Barrel";

    // Make the player invincible and give him a Mace
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("MaceWeapon", 1);
    SetWeapon("MaceWeapon");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame56" (void) // Survive (Spike Circle)
{
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame57" (void) // Eat The Chocolate
{
    minigame_instruction1[PlayerNumber()] = "Eat The Chocolate";
    minigame_instruction2[PlayerNumber()] = "Spam \cdShoot\cg";
    player_viewsprite[PlayerNumber()] = "TNT2A0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            str sprite = "ABCDEFGHIJKLMNOPQRSTUV";
            if (player_answer1[PlayerNumber()] < 21)
                player_answer1[PlayerNumber()]++;
            player_viewsprite[PlayerNumber()] = StrParam(s:"CHOC", c:GetChar(sprite, player_answer1[PlayerNumber()]), s:"0");
            if (player_answer1[PlayerNumber()] == 14)
                Player_Win(PlayerNumber());
        }

        delay(1);
    }
}

Script "DoomWare_Client_Minigame58" (void) // Survive (Wind)
{
    int jumpz = GetActorProperty(0 ,APROP_JumpZ);
    minigame_instruction1[PlayerNumber()] = "Survive";

    // Make the player unable to jump
    SetActorProperty(0 ,APROP_JumpZ, 0<<16);
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Let the player jump again
    SetActorProperty(0 ,APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame59" (void) // Get to Hissy
{
    minigame_instruction1[PlayerNumber()] = "Get to Hissy";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame60" (void) // Count the Lost Souls
{
    minigame_instruction1[PlayerNumber()] = "Count The Lost Souls";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Make the player frozen+invulnerable
    setplayerproperty(1, 2, prop_invulnerability);
    setplayerproperty(1, 1, PROP_FROZEN );

    // Wait until the Lost Souls have stopped appearing
    while (minigame_wincondition1 == 0)
        delay(1);

    // Give the player a Railgun
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        str ans = "Your Answer = ";
        for (int i=0; i<2; i++)
            if (player_answer2[PlayerNumber()][i] != -1)
                ans = StrParam(s:ans, d:player_answer2[PlayerNumber()][i]);
        minigame_instruction2[PlayerNumber()] = ans;
        delay(1);
    }

    // Morph the player back
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame61" (void) // Reach the End (Hurdles)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Freeze the player for a min
    setplayerproperty(1, 1, PROP_TOTALLYFROZEN);

    // Wait for the countdown
    while (minigame_canmove == false)
        delay(1);

    // GO!
    setplayerproperty(1, 0, PROP_TOTALLYFROZEN);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame62" (void) // Cross the Road
{
    minigame_instruction1[PlayerNumber()] = "Cross the Road";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Turn the player into a chicken
    str class = "ChickenPlayer2";
	if (game_wackymod == WACKYMOD_SPEED)
		class = "ChickenPlayer2Speed";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    // Morph the player back
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame63" (void) // Collect a Potion
{
    minigame_instruction1[PlayerNumber()] = "Collect a Potion";
    minigame_instruction2[PlayerNumber()] = "Attack a thief";

    // Make the player invulnerable and give him a sexy leg
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Boot", 1);
    SetWeapon("Boot");

    // Make the player win if he got a potion
    while (game_status == STATUS_MINIGAME)
    {
        if (GetActorProperty(0, APROP_Health) > 100 || (game_wackymod == WACKYMOD_1HP && GetActorProperty(0, APROP_Health) > 1))
            Player_Win(PlayerNumber());
        delay(1);
    }

    // Morph the player back
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame64" (void) // Reach the End (Skyhook)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into the Outrider and make him fly
    str class = "OutriderPlayer";
    if (game_wackymod == WACKYMOD_SPEED)
        class = "OutriderPlayerSpeed";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        setplayerproperty(1, 1, PROP_FLY );
        SetActorAngle(0, 0.25);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (!player_lostround[PlayerNumber()])
        {
            // Allow for air controls
            if (GetUserCVar(PlayerNumber(), "doomware_invertfly"))
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*2 , 0, 0);
            else
                ThrustThingZ(0, ((GetActorPitch(0) >> 8))*-2 , 0, 0);
        }
        delay(1);
    }

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    setplayerproperty(1, 0, PROP_FLY );
}

Script "DoomWare_Client_Minigame65" (void) // Spam the Indicated Button
{
    int errbuff=0;
    int lastbutton = minigame_wincondition2;
    while (game_status == STATUS_MINIGAME)
    {
        int curinput = GetPlayerInput(-1, INPUT_BUTTONS);
        int oldinput = GetPlayerInput(-1, INPUT_OLDBUTTONS);
        
        // Reset the error buffer if the button changed
        if (lastbutton != minigame_wincondition2)
        {
            errbuff = 2;
            lastbutton = minigame_wincondition2;
        }

        // Check the keys the player is pressing
        switch (minigame_wincondition2)
        {
            case 0:
                minigame_instruction1[PlayerNumber()] = "Spam \cdShoot";
                if( (curinput & BT_ATTACK) && !(oldinput & BT_ATTACK) )
                    player_answer1[PlayerNumber()]++;
                else if (((curinput & BT_JUMP) && !(oldinput & BT_JUMP)) || ((curinput & BT_USE) && !(oldinput & BT_USE)))
                    if (player_answer1[PlayerNumber()] != 29)
                        if (errbuff <= 0)
                            player_answer1[PlayerNumber()]--;
                        else
                            errbuff--;
                break;
            case 1:
                minigame_instruction1[PlayerNumber()] = "Spam \ccUse";
                if( (curinput & BT_USE) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_USE) )
                    player_answer1[PlayerNumber()]++;
                else if (((curinput & BT_JUMP) && !(oldinput & BT_JUMP)) || ((curinput & BT_ATTACK) && !(oldinput & BT_ATTACK)))
                    if (player_answer1[PlayerNumber()] != 29)
                        if (errbuff <= 0)
                            player_answer1[PlayerNumber()]--;
                        else
                            errbuff--;
                break;
            case 2:
                minigame_instruction1[PlayerNumber()] = "Spam \chJump";
                if( (curinput & BT_JUMP) && !(oldinput & BT_JUMP) )
                {
                    ThrustThingZ(0, 20, 0, 0);
                    player_answer1[PlayerNumber()]++;
                }
                else if (((curinput & BT_USE) && !(oldinput & BT_USE)) || ((curinput & BT_ATTACK) && !(oldinput & BT_ATTACK)))
                    if (player_answer1[PlayerNumber()] != 29)
                        if (errbuff <= 0)
                            player_answer1[PlayerNumber()]--;
                        else
                            errbuff--;
                break;
        }

        // Check if the player won
        if (player_answer1[PlayerNumber()] >= 29)
        {
            player_answer1[PlayerNumber()] = 29;
            Player_Win(PlayerNumber());
        }

        if (player_answer1[PlayerNumber()] < 0)
            player_answer1[PlayerNumber()] = 0;

        // Set the view sprite
        if (player_answer1[PlayerNumber()] < 10)
            player_viewsprite[PlayerNumber()] = StrParam(s:"MASHOM0", d:player_answer1[PlayerNumber()]);
        else
            player_viewsprite[PlayerNumber()] = StrParam(s:"MASHOM", d:player_answer1[PlayerNumber()]);

        delay(1);
    }
}

Script "DoomWare_Client_Minigame66" (void) // Don't Get Wet
{
    minigame_instruction1[PlayerNumber()] = "Don't Get Wet!";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame67" (void) // Reach the End (Factory Line)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame68" (void) // Pick Up the Key
{
    minigame_instruction1[PlayerNumber()] = "Pick up the assigned key";
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Check if the player has the right key
    while (game_status == STATUS_MINIGAME)
    {
        if ((minigame_wincondition1 == 0 && CheckInventory("BlueCard") > 0) || (minigame_wincondition1 == 1  && CheckInventory("RedCard") > 0) || (minigame_wincondition1 == 2  && CheckInventory("YellowCard") > 0))
            Player_Win(PlayerNumber());
        delay(1);
    }
}

Script "DoomWare_Client_Minigame69" (void) // Survive (Hell Deathmatch)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Stop the player from moving to prevent falling in the lava at the start
    SetActorVelocity(TID_PLAYER+PlayerNumber(), 0.0, 0.0, 0.0, false, false);

    // Give the player a super shotgun
    GiveInventory("Shotgun", 1);
    SetWeapon("Shotgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame70" (void) // Eat
{
    if (minigame_wincondition1 == 0)
        minigame_instruction1[PlayerNumber()] = "Eat anything but Sushi";
    else
        minigame_instruction1[PlayerNumber()] = "Eat anything but Tea";

    // Check if the right food has been consumed
    while (game_status == STATUS_MINIGAME)
    {
        int food_count = CheckInventory("Food_EggRoll")+CheckInventory("Food_SalmonRoll1")+CheckInventory("Food_SalmonRoll2")+CheckInventory("Food_Shrimp")+CheckInventory("Food_Toro")+CheckInventory("Food_Tea")+CheckInventory("Food_Sushi1")+CheckInventory("Food_Sushi2");
        
        // Win if the player ate the correct item
        if ((CheckInventory("Food_EggRoll") > 0) || (CheckInventory("Food_SalmonRoll1") > 0) ||
             (CheckInventory("Food_SalmonRoll2") > 0) || (CheckInventory("Food_Shrimp") > 0) ||
             (CheckInventory("Food_Toro") > 0) || (CheckInventory("Food_Tea") > 0 && minigame_wincondition1 == 0 ) ||
            (CheckInventory("Food_Sushi1") > 0 && minigame_wincondition1 == 1) || (CheckInventory("Food_Sushi2") > 0 && minigame_wincondition1 == 1))
            Player_Win(PlayerNumber());

        // Lose if the player ate the wrong item (Even if they won already)
        if ((CheckInventory("Food_Tea") > 0 && minigame_wincondition1 == 1 ) ||
            (CheckInventory("Food_Sushi1") > 0 && minigame_wincondition1 == 0) || (CheckInventory("Food_Sushi2") > 0 && minigame_wincondition1 == 0))
        {
            if (player_wonround[PlayerNumber()] == true)
            {
                player_wonround[PlayerNumber()] = false;
                player_midround[PlayerNumber()] = true;
            }
            Player_Lose(PlayerNumber(), false);
        }
        
        // Kill the player if he's a fatty
        if (food_count > 3)
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 1, 0);

        delay(1);
    }
}

Script "DoomWare_Client_Minigame71" (void) // Find a Pokemon
{
    int pkmn_num=0;
    minigame_instruction1[PlayerNumber()] = "Find a Pokemon";
    minigame_instruction2[PlayerNumber()] = "Search the Grass";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into Ash
    str class = "AshPlayer";
    
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Check if a Pokemon has been caught
    while (game_status == STATUS_MINIGAME)
    {
        if (CheckInventory("PokemonTrigger"))
        {
            switch (pkmn_num)
            {
                case 0:
                    Player_Win(PlayerNumber());
                    SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
                    SetActorVelocity(0, 0, 0, 0, false, false);
                    LocalSetMusic("d_pkmnen");
                    break;
                case 27:
                case 15:
                case 3:
                    fadeto(0, 0, 0, 1.0, 0.0857);
                    break;
                case 30:
                case 18:
                case 6:
                    fadeto(0, 0, 0, 0.0, 0.0857);
                    break;
                case 33:
                case 21:
                case 9:
                    fadeto(255, 255, 255, 1.0, 0.0857);
                    break;
                case 36:
                case 24:
                case 12:
                    fadeto(255, 255, 255, 0.0, 0.0857);
                    break;
                default:
                    if (pkmn_num >= 39)
                    {
                        int spr_num = pkmn_num - 38;
                        if (spr_num > 17)
                        {
                            spr_num = 17;
                            fadeto(0, 0, 0, 1.0, 0.001);
                        }
                        if (spr_num < 10)
                            player_viewsprite[PlayerNumber()] = StrParam(s:"PKMNBT0", d:spr_num);
                        else
                            player_viewsprite[PlayerNumber()] = StrParam(s:"PKMNBT", d:spr_num);
                    }
                    break;
            }
            pkmn_num++;
        }
        delay(1);
    }
    fadeto(0, 0, 0, 0.0, 0.0);
    LocalSetMusic("");
    SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    delay(1);
    fadeto(0, 0, 0, 0.0, 0.0);
}

Script "DoomWare_Client_Minigame72" (void) // Survive (Disappearing Floor)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame73" (void) // Mine an Ore
{
    // Tell the player what to do
    delay(1);
    switch(minigame_wincondition1)
    {
        case 0:
            minigame_instruction1[PlayerNumber()] = "Mine \ccTin";
            break;
        case 1:
            minigame_instruction1[PlayerNumber()] = "Mine \cfGold";
            break;
        case 2:
            minigame_instruction1[PlayerNumber()] = "Mine \chMithril";
            break;
    }

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into Bob and give him a Rune Pick
    str class = "RunescapePlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        GiveInventory("PickaxeWeapon",1);
        SetWeapon("PickaxeWeapon");
        delay(1);
    }

    // Check if the player mined the right element
    while (game_status == STATUS_MINIGAME)
    {
        if (minigame_wincondition1 == 0 && CheckInventory("TinOreItem"))
            Player_Win(PlayerNumber());
        else if (minigame_wincondition1 == 1 && CheckInventory("GoldOreItem"))
            Player_Win(PlayerNumber());
        else if (minigame_wincondition1 == 2 && CheckInventory("MithrilOreItem"))
            Player_Win(PlayerNumber());
        delay(1);
    }

    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame74" (void) // Reach the End (Eclipse)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame75" (void) // Reach the end (Automap)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";
    minigame_instruction2[PlayerNumber()] = "Check the automap";

    // Fade the player's screen and randomly rotate them
    FadeTo(0, 0, 0, 1.0, 0.0);
    delay(1);
    FadeTo(0, 0, 0, 1.0, 0.0);
    SetActorAngle(TID_PLAYER+PlayerNumber(), FixedDiv(random(0, 360)<<16, 360.0));

    // Wait for the minigame to end
    while (game_status == STATUS_MINIGAME)
        delay(1);
    
    // Let the player see again
    FadeTo(0, 0, 0, 0.0, 0.0);
    delay(1);
    FadeTo(0, 0, 0, 0.0, 0.0);
}

Script "DoomWare_Client_Minigame76" (void) // Score a Basketball
{
    minigame_instruction1[PlayerNumber()] = "Score a Basketball";

    // Give the player a basketball
    GiveInventory("BBallLauncher",1);
    GiveInventory("RocketAmmo",100);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame77" (void) // Reach the End (Bit Trip)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Make the player only able to jump
    str class = "JumpPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        setplayerproperty(1, 1, PROP_FROZEN );
        SetActorAngle(0, 0.25);
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        Force_Observe(709);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);

    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
}

Script "DoomWare_Client_Minigame78" (void) // Shoot Apple Imp Head
{
    minigame_instruction1[PlayerNumber()] = "Shoot the Apple Off The Imp's Head";

    // Give the player a bow and arrow and make him invulnerable+frozen
    SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
    setplayerproperty(1, 1, PROP_FROZEN );
    GiveInventory("BowArrow",1);
    SetWeapon("BowArrow");
    setplayerproperty(1, 2, prop_invulnerability);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame79" (void) // Shoot an Imp
{
    minigame_instruction1[PlayerNumber()] = "Shoot an Imp";

    // Make the player invincible and give him a Railgun
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("Railgun", 1);
    SetWeapon("Railgun");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame80" (void) // Survive (Pyoro)
{
    int jumpz = GetActorProperty(0 ,APROP_JumpZ);
    int speed = GetActorProperty(0, APROP_Speed);

    // Make the player unable to jump
    minigame_instruction1[PlayerNumber()] = "Survive";
    Force_Observe(813);

    // Invert the player's controls and make him unable to jump
    SetActorProperty(0, APROP_Speed, -GetActorProperty(0, APROP_Speed));
    SetActorProperty(0 ,APROP_JumpZ, 0<<16);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        // Make the player always look towards the camera
        SetActorAngle(0, 0.75);
        delay(1);
    }

    // Re-invert the player's controls and let him jump again
    SetActorProperty(0, APROP_Speed, speed);
    SetActorProperty(0, APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame81" (void) // Dodge the Car
{
    int jumpz = GetActorProperty(0 ,APROP_JumpZ);
    int speed = GetActorProperty(0, APROP_Speed);

    // Make the player unable to jump
    minigame_instruction1[PlayerNumber()] = "Dodge the Car";
    Force_Observe(815);

    // Make the player unable to move and make him jump much higher
    SetActorProperty(0, APROP_Speed, 0);
    SetActorProperty(0, APROP_JumpZ, FixedMul(jumpz, 1.5));

    SetActorVelocity(0, 0.0, 0.0, 0.0, false, false);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        // Make the player always look right
        SetActorAngle(0, 1.0);
        delay(1);
    }

    // Put the player back to normal
    SetActorProperty(0, APROP_Speed, speed);
    SetActorProperty(0, APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame82" (void) // Whack a Diglett
{
    minigame_instruction1[PlayerNumber()] = "Whack a Diglett";

    // Make the player invincible and give him a Mace
    setplayerproperty(1, 2, prop_invulnerability);
    GiveInventory("MaceWeapon", 1);
    SetWeapon("MaceWeapon");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame83" (void) // Charge your Laz0r
{
    minigame_instruction1[PlayerNumber()] = "Charge your Laz0r";
    minigame_instruction2[PlayerNumber()] = "Spam \cdshoot\cg. 1 Point Per Frag";
    player_viewsprite[PlayerNumber()] = "TNT2A0";

    // Wait until the minigame is over
    while (game_status == STATUS_MINIGAME)
    {
        // If the player lost, don't let him be able to win
        if (player_lostround[PlayerNumber()])
        {
            player_viewsprite[PlayerNumber()] = "TNT2A0";
            delay(1);
            continue;
        }

        // If he reached a certain score, increment the animation automatically
        if (player_answer1[PlayerNumber()] >= 22 && player_answer1[PlayerNumber()] < 31)
            player_answer1[PlayerNumber()]++;

        // On pressing attack
        if( (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK) )
        {
            // Spawn the aura if it's the first click
            if (player_answer1[PlayerNumber()] == 0)
            {
                SpawnSpotForced("Aura", TID_PLAYER+PlayerNumber(), TID_EXTRA+PlayerNumber(), 0);
                Thing_Projectile(TID_PLAYER+PlayerNumber(), 252, (GetActorAngle(TID_PLAYER+PlayerNumber())>>8)+64, 24, 0);
                Thing_Projectile(TID_PLAYER+PlayerNumber(), 252, (GetActorAngle(TID_PLAYER+PlayerNumber())>>8)-64, 24, 0);
            }

            // Increment the view sprite
            if (player_answer1[PlayerNumber()] < 22)
                player_answer1[PlayerNumber()]++;

            // Fire the Laz0r when ready
            if (player_answer1[PlayerNumber()] == 22)
            {
                GiveInventory("Laz0r", 1);
                SetWeapon("Laz0r");

                Player_Win(PlayerNumber());
            }
        }

        // Select the viewsprite
        if (player_answer1[PlayerNumber()] == 31 || player_answer1[PlayerNumber()] == 0)
            player_viewsprite[PlayerNumber()] = "TNT2A0";
        else
            player_viewsprite[PlayerNumber()] = StrParam(s:"LAZR", d:player_answer1[PlayerNumber()]-1);

        delay(1);
    }
}

Script "DoomWare_Client_Minigame84" (void) // Stay on the Road
{
    minigame_instruction1[PlayerNumber()] = "Stay on the Road";
    minigame_instruction2[PlayerNumber()] = "\ckStrafe\cg to steer";

    // Prevent a bug where some player's won't teleport after morphing
    delay(1);

    // Morph the player into a kart and freeze him
    str class = "BusPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        if (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) == 0)
        {
            SetActorPitch(TID_PLAYER+PlayerNumber(), 0.0);
            SetActorAngle(TID_PLAYER+PlayerNumber(), 0.25);
        }
        delay(1);
    }

    // Set him back to normal
    StopSound(TID_PLAYER+PlayerNumber(), 6);
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    StopSound(TID_PLAYER+PlayerNumber(), 6);
}

Script "DoomWare_Client_Minigame85" (void) // Survive (Time Freeze)
{
    int time = 0;
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";

    // Give players a grenade launcher
    GiveInventory("GrenadeLauncher", 1);
    SetWeapon("GrenadeLauncher");
	TakeInventory("RocketAmmo", 999);
	GiveInventory("RocketAmmo", 5);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        time++;

        // If time's unfreezing, remove the grenade launcher so we don't get cheeky players
        if (time > SECOND*6)
            TakeInventory("GrenadeLauncher", 1);
        delay(1);
    }
}

Script "DoomWare_Client_Minigame86" (void) // Reach the end (Chasm)
{
    minigame_instruction1[PlayerNumber()] = "Reach the end";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");
    
    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame87" (void) // Be the highest player
{
    minigame_instruction1[PlayerNumber()] = "Be the highest player";

    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");
    
    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame88" (void) // Choose a side
{
    int jumpz = GetActorProperty(0 ,APROP_JumpZ);
    int speed = GetActorProperty(0, APROP_Speed);
    minigame_instruction1[PlayerNumber()] = "Choose a side";
    minigame_instruction2[PlayerNumber()] = "The heaviest side will fall";
    Force_Observe(898);

    // Invert the player's controls and make him unable to jump
	SetActorProperty(0, APROP_Speed, -GetActorProperty(0, APROP_Speed));
    SetActorProperty(0 ,APROP_JumpZ, 0<<16);

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
    {
        // Make the player always look towards the camera
        SetActorAngle(0, 0.75);
        delay(1);
    }

    // Re-invert the player's controls and let him jump again
    SetActorProperty(0, APROP_Speed, speed);
    SetActorProperty(0, APROP_JumpZ, jumpz);
}

Script "DoomWare_Client_Minigame89" (void) // Abandon Ship
{
    minigame_instruction1[PlayerNumber()] = "Abandon Ship";

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame90" (void) // Survive (Captain Falcon)
{
    minigame_instruction1[PlayerNumber()] = "Survive";
    minigame_instruction2[PlayerNumber()] = "1 Point Per Frag";
    
    // Morph the player into Captain Falcon
    str class = "CFalconPlayer";
    while (StrCmp(GetActorClass(TID_PLAYER+PlayerNumber()), class) != 0)
    {
        Player_Morph(PlayerNumber(), class);
        delay(1);
    }

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
        
    // Unmorph the player back and unfreeze them if they were
    UnMorphActor(TID_PLAYER+PlayerNumber(), true);
    SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
}

Script "DoomWare_Client_Minigame91" (void) // Reach the End (Golden Idol)
{
    minigame_instruction1[PlayerNumber()] = "Reach the End";
    minigame_instruction2[PlayerNumber()] = "Grab the \ckGolden Key";
    
    // Give the player a push staff so he can be a dick
    GiveInventory("PushStaff", 1);
    SetWeapon("PushStaff");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame92" (void) // Pet Daisy :)
{
    minigame_instruction1[PlayerNumber()] = "Pet Daisy :)";
    minigame_instruction2[PlayerNumber()] = "Click \cdShoot\cg to pet";
    
    // Make the player invulnerable and give them hands to pet with
    SetPlayerProperty(1, 2, prop_invulnerability);
    GiveInventory("PetWeapon", 1);
    SetWeapon("PetWeapon");

    // Wait until the game's over
    while (game_status == STATUS_MINIGAME)
        delay(1);
}

Script "DoomWare_Client_Minigame93" (void) // Choose a source port
{
    minigame_instruction1[PlayerNumber()] = "Pick a source port";

    // While the game is running
    while (game_status == STATUS_MINIGAME)
    {
        // If the win condition changed
        if (minigame_wincondition1 != 0)
        {
            // Give the player a push staff so he can be a dick
            if (CheckInventory("PushStaff") == 0)
            {
                GiveInventory("PushStaff", 1);
                SetWeapon("PushStaff");
            }
            
            // Show the correct win condition
            if (minigame_wincondition1 == 1)
                minigame_instruction1[PlayerNumber()] = "Pick the \cdmost popular\ci source port";
            else if (minigame_wincondition1 == 2)
                minigame_instruction1[PlayerNumber()] = "Pick the \cgleast popular\ci source port";
        }
        delay(1);
    }
}


/*===================================================================================================
                                    1v1 TieBreakers (Clientside)
===================================================================================================*/

Script "DoomWare_Client_TieBreaker1" (void) // Gun Duel
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Shoot the other player";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        setplayerproperty(1, 1, PROP_FROZEN);
        SetActorProperty(0, APROP_HEALTH, 1);
        GiveInventory("Pistol", 1);
        SetWeapon("Pistol");
    }
    else
        Force_Observe(PlayerNumber());

    // Kill the player if they shoot too soon (to prevent holding the shoot button)
    while (minigame_canmove == false)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAK)
        delay(1);

    // Unfreeze frozen players
    SetPlayerProperty(1, 0, PROP_FROZEN);
}

Script "DoomWare_Client_TieBreaker2" (void) // Rope Tug
{
    int plyx, plyy, plyz;

    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Press your \cdShoot\cg key to repeatedly tug the rope";
    minigame_wincondition1 = 0;

    // Move the players
    if (PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        setplayerproperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Kill the player if they press shoot too soon
    while (minigame_canmove == false)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // Showtime!
    LocalAmbientSound("DoomWare/TieStart", 127);
    minigame_instruction1[PlayerNumber()] = "Go!";

    while (game_status == STATUS_TIEBREAK)
    {
        int ply1 = game_highnames[0];
        int ply2 = game_highnames[1];
        minigame_wincondition1 = 0;
        if ((PlayerNumber() == ply1 || PlayerNumber() == ply2) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
        {
            if (PlayerNumber() == ply1 && !player_lostround[ply1] && GetActorY(TID_PLAYER+ply1) < 1848.0)
            {
                minigame_wincondition1++;
                SetActorPosition(TID_PLAYER+ply2, GetActorX(TID_PLAYER+ply2), GetActorY(TID_PLAYER+ply2)-3.0, GetActorZ(TID_PLAYER+ply2), false);
                SetActorPosition(TID_PLAYER+ply1, GetActorX(TID_PLAYER+ply1), GetActorY(TID_PLAYER+ply1)-3.0, GetActorZ(TID_PLAYER+ply1), false);
            }
            if (PlayerNumber() == ply2 && !player_lostround[ply2] && GetActorY(TID_PLAYER+ply2) > 1992.0)
            {
                minigame_wincondition1--;
                SetActorPosition(TID_PLAYER+ply1, GetActorX(TID_PLAYER+ply1), GetActorY(TID_PLAYER+ply1)+3.0, GetActorZ(TID_PLAYER+ply1), false);
                SetActorPosition(TID_PLAYER+ply2, GetActorX(TID_PLAYER+ply2), GetActorY(TID_PLAYER+ply2)+3.0, GetActorZ(TID_PLAYER+ply2), false);
            }
        }
        delay(1);
    }
    setplayerproperty(1, 0, PROP_FROZEN);
    SetActorPosition(TID_PLAYER+PlayerNumber(), plyx, plyy, plyz, 0);
    SpawnSpotForced("TeleportFog", TID_PLAYER+PlayerNumber(), 0, 0);
}

Script "DoomWare_Client_TieBreaker3" (void) // Barrels
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Kill the other player";

    // Give the player a weapon if they're in the game, or force them to observe
    if (PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        setplayerproperty(1, 1, PROP_FROZEN);
        SetActorProperty(0, APROP_HEALTH, 1);
        GiveInventory("Pistol", 1);
        SetWeapon("Pistol");
    }
    else
        Force_Observe(PlayerNumber());

    // Kill the player if they shoot too soon (to prevent holding the shoot button)
    while (minigame_canmove == false)
    {
        if ((PlayerNumber() == game_highnames[0] || PlayerNumber() == game_highnames[1]) && (GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAK)
        delay(1);

    // Unfreeze frozen players
    SetPlayerProperty(1, 0, PROP_FROZEN);
}


/*===================================================================================================
                                  Non 1v1 TieBreakers (Clientside)
===================================================================================================*/

Script "DoomWare_Client_TieBreakerM1" (void) // Survive (Grenades Fight)
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Survive. Kills give you a 1up";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (game_score[PlayerNumber()] == game_highscores[0])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        GiveInventory("GrenadeLauncher", 1);
        GiveInventory("RocketBox", 20);
        SetWeapon("GrenadeLauncher");
        SetPlayerProperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Don't allow the player to shoot while he waits for the round to begin
    while (minigame_canmove == false)
    {
        if ((GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);
    SetPlayerProperty(1, 0, PROP_FROZEN);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAKM)
        delay(1);
}

Script "DoomWare_Client_TieBreakerM2" (void) // Survive (Decreasing Ring)
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Survive. The Map gets smaller.";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (game_score[PlayerNumber()] == game_highscores[0])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        GiveInventory("PushStaff", 1);
        SetWeapon("PushStaff");
        SetPlayerProperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Don't allow the player to attack while he waits for the round to begin
    while (minigame_canmove == false)
    {
        if ((GetPlayerInput(-1, MODINPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & BT_ATTACK))
            Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);
    SetPlayerProperty(1, 0, PROP_FROZEN);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAKM)
    {
        if (GetActorZ(TID_PLAYER+PlayerNumber()) < -128.0)
                Thing_Destroy(TID_PLAYER+PlayerNumber(), 0);
        delay(1);
    }
}

Script "DoomWare_Client_TieBreakerM3" (void) // Hit the Target (1 Shot)
{
    minigame_instruction1[PlayerNumber()] = "Wait for the signal";
    minigame_instruction2[PlayerNumber()] = "Shoot the target.";

    // Give the player a weapon if they're in the game, or force them to observe
    delay(1);
    if (game_score[PlayerNumber()] == game_highscores[0])
    {
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, true);
        GiveInventory("Railgun", 1);
        SetWeapon("Railgun");
        SetPlayerProperty(1, 1, PROP_FROZEN);
    }
    else
        Force_Observe(PlayerNumber());

    // Wait for the minigame to start
    while (minigame_canmove == false)
        delay(1);

    // It's showtime!
    minigame_instruction1[PlayerNumber()] = "Go!";
    LocalAmbientSound("DoomWare/TieStart", 127);
    SetPlayerProperty(1, 0, PROP_FROZEN);

    // Wait until the game's over
    while (game_status == STATUS_TIEBREAKM)
        delay(1);
}


/*===================================================================================================
                                       Minigames (Serverside)
===================================================================================================*/

Script "DoomWare_Server_Minigame1" (void) // The floor/air is lava
{
    HUDMessage(s:"The Floor/Air Is Lava"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_LAVA");
    round_winifmid = true;
    
    // Lower the lights
    int lowerspeed = 8;
    switch (game_speed)
    {
        case 2:
        case 3: lowerspeed = 9; break;
        case 4: lowerspeed = 10; break;
    }
    floor_lowerbyvalue(20, lowerspeed, 10);
    floor_lowerbyvalue(21, 8, 8);
    floor_lowerbyvalue(22, 8, 8);
    floor_lowerbyvalue(691, lowerspeed, 10);
    floor_lowerbyvalue(692, 8, 8);
    floor_lowerbyvalue(693, 8, 8);
    SetThingSpecial(88, 0, 0, 0, 0, 0, 0);
    SetThingSpecial(147, 0, 0, 0, 0, 0, 0);
    
    // Choose which minigame to play (0 is floor, 1 is air)
    minigame_wincondition1 = random(0, 1);
    if (minigame_wincondition1 == 0) 
    {
        delay(SECOND-(2*game_speed));

        // Make the floor lava
        Sector_setDamage(2, 200000, MOD_LAVA);
        Sector_setDamage(20, 200000, MOD_LAVA);
        Sector_setDamage(21, 200000, MOD_LAVA);
        Sector_setDamage(22, 200000, MOD_LAVA);
        Sector_setDamage(691, 200000, MOD_LAVA);
        Sector_setDamage(692, 200000, MOD_LAVA);
        Sector_setDamage(693, 200000, MOD_LAVA);
        ChangeFloor(2, "WFLAVA1");
        ChangeFloor(20, "WFLAVA1");
        ChangeFloor(21, "WFLAVA1");
        ChangeFloor(22, "WFLAVA1");
        ChangeFloor(691, "WFLAVA1");
        ChangeFloor(692, "WFLAVA1");
        ChangeFloor(693, "WFLAVA1");
        delay(SECOND-(2*game_speed));
    }
    else
    {
        delay(30);

        // Silently teleport everyone to a copy of the main arena
        ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 357, true, false);
        Light_Fade(148, 0, SECOND-(2*game_speed));
        Light_Fade(149, 0, SECOND-(2*game_speed));
        Light_Fade(253, 0, SECOND-(2*game_speed));
        Light_Fade(856, 0, SECOND-(2*game_speed));
        delay(SECOND-(2*game_speed));

        // Kill people not underwater with no remorse
        minigame_wincondition1 = 2;
        delay(SECOND+32-(7*game_speed));

        // Silently bring everyone back
        ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false);
    }
    
    // Make everything safe again
    SetThingSpecial(88, 0, 255, 0, 0, 8, 0);
    Sector_setDamage(2, 0, MOD_UNKNOWN);
    Sector_setDamage(20, 0, MOD_UNKNOWN);
    Sector_setDamage(21, 0, MOD_UNKNOWN);
    Sector_setDamage(22, 0, MOD_UNKNOWN);
    Sector_setDamage(691, 0, MOD_UNKNOWN);
    Sector_setDamage(692, 0, MOD_UNKNOWN);
    Sector_setDamage(693, 0, MOD_UNKNOWN);
    ChangeFloor(2, "SLIME15");
    ChangeFloor(20, "N_BRGR13");
    ChangeFloor(691, "N_BRGR13");
    ChangeFloor(21, "TLITE6_5");
    ChangeFloor(692, "TLITE6_5");
    switch (game_skin)
    {
        case MAPSKIN_HALLOWEEN:
            SetThingSpecial(147, 0, 255, 105, 0, 8, 0);
            ChangeFloor(22, "TLITE6_8");
            ChangeFloor(693, "TLITE6_8");
            break;
        case MAPSKIN_CHRISTMAS:
            SetThingSpecial(147, 0, 255, 255, 255, 8, 0);
            ChangeFloor(22, "TLITE6_9");
            ChangeFloor(693, "TLITE6_9");
            break;
        default:
            SetThingSpecial(147, 0, 0, 0, 255, 8, 0);
            ChangeFloor(22, "TLITE6_7");
            ChangeFloor(693, "TLITE6_7");
            break;
    }
    
    floor_raisebyvalue(20, 8, 10);
    floor_raisebyvalue(21, 8, 8);
    floor_raisebyvalue(22, 8, 8);
    floor_raisebyvalue(691, 8, 10);
    floor_raisebyvalue(692, 8, 8);
    floor_raisebyvalue(693, 8, 8);
}

Script "DoomWare_Server_Minigame2" (void) // Survive (Cyberdemon)
{
    HUDMessage(s:"Survive (Cyberdemon)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CYBRDM");
    round_winifmid = true;

    // Spawn the cyberdemons (more if the game is faster)
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    SpawnSpotForced("Cyberdemon", 1, TID_REMOVE, random(0, 359));
    if (game_speed > 1)
        SpawnSpotForced("Cyberdemon", 7+random(0, 3), TID_REMOVE, random(0, 359));
    if (game_speed == MAXSPEEDUPS)
        SpawnSpotForced("Cyberdemon", 3+random(0, 3), TID_REMOVE, random(0, 359));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10 - (SECOND*game_speed));
}

Script "DoomWare_Server_Minigame3" (void) // Survive (ghouls)
{
    HUDMessage(s:"Survive (Ghouls)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_GHOUL");
    Add_Observer(537);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 440, false, true);

    // Spawn a bunch of Jitterskulls
    SpawnSpotForced("Jitterskull", 25, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 27, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 29, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 31, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 33, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Jitterskull", 35, TID_REMOVE, random(0, 359));

    // Spawn more depending on the game speed
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Jitterskull", 32, TID_REMOVE, random(0, 359));
            SpawnSpotForced("Jitterskull", 34, TID_REMOVE, random(0, 359));
        case 3:
            SpawnSpotForced("Jitterskull", 28, TID_REMOVE, random(0, 359));
            SpawnSpotForced("Jitterskull", 30, TID_REMOVE, random(0, 359));
        case 2:
            SpawnSpotForced("Jitterskull", 26, TID_REMOVE, random(0, 359));
            break;
    }

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(SECOND*game_speed));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame4" (void) // Survive (archviles)
{
    int dropped = 0;
    hudmessage(s:"Survive (Archvile)";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_ARCHV");
    round_winifmid = true;

    // Move the dynamic lights up
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)+128.0, 0);

    // Spawn everyone's favorite Doom 2 monster
    SpawnSpotForced("Archvile", 1, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 57, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 58, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 59, TID_REMOVE, random(0, 359));
    SpawnSpotForced("Archvile", 60, TID_REMOVE, random(0, 359));

    // Spawn more depending on the difficulty
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Archvile", 6, TID_REMOVE, random(0, 359));
        case 3:
            SpawnSpotForced("Archvile", 5, TID_REMOVE, random(0, 359));
        case 2:
            SpawnSpotForced("Archvile", 4, TID_REMOVE, random(0, 359));
        case 1:
            SpawnSpotForced("Archvile", 3, TID_REMOVE, random(0, 359));
            break;
    }
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Raise the floor
    floor_raisebyvalue(20, 8, 64);
    floor_raisebyvalue(21, 8, 64);
    floor_raisebyvalue(22, 8, 64);
    floor_raisebyvalue(691, 8, 64);
    floor_raisebyvalue(692, 8, 64);
    floor_raisebyvalue(693, 8, 64);

    // Let the players survive
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(SECOND*game_speed));
    delay(1);
    do
    {
        // Randomly drop a pillar if the game speed is high enough
        if (game_speed > 2 && minigame_timer < SECOND*3 && dropped == 0)
        {
            dropped = random(1, 2);
            if (dropped == 1)
            {
                floor_lowerbyvalue(20, 32, 64);
                floor_lowerbyvalue(21, 32, 64);
                floor_lowerbyvalue(22, 32, 64);
            }
            else
            {
                floor_lowerbyvalue(691, 32, 64);
                floor_lowerbyvalue(692, 32, 64);
                floor_lowerbyvalue(693, 32, 64);
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Move things back
    if (dropped != 1)
    {
        floor_lowerbyvalue(20, 8, 64);
        floor_lowerbyvalue(21, 8, 64);
        floor_lowerbyvalue(22, 8, 64);
    }
    if (dropped != 2)
    {
        floor_lowerbyvalue(691, 8, 64);
        floor_lowerbyvalue(692, 8, 64);
        floor_lowerbyvalue(693, 8, 64);
    }
    SetActorPosition(88, GetActorX (88), GetActorY (88), GetActorZ (88)-128.0, 0);
}

Script "DoomWare_Server_Minigame5" (void) // Stop/Don't Stop moving
{
    int time;
    hudmessage(s:"Stop/Don't Stop Moving";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    setMusic("D_MOVEIT");
    round_winifmid = true;
    minigame_wincondition1 = random(0, 1); // 0 is stop moving, 1 is don't

    // If stop moving, set the floor friction to help slow down players
    if (minigame_wincondition1 == 0)
    {
        Sector_SetFriction(2, 95);
        Sector_SetFriction(19, 95);
        Sector_SetFriction(20, 95);
        Sector_SetFriction(21, 95);
        Sector_SetFriction(22, 95);
        Sector_SetFriction(23, 95);
        Sector_SetFriction(24, 95);
        Sector_SetFriction(691, 95);
        Sector_SetFriction(692, 95);
        Sector_SetFriction(693, 95);
    }    
    
    // Give players time to react
    if (minigame_wincondition1 == 0)
        delay(SECOND*2-(game_speed*2));
    else
        delay(SECOND-(game_speed));

    // Horribly maim anyone who didn't pay attention
    time = SECOND;
    while (time > 0)
    {
        time--;
        for (int i=0; i<MAXPLAYERS; i++)
            if ((minigame_wincondition1 == 0 && Calc_Speed(GetActorVelX(TID_PLAYER+i), GetActorVely(TID_PLAYER+i)) > 20) || (minigame_wincondition1 == 1 && Calc_Speed(GetActorVelX(TID_PLAYER+i), GetActorVely(TID_PLAYER+i)) < 20))
                thing_damage(TID_PLAYER+i, 1337, MOD_BARREL);
        delay(1);
    }

    // Set the friction back to normal
    if (minigame_wincondition1 == 0)
    {
        Sector_SetFriction(2, 100);
        Sector_SetFriction(19, 100);
        Sector_SetFriction(20, 100);
        Sector_SetFriction(21, 100);
        Sector_SetFriction(22, 100);
        Sector_SetFriction(23, 100);
        Sector_SetFriction(24, 100);
        Sector_SetFriction(691, 100);
        Sector_SetFriction(692, 100);
        Sector_SetFriction(693, 100);
    }
}

Script "DoomWare_Server_Minigame6" (void) // Reach the End (Corridor 7)
{
    hudmessage(s:"Reach the End (Corridor 7)";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    setMusic("D_CORRI7");
    Add_Observer(936);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 940, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*20-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame7" (void) // Kill Ned Flanders
{
	round_noforceend = true;
    hudmessage(s:"Kill Ned Flanders";HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_SIMPSN");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 70, false, true);

    // Spawn Ned Flanders
    SpawnSpot ("NedFlanders", 728, TID_REMOVE);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame8" (void) // Destroy a Barrel
{
    HUDMessage(s:"Destroy a Barrel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_barrl");

    // Spawn some barrels to whack
    SpawnSpot("WoodBarrel", 3, TID_REMOVE);
    SpawnSpot("WoodBarrel", 4, TID_REMOVE);
    SpawnSpot("WoodBarrel", 5, TID_REMOVE);
    SpawnSpot("WoodBarrel", 6, TID_REMOVE);
    SpawnSpot("WoodBarrel", 7, TID_REMOVE);
    SpawnSpot("WoodBarrel", 8, TID_REMOVE);
    SpawnSpot("WoodBarrel", 9, TID_REMOVE);
    SpawnSpot("WoodBarrel", 10, TID_REMOVE);
    SpawnSpot("WoodBarrel1UP", 1, TID_REMOVE);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame9" (void) // Shoot A Target
{
    HUDMessage(s:"Shoot A Target"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 90, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame10" (void) // Evade the Kamikazi
{
    int time=0;
    HUDMessage(s:"Evade the Kamikazi"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Jihad");
    round_winifmid = true;

    // Spawn a Kamikaze
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    SpawnSpotForced("Jihad", 1, TID_REMOVE , random(0, 359));
    SpawnSpotForced("AvoidDecoration", 1, TID_AVOID, 0);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Move the AVOID item to follow the Kamikaze
    while (time < (SECOND*2 - 10))
    {
        time++;
        SetActorPosition(TID_AVOID, GetActorX(TID_REMOVE), GetActorY(TID_REMOVE), GetActorZ(TID_REMOVE)+64.0, 0);
        delay(1);
    }

    // Blow up the Kamikaze
    thing_remove(TID_AVOID);
    thing_damage(TID_REMOVE, 50, 0);

    delay(10);
}

Script "DoomWare_Server_Minigame11" (void) // Survive (super Shotgun)
{
    HUDMessage(s:"Survive (super Shotgun)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_stelth");
    round_winifmid = true;
    minigame_fragpoints = true;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame12" (void) // Blow/Don't Blow Your Brains Out
{
    HUDMessage(s:"Blow/Don't Blow Your Brains Out"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_rave");
	minigame_wincondition1 = random(0, 1);
	if (minigame_wincondition1 == 0)
		round_winifsuicide = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(5*game_speed));
}

Script "DoomWare_Server_Minigame13" (void) // Enter The Door
{
    int i;
    hudmessage(s:"Enter The Door"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    minigame_wincondition1 = random(0, 3);
    SetMusic("d_door");

    // Store player positions in case they win
    for (i=0; i<MAXPLAYERS; i++)
        if (PlayerInGame(i))
            Player_SavePosition(i);

    // Raise the doors
    floor_raisebyvalue(24, 32, 128);
    floor_raisebyvalue(25, 32, 128);
    floor_raisebyvalue(39, 32, 128);
    floor_raisebyvalue(44, 32, 128);

    // Give players time to reach the doors
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*3-(5*game_speed));

    // Lower the doors
    floor_lowerbyvalue(24, 32, 128);
    floor_lowerbyvalue(25, 32, 128);
    floor_lowerbyvalue(39, 32, 128);
    floor_lowerbyvalue(44, 32, 128);

    // Invalidate the positions of players who didn't do anything to prevent them from getting teleported.
    for (i=0; i<MAXPLAYERS; i++)
        if (player_midround[i])
            Player_InvalidatePosition(i);

    // Bring players back if they're at the island
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame14" (void) // Meet the Worm
{
    hudmessage(s:"Meet the worm"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_worm");
    round_noforceend = true; // To give time to catch the 1-Up

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 110, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4-(3*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame15" (void) // Reach the End (Swapping Boxes)
{
    int time = SECOND*20-(35*game_speed);
    int box = 0;
    hudmessage(s:"Reach the End (Swapping Boxes)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_boxes");
    Sector_SetDamage(876, 10000, MOD_FALLING);
    Sector_SetDamage(10, 10000, MOD_FALLING);
    Add_Observer(518);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 150, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, time);

    // Make the boxes swap
    time = 0;
    do
    {
        int i;
        time++;
        if (time == 89)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "\cd3";
        else if (time == 89+17)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "\ci2";
        else if (time == 89+34)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "\cg1";
        else if (time == 89+51)
        {
            time = 0;
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "";
            if (box == 0)
            {
                Floor_LowerInstant(7, 0, 24);
                Floor_RaiseInstant(876, 0, 26);
                Floor_LowerInstant(859, 0, 28);
                Floor_RaiseInstant(10, 0, 28);
                ChangeFloor(7, "f_sky1");
                ChangeFloor(876, "DEM4_5");
                ChangeFloor(10, "DEM4_5");
                ChangeFloor(859, "f_sky1");
                Sector_SetDamage(9, 10000, MOD_FALLING);
                Sector_SetDamage(859, 10000, MOD_FALLING);
                Sector_SetDamage(876, 0, MOD_FALLING);
                Sector_SetDamage(10, 0, MOD_FALLING);
                box = 1;
            }
            else
            {
                Floor_RaiseInstant(859, 0, 28);
                Floor_LowerInstant(876, 0, 26);
                Floor_RaiseInstant(7, 0, 24);
                Floor_LowerInstant(10, 0, 28);
                ChangeFloor(876, "f_sky1");
                ChangeFloor(10, "f_sky1");
                ChangeFloor(7, "DEM3_5");
                ChangeFloor(859, "DEM3_5");
                Sector_SetDamage(876, 10000, MOD_FALLING);
                Sector_SetDamage(10, 10000, MOD_FALLING);
                Sector_SetDamage(859, 0, MOD_FALLING);
                Sector_SetDamage(7, 0, MOD_FALLING);
                box = 0;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Fix the boxes
    if (box == 1)
    {
        Floor_RaiseInstant(859, 0, 28);
        Floor_LowerInstant(876, 0, 26);
        Floor_RaiseInstant(7, 0, 24);
        Floor_LowerInstant(10, 0, 28);
        ChangeFloor(876, "f_sky1");
        ChangeFloor(10, "f_sky1");
        ChangeFloor(7, "DEM3_5");
        ChangeFloor(859, "DEM3_5");
        Sector_SetDamage(876, 10000, MOD_FALLING);
        Sector_SetDamage(10, 10000, MOD_FALLING);
        Sector_SetDamage(859, 0, MOD_FALLING);
        Sector_SetDamage(7, 0, MOD_FALLING);
    }
}

Script "DoomWare_Server_Minigame16" (void) // Touch The Sky
{
    HUDMessage(s:"Touch The Sky"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Jump");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*3-(4*game_speed));
}

Script "DoomWare_Server_Minigame17" (void) // Finish a lap (Ancient Lake DDKR)
{
    HUDMessage(s:"Finish A Lap (Ancient Lake)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_ddkr");
    Add_Observer(536);
    Add_Observer(818);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 170, false, true);

    // Countdown until players can move
    SpawnSpotForced("Lakitu", 358, THING_REMOVE, 0);
    delay(SECOND*2);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*18-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame18" (void) // Equip/Don't Equip Weapon
{
    HUDMessage(s:"Equip Weapon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_weapon");
	
	// Pick the weapon (and whether to allow equipping or not)
    minigame_wincondition1 = random(1, 7)+(10*random(0, 1));
	if (minigame_wincondition1 >= 10)
		round_winifmid = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*2-(3*game_speed));
}

Script "DoomWare_Server_Minigame19" (void) // Reach Surface
{
    HUDMessage(s:"Reach Surface"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_water");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 21, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame20" (void) // Reach The End (Factory)
{
    HUDMessage(s:"Reach The End (Factory)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Factry");
    Add_Observer(539);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 190, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame21" (void) // Survive (Grenades)
{
    HUDMessage(s:"Survive (Grenades)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_GRENAD");
    round_winifmid = true;

    // Raise the floor
    ChangeFloor(17, "SHAWN2");
    switch (game_speed)
    {
        case 4:
            floor_raisebyvalue(17, 32, 64);
            break;
        case 3:
        case 2:
            floor_raisebyvalue(17, 24, 64);
            break;
        case 1:
        case 0:
            floor_raisebyvalue(17, 16, 64);
            break;
    }
    delay(SECOND-(2*game_speed));

    // Shoot grenades
    SpawnProjectile(87, "DWGrenade", 0, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 32, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 64, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 96, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 128, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 160, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 192, 90, 4, 0.25, 0);
    SpawnProjectile(87, "DWGrenade", 224, 90, 4, 0.25, 0);
    delay(SECOND + 10);

    // Lower the floor
    ChangeFloor(17, "NFMBGY01");
    floor_lowerbyvalue(17, 16, 64);
    delay(SECOND*2);
}

Script "DoomWare_Server_Minigame22" (void) // Collect 10 Rings
{
    hudmessage(s:"Collect 10 Rings"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_Sonic");
    SpawnSpotForced("WonRoundItem", 89, TID_REMOVE, 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 107, true, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    // Check for winners
    do
    {
        for (int i=0; i<MAXPLAYERS; i++)
            if (CheckActorInventory(TID_PLAYER+i, "WonRoundItem") >= 10)
                Player_Win(i);
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Move the players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame23" (void) // Stay Off/On The Ground
{
    int time;
    hudmessage(s:"Stay Off/On The Ground"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_ground");
    round_winifmid = true;
	minigame_wincondition1 = random(0, 1);
    delay(SECOND+20 - (2*game_speed));

    // Horribly maim anyone who is on/off the floor (based on the value of minigame_wincondition1)
    time = 15;
    while (time > 0)
    {
        time--;
        for (int i=0; i<MAXPLAYERS; i++)
            if ((minigame_wincondition1 == 0 && (GetActorZ(TID_PLAYER+i)>>16) < 11) || (minigame_wincondition1 == 1 && (GetActorZ(TID_PLAYER+i)>>16) > 11))
                thing_damage(TID_PLAYER+i, 10000000, MOD_BARREL);
        delay(1);
    }
    delay(20);
}

Script "DoomWare_Server_Minigame24" (void) // Grab a balloon
{
	int i;
    hudmessage(s:"Grab a balloon"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_SPDRMN");
	
	// Spawn balloons based on the number of players
	switch(PlayerCount())
	{
		default:
			SpawnSpotForced("YellowBalloon", 993, TID_REMOVE, 0.0);
		case 14:
		case 13:
			SpawnSpotForced("RedBalloon", 992, TID_REMOVE, 0.0);
		case 12:
		case 11:
			SpawnSpotForced("GreenBalloon", 991, TID_REMOVE, 0.0);
		case 10:
		case 9:
			SpawnSpotForced("BlueBalloon", 990, TID_REMOVE, 0.0);
		case 8:
		case 7:
			SpawnSpotForced("YellowBalloon", 989, TID_REMOVE, 0.0);
		case 6:
		case 5:
			SpawnSpotForced("RedBalloon", 988, TID_REMOVE, 0.0);
		case 4:
		case 3:
			SpawnSpotForced("GreenBalloon", 987, TID_REMOVE, 0.0);
		case 2:
		case 1:
			SpawnSpotForced("BlueBalloon", 986, TID_REMOVE, 0.0);
			break;
	}

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 703, true, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6-(20*game_speed));

    // Check for winners
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
		{
			int plytid = TID_PLAYER+i;
			
			// If this player isn't in the game, skip them
			if (!PlayerInGame(i))
				continue;
				
			// If this player hasn't won yet
			if (!Check_Player_Won(i))
			{
				str tocheck = "BlueBalloon";
				
				// Use a for loop to check all the different balloon types
				for (int j=0; j<4; j++)
				{
					// Use a switch since we can't use temporary arrays
					switch (j)
					{
						case 1:
							tocheck = "GreenBalloon";
							break;
						case 2:
							tocheck = "RedBalloon";
							break;
						case 3:
							tocheck = "YellowBalloon";
							break;
					}
					
					// If the player has a balloon, then win and spawn a fake balloon
					if (CheckActorInventory(plytid, tocheck))
					{
						Player_Win(i);
						SetActorProperty(plytid, APROP_Gravity, -0.2);
						SpawnSpotForced(StrParam(s:tocheck, s:"Still"), plytid, TID_REMOVE+(i+1), 0.0);
						break;
					}
				}
			}
			
			// If a fake balloon exists for this player, move it to their position
			if (ThingCount(0, TID_REMOVE+(i+1)) > 0);
				SetActorPosition(TID_REMOVE+(i+1), GetActorX(plytid), GetActorY(plytid), GetActorZ(plytid)+16.0, 0);
		}
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

	// Remove all the balloons and reset player gravities
	for (i=0; i<MAXPLAYERS; i++)
	{
		SetActorProperty(i, APROP_Gravity, 1.0);
		Thing_Remove(TID_REMOVE+(i+1));
	}
	
    // Move the players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame25" (void) // Shoot the Target (Popup)
{
    int time=0;
    int SectorTarget = random(30, 36);
    minigame_wincondition1 = SectorTarget;
    HUDMessage(s:"Shoot the Target (Popup)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 210, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Check for winners
    do
    {
        time++;
        if (time == SECOND)
            Floor_RaiseInstant(SectorTarget, 0, 16);
        if (time == SECOND*2)
            Floor_LowerInstant(SectorTarget, 0, 16);
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame26" (void) // Survive (Boxing)
{
    HUDMessage(s:"Survive (Boxing)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_boxing");
    round_winifmid = true;
    minigame_fragpoints = true;
    Add_Observer(538);

    // Spawn some spectators
    SpawnSpotForced("ScriptedMarine", 108, TID_REMOVE, 0);
    SpawnSpotForced("ScriptedMarine", 309, TID_REMOVE, 64);
    SpawnSpotForced("ScriptedMarine", 334, TID_REMOVE, 128);
    SpawnSpotForced("ScriptedMarine", 336, TID_REMOVE, 192);
    SpawnSpotForced("ScriptedMarine", 332, TID_REMOVE, 32);
    SpawnSpotForced("ScriptedMarine", 333, TID_REMOVE, 96);
    SpawnSpotForced("ScriptedMarine", 335, TID_REMOVE, 160);
    SpawnSpotForced("ScriptedMarine", 337, TID_REMOVE, 224);
    Thing_Deactivate(TID_REMOVE);
    Thing_SetTranslation(TID_REMOVE, 6);
    SpawnSpotForced("ZombieMan", 267, TID_REMOVE, 32);
    SpawnSpotForced("ChaingunGuy", 268, TID_REMOVE, 64);
    SpawnSpotForced("Archvile", 269, TID_REMOVE, 64);
    SpawnSpotForced("BaronOfHell", 286, TID_REMOVE, 96);
    SpawnSpotForced("CyberDemon", 287, TID_REMOVE, 128);
    SpawnSpotForced("ShotgunGuy", 288, TID_REMOVE, 128);
    SpawnSpotForced("Revenant", 289, TID_REMOVE, 160);
    SpawnSpotForced("HellKnight", 306, TID_REMOVE, 192);
    SpawnSpotForced("DoomImp", 307, TID_REMOVE, 192);
    SpawnSpotForced("WolfensteinSS", 308, TID_REMOVE, 0);
    Thing_Deactivate(TID_REMOVE);

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 128, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6+17 -(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame27" (void) // Survive (Terry)
{
    HUDMessage(s:"Survive (Terry)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Terry");
    round_winifmid = true;

    // Teleport players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 127, true, true);

    // Summon our lord and saviour
    SpawnSpotForced("dickfail", 129, TID_REMOVE, 0);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame28" (void) // Finish a Lap (E1M1)
{
    HUDMessage(s:"Finish a Lap (E1M1)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_e1m1");
    Add_Observer(758);
    Add_Observer(757);
    Add_Observer(759);
    Add_Observer(557);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 230, false, true);

    // Countdown until players can move
    SpawnSpotForced("Lakitu", 358, THING_REMOVE, 0);
    delay(SECOND*2);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*14-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame29" (void) // Duck Hunt
{
    hudmessage(s:"Duck Hunt"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_duck");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 66, true, true);

    // Spawn some birds to shoot
    SpawnSpotForced("Bird1", 126, TID_REMOVE, random(-180, 180));
    SpawnSpotForced("Bird2", 679, TID_REMOVE, random(-180, 180));
    SpawnSpotForced("Bird3", 149, TID_REMOVE, random(-180, 180));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame30" (void) // Dive into the Water
{
    int time = 0;
    int tp = 0;
    hudmessage(s:"Dive Into The Water"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Lava");

    // Move all players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 250, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6-(10*game_speed));

    time = random(15, SECOND);
    do
    {
        time--;

        // Hop players from water to lava zones
        if (time <= 0)
        {
            time = random(15, 35);
            if (tp == 0)
            {
                TeleportInSector(162, 436, 396, false);
                tp = 1;
            }
            else
            {
                TeleportInSector(161, 396, 436, false);
                tp = 0;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame31" (void) // Server - Reach the End (Boulders)
{
    int time = 0;
    hudmessage(s:"Reach the End (Boulders)"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_SNEAK");
    Add_Observer(558);

    // Move all players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 270, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    do
    {
        time++;
        if (time == 17)
        {
            Thing_ProjectileGravity(random(166, 169), 255, 128, 64, 0);
            Thing_ProjectileGravity(random(186, 189), 255, 128, 64, 0);
            time = 0;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame32" (void) // Server - Reach the End (Ice)
{
    int time = 0;
    int num = 0;
    hudmessage(s:"Reach the End (Ice)"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_echobs");
    Add_Observer(559);
    round_noforceend = true; // To give time to catch the 1-Up

    // Move all players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 290, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND+(10-game_speed)*31);

    // Start shaking the floor after a bit
    delay(SECOND);
    Radius_Quake2(227, 5, SECOND+(10-game_speed)*31, 0, 256, "DoomWare/IceMove");

    // Open the floor
    do
    {
        time++;
        if (time == (10-game_speed))
        {
            Floor_lowerInstant(45+num, 0, 128);
            Floor_lowerInstant(78+num, 0, 128);
            Ceiling_lowerInstant(78+num, 0, 128);
            Sector_setDamage(45+num, 999, mod_falling);
            time = 0;
            num++;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Fix the floor
    for (int i=0;i<31;i++)
    {
        Floor_raiseInstant(45+i, 0, 128);
        Ceiling_raiseInstant(78+i, 0, 128);
        Floor_raiseInstant(78+i, 0, 128);
        Sector_setDamage(45+i, 0, mod_falling);
        if (i%8 == 7)
            delay(1);
    }
}

Script "DoomWare_Server_Minigame33" (void) // Survive (Romero)
{
    hudmessage(s:"Survive (Romero)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_FINBOS");
    round_winifmid = true;

    // Move the dynamic lights up
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)+128.0, 0);

    // Spawn (other) God
    SpawnSpotForced("MechaRomero", 1, TID_REMOVE, random(0, 359));
    SpawnSpotForced("TeleportFog", 1, 42, 0);

    // Spawn more depending on the difficulty
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("MechaRomero", 3+random(0, 3), TID_REMOVE, random(0, 359));
        case 3:
        case 2:
        case 1:
            SpawnSpotForced("MechaRomero", 7+random(0, 3), TID_REMOVE, random(0, 359));
            break;
    }
    SpawnSpotForced("TeleportFog", 1, TID_REMOVE, 0);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Raise the floor
    floor_raisebyvalue(20, 8, 64);
    floor_raisebyvalue(21, 8, 64);
    floor_raisebyvalue(22, 8, 64);
    floor_raisebyvalue(691, 8, 64);
    floor_raisebyvalue(692, 8, 64);
    floor_raisebyvalue(693, 8, 64);

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10-(SECOND*game_speed));

    // Move things back
    floor_lowerbyvalue(20, 8, 64);
    floor_lowerbyvalue(21, 8, 64);
    floor_lowerbyvalue(22, 8, 64);
    floor_lowerbyvalue(691, 8, 64);
    floor_lowerbyvalue(692, 8, 64);
    floor_lowerbyvalue(693, 8, 64);
    SetActorPosition (88, GetActorX (88), GetActorY (88), GetActorZ (88)-128.0, 0);
}

Script "DoomWare_Server_Minigame34" (void) // Survive (Hoth)
{
    HUDMessage(s:"Survive (Hoth)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_hoth");
    round_winifmid = true;
    minigame_fragpoints = true;
    Add_Observer(576);
    Add_Observer(776);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 880, false, true);

    // Spawn a lot of different objects
    SpawnSpotForced("ATST", 246, TID_REMOVE, random(0, 359));
    SetThingSpecial(TID_REMOVE, ACS_ExecuteAlways, 14);
    SpawnSpotForced("HothTurret", 247, TID_REMOVE, random(0, 359));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*14-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame35" (void) // Climb the Colossus
{
    HUDMessage(s:"Climb the Colossus"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_sotc");

    // Start the rain
    SetActorState(577, "Activated");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 819, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*25-(SECOND*game_speed));

    // Return players back and stop the rain
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
    SetActorState(577, "Deactivated");
}

Script "DoomWare_Server_Minigame36" (void) // Get on the Colored Circle
{
    int color = random(0, 3);
    int i;
    HUDMessage(s:"Get on the Colored Circle"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_twistr");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 248, true, true);

    // Display the color after a while
    delay(35);
    switch (color)
    {
        case 0:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANBLUE");
            break;
        case 1:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANGRN");
            break;
        case 2:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANRED");
            break;
        case 3:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANYEL");
            break;
    }
    delay(SECOND*2-(10*game_speed));

    // Lower the floors
    for (i=0; i<5; i++)
    {
        if (i == color)
            continue;
        Floor_LowerInstant(111+i, 0, 16);
        Sector_setDamage(111+i, 200000, MOD_LAVA);
        ChangeFloor(111+i, "WFLAVA1");
    }
    delay(70);

    // Return the players
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Raise the floors back up
    for (i=0; i<5; i++)
    {
        if (i == color)
            continue;
        Floor_RaiseInstant(111+i, 0, 16);
        Sector_setDamage(111+i, 0, MOD_UNKNOWN);
        switch (i)
        {
            case 0:
                ChangeFloor(111, "TRANBLUE");
                break;
            case 1:
                ChangeFloor(112, "TRANGRN");
                break;
            case 2:
                ChangeFloor(113, "TRANRED");
                break;
            case 3:
                ChangeFloor(114, "TRANYEL");
                break;
            case 4:
                ChangeFloor(115, "PURE");
                break;
        }

    }
    SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "PURE");
}

Script "DoomWare_Server_Minigame37" (void) // Dive Down
{
    HUDMessage(s:"Dive Down"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_water");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 249, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*3+17-(10*game_speed));

    do
    {
        delay(1);

        // Make the player win if they're deep enough
        for (int i=0; i<MAXPLAYERS; i++)
            if (GetActorZ(TID_PLAYER+i) < 50.0)
                Player_Win(i);
    }
    while(minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame38" (void) // Repeat the Pattern
{
    int caco1, caco2, caco3, caco4;
    int i, j;
    hudmessage(s:"Repeat The Pattern"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_STALKS");
    caco1 = random(0, 5);
    caco2 = random(0, 5);
    caco3 = random(0, 5);
    caco4 = random(0, 5);
    minigame_canmove = false;
    minigame_invisiblehats = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 310, false, true);

    // Clear out player solutions
    for (i=0; i<MAXPLAYERS; i++)
        for (j=0; j<4; j++)
            player_answer2[i][j] = -1;

    // Show the cacodemons to shoot
    delay(35);
    thing_damage(326+caco1, 1, 0);
    delay(SECOND-(5*game_speed));
    thing_damage(326+caco2, 1, 0);
    delay(SECOND-(5*game_speed));
    thing_damage(326+caco3, 1, 0);
    delay(SECOND-(5*game_speed));
    thing_damage(326+caco4, 1, 0);
    delay(SECOND-(5*game_speed));

    // Give time for the players to spit their answers
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5 + 15);

    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            if (player_answer1[i] > 0)
                player_answer1[i]--;

            for (j=0; j<4; j++)
            {
                if (player_answer2[i][j] == -1)
                    break;

                switch(j)
                {
                    case 0:
                        if (player_answer2[i][0] != caco1)
                            Player_Lose(i, false);
                        break;
                    case 1:
                        if (player_answer2[i][1] != caco2)
                            Player_Lose(i, false);
                        break;
                    case 2:
                        if (player_answer2[i][2] != caco3)
                            Player_Lose(i, false);
                        break;
                    case 3:
                        if (player_answer2[i][3] != caco4)
                            Player_Lose(i, false);
                        else
                            Player_Win(i);
                        break;
                }
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame39" (void) // Storm the Beach
{
    hudmessage(s:"Storm the beach"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_omaha");
    Add_Observer(777);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 340, false, true);

    // Spawn some horrible hitscanners
    SpawnSpotForced("ChaingunGuy", 1000, TID_REMOVE, 128);
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Give time for the players to reach the beach
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5-(2*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame40" (void) // Survive (Dark Corridors)
{
    hudmessage(s:"Survive (Dark Corridors)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_doom");
    minigame_fragpoints = true;
    minigame_invisiblehats = true;
    round_winifmid = true;
    Add_Observer(778);
    Add_Observer(779);
    Add_Observer(797);
    Add_Observer(796);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 360, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame41" (void) // Go To The Light
{
    int i;
    hudmessage(s:"Go To The Light"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_AMPIE");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 206, true, true);

    // Pick a random sector to mark as safe
    int ceil = random(0, 11);
    Light_ChangeToValue(116+ceil, 256);
    delay(SECOND-(5*game_speed));

    // Lower the ceiling
    for (i=0; i<13; i++)
        if (i != ceil)
            Ceiling_LowerAndCrush(116+i, 20+(2*game_speed), 100, 1);
    delay(SECOND*3+17 -(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Raise the ceiling back up
    for (i=0; i<13; i++)
        if (ceil != i)
            Ceiling_RaiseByValue(116+i, 16, 256);
    Light_ChangeToValue(116+ceil, 16);
}

Script "DoomWare_Server_Minigame42" (void) // Survive (Rockets)
{
    hudmessage(s:"Survive (Rockets)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_ROCKET");
    Add_Observer(656);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 226, true, true);

    //Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*13-(SECOND*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame43" (void) // Zorch a Flemoid
{
    HUDMessage(s:"Zorch a Flemoid"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_Chex");
	
	// Spawn the Flemoid invaders
	SpawnSpotFacingForced("Flemoid", 995, TID_REMOVE);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 994, true, true);
	
    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10-(10*game_speed));
	
    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame44" (void) // Reach the End (Void)
{
	int i;
    HUDMessage(s:"Reach the End (Void)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_void");
	minigame_wincondition1 = 0; // This is a bit field that tells us which platforms are raised
	Add_Observer(965);
	Add_Observer(984);
	Add_Observer(985);
	
	// Spawn some Imps
	SpawnSpotForced("DoomImpVoid", 963, TID_REMOVE, 180);
	SpawnSpotForced("DoomImpVoid", 964, TID_REMOVE+1, 180);
	thing_settranslation(TID_REMOVE, 16);
	thing_settranslation(TID_REMOVE+1, 17);
	Thing_ChangeTID(TID_REMOVE+1, TID_REMOVE);
	
	// Make the map move all fancy
	ACS_NamedExecute("DoomWare_VoidMapBooks", 0);
	ACS_NamedExecute("DoomWare_VoidMapLights", 0);
	ACS_NamedExecute("DoomWare_VoidMapSky", 0);
	ACS_NamedExecute("DoomWare_VoidMapPillars", 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 966, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*20-(SECOND*game_speed));
	
    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame45" (void) // Finish a Lap (Rainbow Road)
{
    HUDMessage(s:"Finish a Lap (Rainbow Road)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_rainbw");
    Add_Observer(798);
    Add_Observer(579);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 380, false, true);

    // Countdown until players can move
    SpawnSpotForced("Lakitu", 358, THING_REMOVE, 0);
    delay(SECOND*2);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*39-(SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame46" (void) // Reach the End (Bigger Swapping Boxes)
{
    int time = SECOND*28+20-(14*game_speed);
    int box = 0;
    Add_Observer(596);
    hudmessage(s:"Reach the End (Bigger Swapping Boxes)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_boxes");
    Sector_SetDamage(136, 10000, MOD_FALLING);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 420, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, time);

    // Make the boxes swap
    time = 0;
    do
    {
        int i;
        time++;
        if (time == 89)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "\cd3";
        else if (time == 89+17)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "\ci2";
        else if (time == 89+34)
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "\cg1";
        else if (time == 89+51)
        {
            time = 0;
            for (i=0; i<MAXPLAYERS; i++)
                minigame_instruction3[i] = "";
            if (box == 0)
            {
                Floor_LowerInstant(135, 0, 32);
                Floor_RaiseInstant(136, 0, 32);
                Floor_LowerInstant(137, 0, 36);
                Floor_RaiseInstant(138, 0, 40);
                Floor_LowerInstant(139, 0, 44);
                ChangeFloor(136, "DEM4_5");
                ChangeFloor(138, "DEM4_5");
                ChangeFloor(135, "f_sky1");
                ChangeFloor(137, "f_sky1");
                ChangeFloor(139, "f_sky1");
                Sector_SetDamage(136, 0, MOD_FALLING);
                Sector_SetDamage(138, 0, MOD_FALLING);
                Sector_SetDamage(135, 10000, MOD_FALLING);
                Sector_SetDamage(137, 10000, MOD_FALLING);
                Sector_SetDamage(139, 10000, MOD_FALLING);
                box = 1;
            }
            else
            {
                Floor_RaiseInstant(135, 0, 32);
                Floor_LowerInstant(136, 0, 32);
                Floor_RaiseInstant(137, 0, 36);
                Floor_LowerInstant(138, 0, 40);
                Floor_RaiseInstant(139, 0, 44);
                ChangeFloor(136, "f_sky1");
                ChangeFloor(138, "f_sky1");
                ChangeFloor(135, "DEM3_5");
                ChangeFloor(137, "DEM3_5");
                ChangeFloor(139, "DEM3_5");
                Sector_SetDamage(136, 10000, MOD_FALLING);
                Sector_SetDamage(138, 10000, MOD_FALLING);
                Sector_SetDamage(135, 0, MOD_FALLING);
                Sector_SetDamage(137, 0, MOD_FALLING);
                Sector_SetDamage(139, 0, MOD_FALLING);
                box = 0;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Fix the boxes
    if (box == 1)
    {
        Floor_RaiseInstant(135, 0, 32);
        Floor_LowerInstant(136, 0, 32);
        Floor_RaiseInstant(137, 0, 36);
        Floor_LowerInstant(138, 0, 40);
        Floor_RaiseInstant(139, 0, 44);
        ChangeFloor(136, "f_sky1");
        ChangeFloor(138, "f_sky1");
        ChangeFloor(135, "DEM3_5");
        ChangeFloor(137, "DEM3_5");
        ChangeFloor(139, "DEM3_5");
        Sector_SetDamage(136, 10000, MOD_FALLING);
        Sector_SetDamage(138, 10000, MOD_FALLING);
        Sector_SetDamage(135, 0, MOD_FALLING);
        Sector_SetDamage(137, 0, MOD_FALLING);
        Sector_SetDamage(139, 0, MOD_FALLING);
    }
}

Script "DoomWare_Server_Minigame47" (void) // Survive (Banana)
{
    HUDMessage(s:"Survive (Banana)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_banana");
    round_winifmid = true;

    // Spawn some warnings
    SpawnSpotForced("Avoid", 1, TID_REMOVE, random(0, 359));
    if (game_speed > 1)
        SpawnSpotForced("Avoid", 57, TID_REMOVE, random(0, 359));
    if (game_speed == 4)
        SpawnSpotForced("Avoid", 59, TID_REMOVE, random(0, 359));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));
    delay(SECOND*4-(game_speed*17));

    // Spawn the banana
    SpawnSpotForced("Banana", TID_REMOVE, TID_REMOVE+1, random(0, 359));
    thing_destroy(TID_REMOVE, 0);
    delay(SECOND*2);
}

Script "DoomWare_Server_Minigame48" (void) // Survive (Spike)
{
    HUDMessage(s:"Survive (Banana)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_spiky");
    round_winifmid = true;

    // Spawn some warnings
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Avoid", 5, TID_REMOVE+1, random(0, 359));
        case 3:
            SpawnSpotForced("Avoid", 3, TID_REMOVE+1, random(0, 359));
        case 2:
            SpawnSpotForced("Avoid", 9, TID_REMOVE+1, random(0, 359));
        case 1:
            SpawnSpotForced("Avoid", 7, TID_REMOVE+1, random(0, 359));
        default:
            SpawnSpotForced("Avoid", 1, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 58, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 59, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 60, TID_REMOVE+1, random(0, 359));
            SpawnSpotForced("Avoid", 57, TID_REMOVE+1, random(0, 359));
            break;
    }
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));
    delay(SECOND*3-(game_speed*7));

    // Spawn the spikes
    SpawnSpotForced("LilithSpikeSpawner", TID_REMOVE+1, TID_REMOVE, random(0, 359));
    thing_destroy(TID_REMOVE+1, 0);
    delay(SECOND + 17);
}

Script "DoomWare_Server_Minigame49" (void) // Math
{
    int i;
    HUDMessage(s:"Math"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_MATH");

    // Create a problem
    int operation = random(0, 2);
    int result;
    minigame_wincondition3 = operation;
    minigame_invisiblehats = true;
    switch (operation)
    {
        case 0:
            minigame_wincondition1 = random(0, 49);
            minigame_wincondition2 = random(0, 50);
            result = minigame_wincondition1 + minigame_wincondition2;
            break;
        case 1:
            minigame_wincondition1 =  random(50, 99);
            minigame_wincondition2 =  random(0, 50);
            result = minigame_wincondition1 - minigame_wincondition2;
            breaK;
        case 2:
            minigame_wincondition1 =  random(0, 10);
            minigame_wincondition2 =  random(0, 9);
            result = minigame_wincondition1 * minigame_wincondition2;
            break;
    }

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 400, false, true);

    // Clear out player solutions
    for (i=0; i<MAXPLAYERS; i++)
        for (int j=0; j<2; j++)
            player_answer2[i][j] = -1;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5 - (game_speed*7));

    // Check if the user spat out the correct answer
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;

            if (player_answer1[i] > 0)
                player_answer1[i]--;

            if ((result < 10 && player_answer2[i][0] == -1) || (result >= 10 && player_answer2[i][1] == -1))
                continue;

            if (result < 10)
            {
                if (player_answer2[i][0] == result)
                    Player_Win(i);
                else
                    Player_Lose(i, false);
            }
            else
            {
                if (player_answer2[i][0] == result/10 && player_answer2[i][1] == result%10)
                    Player_Win(i);
                else
                    Player_Lose(i, false);
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame50" (void) // Survive (Bullet Hell)
{
    HUDMessage(s:"Survive (Bullet Hell)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_trotle");
    Add_Observer(597);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 338, true, true);

    // Spawn Lilith, from the WAD I never finished making :(
    SpawnSpotForced("Lilith", 339, TID_REMOVE, 192);
    NoiseAlert(TID_PLAYER, TID_PLAYER);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4+17 + (SECOND*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Award survivors with an achievement
    delaY(2);
    for (int i=0; i<MAXPLAYERS; i++)
        if (player_midround[i] == true)
            Give_Achievement(i, ACHIEVE_ID_BULLETHELL);
}

Script "DoomWare_Server_Minigame51" (void) // Clean your weapon
{
    HUDMessage(s:"Clean your weapon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CLEAN");
    minigame_wincondition1 = 1337; // To force a 320x240 viewsprite

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*14+10-(12*game_speed));
}

Script "DoomWare_Server_Minigame52" (void) // Gib a Turkey
{
    HUDMessage(s:"Gib a Turkey"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_TURKEY");

    // Spawn some turkeys to gib
    SpawnSpot("Turkey", 919, TID_REMOVE);

    // Teleport everyone to the arena and start a timer
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 918, true, true);
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*9-(20*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
    
    // Teleport the players back to the main arena
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false);
}

Script "DoomWare_Server_Minigame53" (void) // Drink
{
    HUDMessage(s:"Drink"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DRINK");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7+5-(12*game_speed));
}

Script "DoomWare_Server_Minigame54" (void) // Survive (Chilli)
{
    HUDMessage(s:"Survive (Chilli)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_wtfbmb");
    round_winifmid = true;

    // Create some warnings
    SpawnSpotForced("Avoid", 1, TID_REMOVE+1, random(0, 359));
    switch (game_speed)
    {
        case 4:
            SpawnSpotForced("Avoid", 59, TID_REMOVE+1, random(0, 359));
        case 3:
        case 2:
            SpawnSpotForced("Avoid", 57, TID_REMOVE+1, random(0, 359));
            break;
    }
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));
    delay(SECOND*4-(game_speed*17));

    // Spawn the chilli
    SetMusic("");
    SpawnSpotForced("Chilli", TID_REMOVE+1, TID_REMOVE, random(0, 359));
    thing_destroy(TID_REMOVE+1, 0);
    delay(SECOND + 18);

    // Make the world tremble at the sight of it's spicyness
    Radius_Quake2(1, 5, SECOND*3+21, 0, 512, "DoomWare/IceMove");
    delay(SECOND*3+21);
}

Script "DoomWare_Server_Minigame55" (void) // Hit the Real Barrel
{
    HUDMessage(s:"Hit the Real Barrel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_BRLCHS");

    // Spawn a bunch of fake and real explosive barrels
    int real = random(1, 9);
    for (int i=1; i<8; i++)
        if (real != i)
            SpawnSpot ("ExplosiveBarrelLegs", 2+i, TID_REMOVE);
    if (real != 9)
        SpawnSpot ("ExplosiveBarrelLegs", 1, TID_REMOVE);
    if (real == 9)
        SpawnSpot ("ExplosiveBarrelReal", 1, TID_REMOVE);
    else
        SpawnSpot ("ExplosiveBarrelReal", 2+real, TID_REMOVE);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6+10-(20*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        Check_FailRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame56" (void) // Survive (Spike Circle)
{
    HUDMessage(s:"Survive (Spike Circle)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Factry");
    round_winifmid = true;
    Add_Observer(598);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 460, false, true);

    // Activate the rotaty dead spikes of doom
    thing_activate(64);
    thing_activate(65);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*8+20+(20*game_speed));

    // Give the spikes a break
    thing_deactivate(64);
    thing_deactivate(65);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame57" (void) // Eat The Chocolate
{
    HUDMessage(s:"Eat The Chocolate"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DRINK");

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4+15-(12*game_speed));
}

Script "DoomWare_Server_Minigame58" (void) // Survive (Wind)
{
    HUDMessage(s:"Survive (Wind)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_MUNCH");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 359, true, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+20-(12*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame59" (void) // Get to Hissy
{
    HUDMessage(s:"Get to Hissy"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    setMusic("D_HISSY");
    Add_Observer(616);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 480, false, true);

    // Spawn the Hissy hogger himself
    SpawnSpotForced("Linguica", 376, TID_REMOVE, 192);
    switch(game_speed)
    {
        case 4:
            SpawnSpotForced("Linguica", 379, TID_REMOVE, 192);
        case 3:
        case 2:
            SpawnSpotForced("Linguica", 378, TID_REMOVE, 192);
            break;
    }

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*8+20-(10*game_speed));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame60" (void) // Count the Lost Souls
{
    int i;
    HUDMessage(s:"Count The Lost Souls"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_count");
    minigame_wincondition1 = 0;
    minigame_invisiblehats = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 500, false, true);

    // Clear out player solutions
    for (i=0; i<MAXPLAYERS; i++)
        for (int j=0; j<2; j++)
            player_answer2[i][j] = -1;

    // Spawn some Lost Souls, or some rockets if the game speed is high enough
    int fakes = 0;
    int result = random(10, 14+4*game_speed);
    minigame_wincondition1 = 0;
    for (i=0;i<result;i++)
    {
        if (game_speed > 2 && random(1, 10) == 1)
        {
            fakes++;
            SpawnForced("FakeRocket", GetActorX(397)+random(0, +64.0), GetActorY(397)+random(-64.0, +64.0), GetActorz(397)+random(-32.0, +32.0), TID_REMOVE+1, 0);
            SetActorVelocity(TID_REMOVE+1, 10.0, 0, 0, 0, 0);
            Thing_ChangeTID(TID_REMOVE+1, TID_REMOVE);
        }
        else
            SpawnForced("SkullCounter", GetActorX(397)+random(0, +64.0), GetActorY(397)+random(-64.0, +64.0), GetActorz(397)+random(-32.0, +32.0), TID_REMOVE, 0);
        delay(18-random(5-game_speed, 7));
    }
    result -= fakes;
    delay(SECOND*2);

    // Move the players to the numbers
    minigame_wincondition1 = 1;
    for (i=0; i<MAXPLAYERS; i++)
        thing_move(TID_PLAYER+i, 400+i, false);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5+15-(game_speed*7));

    // Check if the user spat out the correct answer
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;

            if (player_answer1[i] > 0)
                player_answer1[i]--;

            if (result >= 10 && player_answer2[i][1] == -1)
                continue;

            if (player_answer2[i][0] == result/10 && player_answer2[i][1] == result%10)
                Player_Win(i);
            else
                Player_Lose(i, false);
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame61" (void) // Reach the End (Hurdles)
{
    HUDMessage(s:"Reach the End (Hurdles)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_HURDLE");
    Add_Observer(617);
    minigame_canmove = false;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 520, false, true);

    // Spawn a wall to prevent players from going forward
    SpawnSpotForced("InvisibleBridge32", 398, TID_REMOVE, 0);
    delay(4);
    thing_remove(TID_REMOVE);

    // Countdown until players can move
    delay(SECOND*2+26);
    minigame_canmove = true;

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*12+10-(17*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame62" (void) // Cross the Road
{
    int time = 0;
    hudmessage(s:"Cross the Road"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CHICKN");
    Add_Observer(618);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 540, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*8+20-(15*game_speed));

    // Keep the roads busy
    do
    {
        if (time == 0)
        {
            int tran = random(11, 16);
            SpawnProjectile(random(416, 417), "DangerousCar", 0, 256, 0, 0, TID_REMOVE);
            if (tran != 16)
                Thing_SetTranslation(TID_REMOVE, tran);
            Thing_ChangeTID(TID_REMOVE, TID_REMOVE+1);

            tran = random(11, 16);
            SpawnProjectile(random(418, 419), "DangerousCar", 128, 256, 0, 0, TID_REMOVE);
            if (tran != 16)
                Thing_SetTranslation(TID_REMOVE, tran);
            Thing_ChangeTID(TID_REMOVE, TID_REMOVE+1);

            time = random(15, 70);
        }
        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame63" (void) // Collect a Potion
{
    hudmessage(s:"Collect a Potion"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_THIEF");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 399, true, true);

    // Spawn some thiefs
    SpawnSpotForced("BlueThief", 437, TID_REMOVE, random(0, 256));
    NoiseAlert(TID_PLAYER+random(0, PlayerCount()-1), TID_PLAYER+random(0, PlayerCount()-1));

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+25-(15*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame64" (void) // Reach the End (Skyhook)
{
    int i;
    hudmessage(s:"Reach the End (Skyhook)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_SKYHOK");

    // Place the polyobjects in the correct place.
    for (i=0; i<8; i++)
    {
        switch (random(1, 4))
        {
            case 1:
                SetLineTexture(2+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
                SetLineTexture(2+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
                SetLineTexture(3+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
                SetLineTexture(3+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
                SetLineTexture(4+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB1");
                SetLineTexture(4+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB1");
                Polyobj_MoveTo(0+i*4, 128, 10592, 3584+384*i);
                Polyobj_MoveTo(1+i*4, 128, 10784, 3584+384*i);
                break;
            case 2:
                SetLineTexture(2+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
                SetLineTexture(2+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
                SetLineTexture(3+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
                SetLineTexture(3+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
                SetLineTexture(4+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
                SetLineTexture(4+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
                Polyobj_MoveTo(0+i*4, 128, 10592, 3584+384*i);
                Polyobj_MoveTo(2+i*4, 128, 10592, 3584+384*i);
                break;
            case 3:
                SetLineTexture(2+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
                SetLineTexture(2+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
                SetLineTexture(3+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
                SetLineTexture(3+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
                SetLineTexture(4+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB3");
                SetLineTexture(4+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB3");
                Polyobj_MoveTo(2+i*4, 128, 10592, 3584+384*i);
                Polyobj_MoveTo(3+i*4, 128, 10784, 3584+384*i);
                break;
            case 4:
                SetLineTexture(2+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB4");
                SetLineTexture(2+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB2");
                SetLineTexture(3+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
                SetLineTexture(3+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
                SetLineTexture(4+i*3, SIDE_FRONT, TEXTURE_MIDDLE, "SKYHOKB2");
                SetLineTexture(4+i*3, SIDE_BACK, TEXTURE_MIDDLE, "SKYHOKB4");
                Polyobj_MoveTo(1+i*4, 128, 10784, 3584+384*i);
                Polyobj_MoveTo(3+i*4, 128, 10784, 3584+384*i);
                break;
        }
    }

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 560, false, true);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*8-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Reset the Skyhook
    for (i=0; i<8; i++)
    {
        Polyobj_MoveTo(0+i*4, 128, 11024, 3584+384*i);
        Polyobj_MoveTo(1+i*4, 128, 11248, 3584+384*i);
        Polyobj_MoveTo(2+i*4, 128, 11472, 3584+384*i);
        Polyobj_MoveTo(3+i*4, 128, 11696, 3584+384*i);
    }
}

Script "DoomWare_Server_Minigame65" (void) // Spam the Indicated Button
{
    int time = random(15, SECOND*2);
    hudmessage(s:"Spam the Indicated Button"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_BUTCHG");
    minigame_wincondition1 = 1337; // To force a 320x240 viewsprite
    minigame_wincondition2 = 0;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*11+20-(5*game_speed));

    // Consantly change the objective
    do
    {
        time--;
        if (time == 0)
        {
            AmbientSound("DoomWare/ButtonChange", 127);
            switch (minigame_wincondition2)
            {
                case 0:
                    minigame_wincondition2 = random(1, 2);
                    time = random(SECOND, SECOND*2);
                    break;
                case 1:
                    minigame_wincondition2 = random(0, 2);
                    if (minigame_wincondition2 == 1)
                        minigame_wincondition2 = 0;
                    time = random(SECOND, SECOND*2);
                    break;
                case 2:
                    minigame_wincondition2 = random(0, 1);
                    time = random(SECOND, SECOND*2);
                    break;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame66" (void) // Don't Get Wet
{
    int i;
    hudmessage(s:"Don't Get Wet"; HUDMSG_LOG, MSGID_CONSOLE, cr_black, 2.0, 2.0, 0);
    SetMusic("D_AMPIE");
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 439, true, true);

    // Spawn an umbrella
    int ceil2 = random(0, 4);
    if (ceil2 == 4)
        SpawnSpotForced("Umbrella", 476, TID_REMOVE, random(0, 256));
    else
        SpawnSpotForced("Umbrella", 456+ceil2, TID_REMOVE, random(0, 256));
    delay(SECOND-(5*game_speed));

    // Start the downpour
    if (ceil2 == 0)
    {
        Ceiling_LowerByValue(173, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(174, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(175, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(173, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(174, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(175, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 1)
    {
        Ceiling_LowerByValue(176, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(177, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(178, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(176, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(177, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(178, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 2)
    {
        Ceiling_LowerByValue(163, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(164, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(165, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(163, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(164, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(165, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 3)
    {
        Ceiling_LowerByValue(167, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(168, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(169, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(167, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(168, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(169, 24+(2*game_speed), 100, 1);
    }

    if (ceil2 == 4)
    {
        Ceiling_LowerByValue(170, 24+(2*game_speed), 232);
        Ceiling_LowerByValue(171, 24+(2*game_speed), 256);
        Ceiling_LowerByValue(172, 24+(2*game_speed), 296);
    }
    else
    {
        Ceiling_LowerAndCrush(170, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(171, 24+(2*game_speed), 100, 1);
        Ceiling_LowerAndCrush(172, 24+(2*game_speed), 100, 1);
    }

    for (i=0; i<16; i++)
        ChangeCeiling(163+i, "WFWater1");

    Ceiling_LowerAndCrush(166, 24+(2*game_speed), 100, 1);
    delay(SECOND*4+15-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Raise the water back up
    for (i=0; i<16; i++)
        ChangeCeiling(163+i, "F_SKY1");
    Ceiling_RaiseByValue(166, 64, 384);
    if (ceil2 == 0)
    {
        Ceiling_RaiseByValue(173, 64, 232);
        Ceiling_RaiseByValue(174, 64, 256);
        Ceiling_RaiseByValue(175, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(173, 64, 384);
        Ceiling_RaiseByValue(174, 64, 384);
        Ceiling_RaiseByValue(175, 64, 384);
    }

    if (ceil2 == 1)
    {
        Ceiling_RaiseByValue(176, 64, 232);
        Ceiling_RaiseByValue(177, 64, 256);
        Ceiling_RaiseByValue(178, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(176, 64, 384);
        Ceiling_RaiseByValue(177, 64, 384);
        Ceiling_RaiseByValue(178, 64, 384);
    }

    if (ceil2 == 2)
    {
        Ceiling_RaiseByValue(163, 64, 232);
        Ceiling_RaiseByValue(164, 64, 256);
        Ceiling_RaiseByValue(165, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(163, 64, 384);
        Ceiling_RaiseByValue(164, 64, 384);
        Ceiling_RaiseByValue(165, 64, 384);
    }

    if (ceil2 == 3)
    {
        Ceiling_RaiseByValue(167, 64, 232);
        Ceiling_RaiseByValue(168, 64, 256);
        Ceiling_RaiseByValue(169, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(167, 64, 384);
        Ceiling_RaiseByValue(168, 64, 384);
        Ceiling_RaiseByValue(169, 64, 384);
    }

    if (ceil2 == 4)
    {
        Ceiling_RaiseByValue(170, 64, 232);
        Ceiling_RaiseByValue(171, 64, 256);
        Ceiling_RaiseByValue(172, 64, 296);
    }
    else
    {
        Ceiling_RaiseByValue(170, 64, 384);
        Ceiling_RaiseByValue(171, 64, 384);
        Ceiling_RaiseByValue(172, 64, 384);
    }

}

Script "DoomWare_Server_Minigame67" (void) // Reach the End (Factory Line)
{
    HUDMessage(s:"Reach The End (Factory)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_Factry");
    Add_Observer(799);
    Add_Observer(800);
    Add_Observer(636);
    Add_Observer(801);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 438, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*37+5-((SECOND+5)*game_speed));

    // Spawn some Flamethrowers
    SpawnSpotForced("FlameProjectiler", 477, TID_REMOVE, 0);
    SpawnSpotForced("FlameProjectiler", 479, TID_REMOVE, 128);
    delay(SECOND*2);
    SpawnSpotForced("FlameProjectiler", 478, TID_REMOVE, 0);

    while (minigame_timer != TIMER_OFF)
        delay(1);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame68" (void) // Pick Up The Key
{
    HUDMessage(s:"Pick Up The Key"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_twistr");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 496, true, true);

    // Spawn the cards
    SpawnSpotForced("YellowCard", 497, TID_REMOVE, 0);
    SpawnSpotForced("BlueCard", 498, TID_REMOVE+1, 0);
    SpawnSpotForced("RedCard", 499, TID_REMOVE+2, 0);
    Thing_SetSpecial(TID_REMOVE, 226, 243, 0, 0);
    Thing_SetSpecial(TID_REMOVE+1, 226, 243, 0, 1);
    Thing_SetSpecial(TID_REMOVE+2, 226, 243, 0, 2);

    // Randomly pick the winning key
    minigame_wincondition1 = random(0, 2);
    delay(SECOND);
    switch (minigame_wincondition1)
    {
        case 0:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANBLUE");
            break;
        case 1:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANRED");
            break;
        case 2:
            SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "TRANYEL");
            break;
    }

    // Give players time to catch the key
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*3-(10*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Reset the color
    SetLineTexture(1, SIDE_FRONT, TEXTURE_BOTTOM, "PURE");
}

Script "DoomWare_Server_Minigame69" (void) // Survive (Hell Deathmatch)
{
    HUDMessage(s:"Survive (Hell Deathmatch)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_DINO");
    round_winifmid = true;
    Add_Observer(802);
    Add_Observer(803);
    Add_Observer(804);
    Add_Observer(637);
    Add_Observer(805);
    Add_Observer(806);
    Add_Observer(807);
    minigame_fragpoints = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 580, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*22+30-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame70" (void) // Eat
{
    HUDMessage(s:"Eat"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_sushi");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 600, false, true);

    // Spawn the food
    minigame_wincondition1 = random(0, 1);
    SpawnSpotForced("1UP", 704, TID_REMOVE, 0);
    SpawnSpotForced("Food_Toro", 516, TID_REMOVE, 0);
    int thingy = random(0, 1);
    if (thingy == 1)
        SpawnSpotForced("Food_SalmonRoll1", 639, TID_REMOVE, 0);
    else
        SpawnSpotForced("Food_SalmonRoll2", 639, TID_REMOVE, 0);
    SpawnSpotForced("Food_Shrimp", 657, TID_REMOVE, 0);
    SpawnSpotForced("Food_EggRoll", 658, TID_REMOVE, 0);
    thingy = random(0, 1);
    if (thingy == 1)
        SpawnSpotForced("Food_Sushi1", 659, TID_REMOVE, 0);
    else
        SpawnSpotForced("Food_Sushi1", 659, TID_REMOVE, 0);
    SpawnSpotForced("Food_Tea", 675, TID_REMOVE, 0);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*7-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame71" (void) // Find a Pokemon
{
    HUDMessage(s:"Find a Pokemon"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_pkmn");
    SpawnSpotForced("PokemonTrigger", 517, TID_REMOVE, 0);
    minigame_wincondition1 = 1338; // To force a 20x18 viewsprite

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 620, false, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4-(7*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame72" (void) // Survive (Disappearing Floor)
{
    int i;
    int dropped = 0;
    int state = 0;
    bool firstdrop = true;
    round_winifmid = true;
    HUDMessage(s:"Survive (Disappearing Floor)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_twistr");
    Add_Observer(638);

    // We'll make use of the player_answer variables to save up on making more globals
    // Start by filling in a list of all numbers from 1 to 9
    for (i=0; i<9; i++)
        player_answer1[i] = i;

    // Shuffle that array
    for (i=0; i<9; i++)
    {
        int j = random(i, 8);
        int k = player_answer1[i];
        player_answer1[i] = player_answer1[j];
        player_answer1[j] = k;
    }

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 519, true, true);

    // Start the timer
    int time = SECOND*2 + ((8-game_speed)*6)*8 + (SECOND-game_speed*2)*8;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, time);
    time = SECOND*2;

    // Handle the floors
    do
    {
        time--;
        if (time == 0 && dropped != 8)
        {
            switch(state)
            {
                case 4:
                case 2:
                case 0:
                    changefloor(193+player_answer1[dropped], "TRANYEL");
                    SectorSound("doomware/blip", 127);
                    time = (8-game_speed);
                    if (firstdrop)
                    {
                        // Warn newcomers to avoid the color
                        int sector = player_answer1[dropped];
                        SpawnSpotForced("Avoid", 519, TID_REMOVE, 0);
                        SetActorPosition(TID_REMOVE, GetActorX(TID_REMOVE)-213.0+213.0*(sector%3), GetActorY(TID_REMOVE)+213.0-213.0*(sector/3), GetActorZ(TID_REMOVE), false);
                        Thing_Destroy(TID_REMOVE, false, 0);
                        firstdrop = false;
                    }
                    break;
                case 5:
                case 3:
                case 1:
                    changefloor(193+player_answer1[dropped], "PURE");
                    time = (8-game_speed);
                    break;
                case 6:
                    SectorSound("doomware/bloop", 127);
                    Floor_LowerInstant(193+player_answer1[dropped], 0, 16);
                    Sector_setDamage(193+player_answer1[dropped], 200000, MOD_LAVA);
                    ChangeFloor(193+player_answer1[dropped], "WFLAVA1");
                    dropped++;
                    time = (SECOND-game_speed*2);
                    break;
            }
            state = (state+1)%7;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Put the floors back to normal
    for (i=0;i<9;i++)
    {
        if (i < dropped)
        {
            Floor_RaiseInstant(193+player_answer1[i], 0, 16);
            Sector_setDamage(193+player_answer1[i], 0, MOD_LAVA);
        }
        ChangeFloor(193+player_answer1[i], "PURE");
    }
}

Script "DoomWare_Server_Minigame73" (void) // Mine an ore
{
    HUDMessage(s:"Mine an ore"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_snight");
    minigame_wincondition1 = random(0, 2);

    // Spawn the ores
    SpawnSpotForced("GoldOre", 676, TID_REMOVE, 0);
    SpawnSpotForced("TinOre", 677, TID_REMOVE, 0);
    SpawnSpotForced("MithrilOre", 678, TID_REMOVE, 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 640, false, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+25-(10*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame74" (void) // Reach the End (Eclipse)
{
    HUDMessage(s:"Reach the End (Eclipse)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_eclpse");
    Add_Observer(808);
    Add_Observer(809);
    Add_Observer(810);
    Add_Observer(687);
    Add_Observer(811);
    Add_Observer(812);

    // Spawn Apostles
    SpawnSpotForced("BaronOfHell2", 680, TID_REMOVE, 128);
    SpawnSpotForced("Demon3", 681, TID_REMOVE, 128);
    SpawnSpotForced("TentacleWorm", 682, TID_REMOVE, 128);
    SpawnSpotForced("Aguares", 683, TID_REMOVE, 128);
    SpawnSpotForced("ForbiddenOne", 684, TID_REMOVE, 128);
    SpawnSpotForced("SlimyWorm", 685, TID_REMOVE, 128);
    if (game_speed > 2)
        SpawnSpotForced("Cacodemon2", 686, TID_REMOVE, 128);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 660, false, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*25+25-(20*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame75" (void) // Reach the end (Automap)
{
    HUDMessage(s:"Reach the end (Automap)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_countd");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 897, true, true);

    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+25-(5*game_speed));

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame76" (void) // Score a Basketball
{
    HUDMessage(s:"Score a Basketball"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_bball");

    // Spawn some Spectators
    SpawnSpotForced("ScriptedMarine", 108, TID_REMOVE, 0);
    SpawnSpotForced("ScriptedMarine", 309, TID_REMOVE, 64);
    SpawnSpotForced("ScriptedMarine", 334, TID_REMOVE, 128);
    SpawnSpotForced("ScriptedMarine", 336, TID_REMOVE, 192);
    SpawnSpotForced("ScriptedMarine", 332, TID_REMOVE, 32);
    SpawnSpotForced("ScriptedMarine", 333, TID_REMOVE, 96);
    SpawnSpotForced("ScriptedMarine", 335, TID_REMOVE, 160);
    SpawnSpotForced("ScriptedMarine", 337, TID_REMOVE, 224);
    Thing_Deactivate(TID_REMOVE);
    Thing_SetTranslation(TID_REMOVE, 6);
    SpawnSpotForced("ZombieMan", 267, TID_REMOVE, 32);
    SpawnSpotForced("ChaingunGuy", 268, TID_REMOVE, 64);
    SpawnSpotForced("Archvile", 269, TID_REMOVE, 64);
    SpawnSpotForced("BaronOfHell", 286, TID_REMOVE, 96);
    SpawnSpotForced("CyberDemon", 287, TID_REMOVE, 128);
    SpawnSpotForced("ShotgunGuy", 288, TID_REMOVE, 128);
    SpawnSpotForced("Revenant", 289, TID_REMOVE, 160);
    SpawnSpotForced("HellKnight", 306, TID_REMOVE, 192);
    SpawnSpotForced("DoomImp", 307, TID_REMOVE, 192);
    SpawnSpotForced("WolfensteinSS", 308, TID_REMOVE, 0);
    Thing_Deactivate(TID_REMOVE);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 689, true, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4+10-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame77" (void) // Reach the End (Bit Trip)
{
    int i;
    int time;
    int action=0;
    HUDMessage(s:"Reach the End (Bit Trip)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_runner");
    round_forceobservers = true;
    round_winifmid = true;
    Add_Observer(709);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 710, false, true);
    delay(1);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*49-SECOND*12-30);
    time = SECOND*3;

    // Constantly move the players
    do
    {
        time--;
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (!player_lostround[i])
            {
                int oldpos, newpos;
                oldpos = GetActorY(TID_PLAYER+i);
                SetActorPosition(TID_PLAYER+i, GetActorX(TID_PLAYER+i), GetActorY(TID_PLAYER+i)+10.0, GetActorZ(TID_PLAYER+i), 0);
                SetActorAngle(TID_PLAYER+i, 0.25);
                newpos = GetActorY(TID_PLAYER+i);

                // Kill the player if he didn't move
                if (newpos == oldpos)
                    thing_destroy(TID_PLAYER+i, 1);
            }
        }

        // Move the camera
        SetActorPosition(709, GetActorX(709), GetActorY(709)+10.0, GetActorZ(709), 0);

        // Manipulate the world
        if (time == 0)
        {
            switch (action)
            {
                case 0:
                    Generic_Door(207,64,0,34,0);
                    time = SECOND*10+20;
                    break;
                case 1:
                    Generic_Door(207,64,0,34,0);
                    time = SECOND*9;
                    break;
                case 2:
                    Generic_Door(207,64,0,34,0);
                    time = SECOND*2+5;
                    break;
                case 3:
                    Generic_Door(208,64,0,34,0);
                    time = SECOND*24+10-SECOND*13;
                    break;
            }
            action++;
        }

        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Move the camera back
    SetActorPosition(709, GetActorX(709), -5536.0, GetActorZ(709), 0);
}

Script "DoomWare_Server_Minigame78" (void) // Shoot Apple Imp Head
{
    HUDMessage(s:"Shoot Apple Imp Head"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_apple");

    // Spawn the Imp with an apple on its head
    SpawnSpotForced("ImpTarget", 707, TID_REMOVE, 192);
    SpawnSpotForced("Apple", 706, TID_REMOVE, 192);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 730, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*2-(2*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        Check_FailRoundItem();
        for (int i=0; i<MAXPLAYERS; i++)
            if (player_lostround[i])
                Give_Achievement(i, ACHIEVE_ID_BADAIM);
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame79" (void) // Shoot an Imp
{
    int time = 0;
    HUDMessage(s:"Shoot an Imp"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_CHICKN");
    Line_SetBlocking(26, BLOCKF_CREATURES, 0);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 540, false, true);

    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*8+20-(15*game_speed));

    // Keep the roads busy
    do
    {
        Check_WonRoundItem();
        if (time == 0)
        {
            if (random(0, 15) == 0)
                SpawnSpotForced("ImpKart1UP", random(416, 417), TID_REMOVE, 0);
            else
                SpawnSpotForced("ImpKart", random(416, 417), TID_REMOVE, 0);
            if (random(0, 15) == 0)
                SpawnSpotForced("ImpKart1UP", random(418, 419), TID_REMOVE, 128);
            else
                SpawnSpotForced("ImpKart", random(418, 419), TID_REMOVE, 128);
            time = random(15, SECOND*2);
        }
        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
    Line_SetBlocking(26, 0, BLOCKF_CREATURES);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame80" (void) // Survive (Pyoro)
{
    int time = 0;
    round_winifmid = true;
    round_forceobservers = true;
    hudmessage(s:"Survive (Pyoro)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_PYORO");
    Add_Observer(813);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 820, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*8+(20*game_speed));

    // Make it rain
    do
    {
        if (time == 0)
        {
            SpawnProjectile(814, "Bean", 0, 0, -64-game_speed*4, 0, TID_REMOVE+1);
            SetActorPosition(TID_REMOVE+1, GetActorX(TID_REMOVE+1)+32.0*random(0,29), GetActorY(TID_REMOVE+1), GetActorZ(TID_REMOVE+1), false);
            Thing_ChangeTID(TID_REMOVE+1, TID_REMOVE);
            time = random(15, 35-game_speed*3);
        }
        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Fix the floors
    for (int i=0; i<15; i++)
    {
        if (GetSectorFloorZ(222+i, GetActorX(814)+32.0*i, GetActorY(814)) != 72.0)
        {
            Floor_RaiseInstant(222+i, 0, 64);
            Sector_SetDamage(222+i, 0, MOD_UNKNOWN);
        }
    }
}

Script "DoomWare_Server_Minigame81" (void) // Dodge the Car
{
    int time = 0;
    round_winifmid = true;
    round_forceobservers = true;
    hudmessage(s:"Dodge the Car"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DODGE");
    Add_Observer(815);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 840, false, true);

    // Spawn a car
    Thing_ProjectileGravity(816, random(253, 254), 128, 64, 0);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*4);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame82" (void) // Whack a Diglett
{
    HUDMessage(s:"Whack a Diglett"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DIGLET");

    // Spawn some digletts to whack
    for (int i=0; i<9; i++)
        Spawn("Diglett", random(-304, 304)<<16,random(-304, 304)<<16, 10.0, TID_REMOVE);
    Spawn("DiglettShiny", random(-304, 304)<<16,random(-304, 304)<<16, 10.0, TID_REMOVE);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*4-(10*game_speed));

    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame83" (void) // Charge your Laz0r
{
    int i;
    HUDMessage(s:"Charge your Laz0r"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_DBZ");
    minigame_fragpoints = true;
    minigame_wincondition1 = 1337;

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5+30-(12*game_speed));

    // Make the Auras follow the players
    do
    {
        for (i=0; i<MAXPLAYERS; i++)
        {
            if (ThingCount(0, TID_EXTRA+i) != 0 && GetActorProperty(TID_PLAYER+i, APROP_Health) > 0)
                SetActorPosition(TID_EXTRA+i, GetActorX(TID_PLAYER+i),  GetActorY(TID_PLAYER+i),  GetActorZ(TID_PLAYER+i), false);
            else if (ThingCount(0, TID_EXTRA+i) != 0 && player_answer1[i] != -1)
            {
                SetActorState(TID_EXTRA+i, "Death", true);
                player_answer1[i] = -1;
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Kill the auras
    for (i=0; i<MAXPLAYERS; i++)
        if (ThingCount(0, TID_EXTRA+i) != 0)
            SetActorState(TID_EXTRA+i, "Death", true);
}

Script "DoomWare_Server_Minigame84" (void) // Stay on the Road
{
    int time = 10;
    int direction = 0;
    HUDMessage(s:"Stay on the Road"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("");
    Add_Observer(817);
    round_winifmid = true;

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 860, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10+(12*game_speed));

    // Make the buses drift
    do
    {
        // Change the direction of the buses
        if (time == 0)
        {
            time = random(20, SECOND*2-game_speed*12);
            direction = random(-4, 4);
        }

        // Make the buses drift off
        for (int i=0; i<MAXPLAYERS; i++)
            if (player_lostround[i] == false)
                SetActorVelocity(TID_PLAYER+i, (direction<<16)/(8-game_speed/2), 0, 0, true, false);

        time--;
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame85" (void) // Survive (Time Freeze)
{
    HUDMessage(s:"Survive (Time freeze)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    round_winifmid = true;
    minigame_fragpoints = true;

    // Give all the players a time freeze powerup
    for (int i=0; i<MAXPLAYERS; i++)
        GiveActorInventory(TID_PLAYER+i, "TimeFreeze", 1);

    // Since timefreeze stops music, we gotta fake some
    PlaySound(1, "DoomWare/MusicFreeze", CHAN_ITEM | CHAN_NOPAUSE, 1.0, true, ATTN_NONE);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*10);

    // Stop the "music"
    PlaySound(1, "DoomWare/Blank", CHAN_ITEM | CHAN_NOPAUSE, 1.0, false, ATTN_NONE);
}

Script "DoomWare_Server_Minigame86" (void) // Reach the End (Chasm)
{
    HUDMessage(s:"Reach The End (Chasm)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_the_da");
    Add_Observer(878);
    Add_Observer(877);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 857, true, true);
    
    // Because this map isn't cruel enough, create Imps
    Thing_SpawnNoFog(879, T_IMP, GetActorAngle(879), TID_REMOVE);

    // Start a timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*25-game_speed*SECOND);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_Minigame87" (void) // Be the highest player
{
    int i;
    int highest = 0;
    SetMusic("d_height");
    hudmessage(s:"Be the highest player"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    
    // Raise the floor
    floor_raisebyvalue(19, 16, 64);
    floor_raisebyvalue(20, 8, 32);
    floor_raisebyvalue(21, 8, 32);
    floor_raisebyvalue(22, 8, 32);
    floor_raisebyvalue(691, 8, 32);
    floor_raisebyvalue(692, 8, 32);
    floor_raisebyvalue(693, 8, 32);

    // Let the players survive
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*5+(SECOND*game_speed));

    // Find out what the biggest height is
    for (i=0; i<MAXPLAYERS; i++)
        if (GetActorZ(TID_PLAYER+i) > highest)
            highest = GetActorZ(TID_PLAYER+i);
    
    // Make the highest players win
    for (i=0; i<MAXPLAYERS; i++)
        if (GetActorZ(TID_PLAYER+i) == highest)
            Player_Win(i);
    delay(1);

    // Move things back
    floor_lowerbyvalue(19, 16, 64);
    floor_lowerbyvalue(20, 8, 32);
    floor_lowerbyvalue(21, 8, 32);
    floor_lowerbyvalue(22, 8, 32);
    floor_lowerbyvalue(691, 8, 32);
    floor_lowerbyvalue(692, 8, 32);
    floor_lowerbyvalue(693, 8, 32);
    
}

Script "DoomWare_Server_Minigame88" (void) // Choose a side
{
    bool shifted = 0;
    Add_Observer(898);
    round_forceobservers = true;
    round_winifmid = true;
    hudmessage(s:"Choose a side"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_STEADY");

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 900, false, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*5);
    
    // Shift the seesaw
    delay(1);
    do
    {
        // If two seconds are left
        if (minigame_timer < SECOND*2 && shifted == 0)
        {
            int side1count = ThingCountNameSector("DoomPlayer", 0, 837)+ThingCountNameSector("DoomPlayer", 0, 688);
            int side2count = ThingCountNameSector("DoomPlayer", 0, 836)+ThingCountNameSector("DoomPlayer", 0, 690);
            
            if (side1count > side2count)
            {
                shifted = 1;
                Floor_LowerInstant(837, 0, 16);
                Floor_LowerInstant(688, 0, 16);
                Sector_SetDamage(837, 1337, MOD_LAVA);
                Sector_SetDamage(688, 1337, MOD_LAVA);
                Sector_SetWind(690, 200, 128, 0);
            }
            else if (side1count < side2count)
            {
                shifted = 2;
                Floor_LowerInstant(836, 0, 16);
                Floor_LowerInstant(690, 0, 16);
                Sector_SetDamage(836, 1337, MOD_LAVA);
                Sector_SetDamage(690, 1337, MOD_LAVA);
                Sector_SetWind(688, 200, 0, 0);
            }
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);

    // Fix the seesaw
    if (shifted == 1)
    {
        Floor_RaiseInstant(837, 0, 16);
        Floor_RaiseInstant(688, 0, 16);
        Sector_SetDamage(837, 0, MOD_UNKNOWN);
        Sector_SetDamage(688, 0, MOD_UNKNOWN);
        Sector_SetWind(690, 0, 0, 0);
    }
    else if (shifted == 2)
    {
        Floor_RaiseInstant(836, 0, 16);
        Floor_RaiseInstant(690, 0, 16);
        Sector_SetDamage(836, 0, MOD_UNKNOWN);
        Sector_SetDamage(690, 0, MOD_UNKNOWN);
        Sector_SetWind(688, 0, 0, 0);
    }
}

Script "DoomWare_Server_Minigame89" (void) // Abandon Ship
{
    int i, j, k;
    int nextboom = 0;
    int lastboom = 0;
    hudmessage(s:"Abandon Ship"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_ABANDN");
    
    // Shake the floor and start the alarm
    Radius_Quake2(896, 2, SECOND*7-game_speed*15, 0, 1024, "DoomWare/IceMove");
    Thing_Activate(697);
    
    // Close doors at random
    for (i=0; i<8; i++)
        player_answer1[i] = 900+i;
    for (i=0; i<8; i++)
    {
        j = random(i, 7);
        k = player_answer1[i];
        player_answer1[i] = player_answer1[j];
        player_answer1[j] = k;
    }
    for (i=7; i>=PlayerCount()/2; i--)
        Ceiling_LowerInstant(player_answer1[i], 0, 16);

    // Move all the players to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 896, true, true);

    // Start a timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*7-game_speed*15);
    do
    {
        // Make random booms
        nextboom--;
        if (nextboom <= 0)
        {
            SpawnSpotForced("Explosion_Effect_Quiet", 694+lastboom, 0, 0);
            nextboom = random(5, 15);
            lastboom = (lastboom+1)%3;
        }
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Return players back
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
    
    // Open all the doors again and stop the alarm
    for (i=7; i>=PlayerCount()/2; i--)
        Ceiling_MoveToValue(player_answer1[i], 8, 120, 0);
    Thing_Deactivate(697);
}

Script "DoomWare_Server_Minigame90" (void) // Survive (Captain Falcon)
{
    HUDMessage(s:"Survive (Captain Falcon)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_SSB");
    Add_Observer(698);
    round_winifmid = true;
    minigame_fragpoints = true;
    
    // Teleport everyone to the fighting arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 700, true, true);
    
    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*10+30-(10*game_speed));

    // If there is only one player left, make him win to stop the timer
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
    
    // Teleport the players back to the main arena
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false);
}

Script "DoomWare_Server_Minigame91" (void) // Reach the End (Golden Idol)
{
    HUDMessage(s:"Reach the End (Golden Idol)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_RAIDRS");
    Add_Observer(702);
    
    // Teleport everyone to the Temple of Warriors
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 920, false, true);
    
    // Spawn the "Golden Idol"
    SpawnSpotForced("YellowSkull", 701, TID_REMOVE, 0);
    Thing_SetSpecial(TID_REMOVE, 226, 252, 0, 0);
    
    // Start the timer
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, SECOND*15-(25*game_speed));
    
    // Teleport the players back to the main arena
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false);
}

Script "DoomWare_Server_Minigame92" (void) // Pet Daisy :)
{
    HUDMessage(s:"Pet Daisy :)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_FARM");
    
    // Spawn Daisy :)
    SpawnSpotForced("Daisy", random(3, 10), TID_REMOVE, 0);
    
    // Start the timer
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, SECOND*6-25-(20*game_speed));
    
    // Check for winners
    do
    {
        Check_WonRoundItem();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);
}

Script "DoomWare_Server_Minigame93" (void) // Choose a source port
{
    int port1=0, port2=0, port3=0;
    HUDMessage(s:"Choose a source port"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_MOON");
    minigame_wincondition1 = 0;
    round_winifmid = true;
    
    // Teleport everyone to the arena
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 917, true, true);
    
    // Give people time to make a panic decision
    delay(SECOND*3 + 30);
    
    // Kill anyone not on a port
    Ceiling_CrushRaiseAndStay(916, 96, 1337);
    delay(17);
    
    // Make everyone now change port
    minigame_wincondition1 = random(1, 2);
    delay(SECOND*3 + 33);
    
    // Count the people per port
    for (int i=0; i<MAXPLAYERS; i++)
    {
        port1 += ThingCountSector(T_NONE, TID_PLAYER+i, 705);
        port2 += ThingCountSector(T_NONE, TID_PLAYER+i, 710);
        port3 += ThingCountSector(T_NONE, TID_PLAYER+i, 899);
    }
    
    // Since we don't want any port to have 0, (in the case of few players), correct that
    port1 = Max(1, port1);
    port2 = Max(1, port2);
    port3 = Max(1, port3);
    
    // Crush ceilings depending on the number of players per port
    Ceiling_CrushRaiseAndStay(916, 64, 1337);
    if (minigame_wincondition1 == 1)
    {
        if (port1 < port2 || port1 < port3)
            Ceiling_CrushRaiseAndStay(705, 96, 1337);
        if (port2 < port1 || port2 < port3)
            Ceiling_CrushRaiseAndStay(710, 96, 1337);
        if (port3 < port1 || port3 < port2)
            Ceiling_CrushRaiseAndStay(899, 96, 1337);
    }
    else
    {
        if (port1 > port2 || port1 > port3)
            Ceiling_CrushRaiseAndStay(705, 96, 1337);
        if (port2 > port1 || port2 > port3)
            Ceiling_CrushRaiseAndStay(710, 96, 1337);
        if (port3 > port1 || port3 > port2)
            Ceiling_CrushRaiseAndStay(899, 96, 1337);        
    }
    delay(17);
    
    // Teleport the players back to the main arena
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, false);
}


/*===================================================================================================
                                    1v1 TieBreakers (Serverside)
===================================================================================================*/

Script "DoomWare_Server_TieBreaker1" (void) // Gun Duel
{
    HUDMessage(s:"TieBreaker1v1 - Gun Duel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_gduel");
    Add_Observer(727);

    // Teleport the participants to the arena, make everyone else lose
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[0], 726);
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[1], 708);
    for (int i=2; i<MAXPLAYERS; i++)
        Player_Lose(game_highnames[i], true);

    // Start a random timer
    Delay(random(SECOND*3, SECOND*7));

    // Game started!
    minigame_canmove = true;
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, (SECOND*2));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_TieBreaker2" (void) // Rope Tug
{
    HUDMessage(s:"TieBreaker1v1 - Rope Tug"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_tug");
    Add_Observer(729);

    // Teleport the participants to the arena, make everyone else lose
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[0], 747);
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[1], 746);
    for (int i=2; i<MAXPLAYERS; i++)
        Player_Lose(game_highnames[i], true);

    // Start a random timer
    delay(random(SECOND, SECOND*3));

    // Game started!
    minigame_canmove = true;
    ACS_NamedExecuteWait("DoomWare_Server_GameWait", 0, (SECOND*10));

    // Move the players back if they didn't die
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_TieBreaker3" (void) // Barrels 1v1
{
    int i;
    HUDMessage(s:"TieBreaker1v1 - Gun Duel"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("d_brlfun");
    Add_Observer(751);

    // Teleport the participants to the arena, make everyone else lose
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[0], 750);
    ACS_NamedExecuteAlways("DoomWare_Server_TeleportSingle", 0, game_highnames[1], 749);
    for (i=2; i<MAXPLAYERS; i++)
        Player_Lose(game_highnames[i], true);

    // Spawn the barrels and create a random timer
    SpawnSpotForced("ExplosiveBarrel", 748, TID_REMOVE, 0.0);
    Delay(random(SECOND*2, SECOND*4));

    // Game started!
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, (SECOND*5));

    // Check for winners
    do
    {		
        if (player_lostround[game_highnames[0]])
        {
            Player_Win(game_highnames[1]);
            SetActorProperty(TID_PLAYER+game_highnames[1], APROP_Invulnerable, 1);
        }
        else if (player_lostround[game_highnames[1]])
        {
            Player_Win(game_highnames[0]);
            SetActorProperty(TID_PLAYER+game_highnames[0], APROP_Invulnerable, 1);
        }

        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Move the players back if they didn't die
    SetActorProperty(TID_PLAYER+game_highnames[0], APROP_Invulnerable, 0);
    SetActorProperty(TID_PLAYER+game_highnames[1], APROP_Invulnerable, 0);
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}


/*===================================================================================================
                                  Non 1v1 TieBreakers (Serverside)
===================================================================================================*/

Script "DoomWare_Server_TieBreakerM1" (void) // Survive (Grenades Fight)
{
    HUDMessage(s:"TieBreakerM - Survive (Grenades Fight)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_GARAGE");
    round_winifmid = true;
    minigame_fragpoints = true;
    Add_Observer(752);
    Add_Observer(756);

    // Teleport our participants to the main arena and start a random timer
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 760, false, true);
    delay(random(SECOND*2, SECOND*4));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, (SECOND*13));

    // Check for last man standing
    do
    {
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_TieBreakerM2" (void) // Survive (Decreasing Ring)
{
    int i;
    int floors_dropped = 0;
    int ticks_passsed = 0;
    HUDMessage(s:"TieBreakerM - Survive (Decreasing Ring)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_PUSHER");
    Add_Observer(754);
    round_winifmid = true;

    // Teleport our participants to the main arena and start a random timer
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 753, true, true);
    delay(random(SECOND*2, SECOND*4));

    // Start the timer
    minigame_canmove = true;
    ACS_NamedExecute("DoomWare_Server_GameWait", 0, (SECOND*5 + SECOND*2*9));

    // While the game is running
    do
    {
        // Drop a floor ever 2 seconds
        ticks_passsed++;
        if (ticks_passsed%(SECOND*2) == 0)
        {
            ticks_passsed = 0;
            Floor_LowerInstant(210+floors_dropped, 0, 314);
            Sector_setDamage(210+floors_dropped, 200000, MOD_WATER);
            ChangeFloor(210+floors_dropped, "WFWATER1");
            floors_dropped++;
        }

        // Check for last man standing
        Check_LMS();
        delay(1);
    }
    while (minigame_timer != TIMER_OFF);

    // Bring the dropped floors back up
    for (i=0;i<floors_dropped;i++)
    {
        Floor_RaiseInstant(210+i, 0, 314);
        Sector_setDamage(210+i, 0, MOD_UNKNOWN);
        ChangeFloor(210+i, "NFMBGY01");
    }

    // Return survivors to the waiting room
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}

Script "DoomWare_Server_TieBreakerM3" (void) // Shoot the Target (1 shot)
{
    int i;
    int time = 0;
    int checks = 0;
    HUDMessage(s:"TieBreakerM - Shoot the Target (1 shot)"; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, 2.0, 2.0, 0);
    SetMusic("D_fire");
    Add_Observer(755);

    // Teleport our participants to the main arena and start a random timer
    ACS_NamedExecute("DoomWare_Server_TeleportPlayers", 0, 780, false, true);
    
    // Wait some time
    delay(random(SECOND*2, SECOND*4));

    // Raise the target
    minigame_canmove = true;
    minigame_wincondition1 = random(2, 4);
    Floor_RaiseInstant(217+minigame_wincondition1, 0, 16);

    // Lower the target once it's been shot
    while (time < SECOND*2)
    {
        for (i=0; i<MAXPLAYERS; i++)
		{
            if (player_wonround[i] == true)
            {
                Floor_LowerInstant(217+minigame_wincondition1, 0, 16);
                minigame_wincondition1 = -1;
                break;
            }
		}
        time++;
        delay(1);
    }

    // Lower the target if no one shot it
    for (i=0; i<MAXPLAYERS; i++)
        if (player_wonround[i] != true)
            checks++;
    if (checks == MAXPLAYERS)
        Floor_LowerInstant(217+minigame_wincondition1, 0, 16);

    // Bring people back to the main arena
    ACS_NamedExecute("DoomWare_Server_ReturnPlayers", 0, true);
}


/*===================================================================================================
                                       Extra Minigame Scripts
===================================================================================================*/

Script 9 (int Condition) // Check win with condition
{
    if (Condition == minigame_wincondition1)
        Player_Win(PlayerNumber());
}

Script 10 (void) // Give WonRoundItem for DECORATE
{
    SetActivatorToTarget(0);
    GiveInventory("WonRoundItem", 1);
}

Script 11 (void) // Give FailRoundItem for DECORATE
{
    SetActivatorToTarget(0);
    GiveInventory("FailRoundItem", 1);
}

Script 12 (void) // Win players for accomplishing tasks
{
    int current_minigame = round_current[game_roundnum-1];
    switch (current_minigame)
    {
        case 14:
            if (!Check_Player_Won(PlayerNumber()))
                LocalAmbientSound("DoomWare/Worm", 127);
            Player_Win(PlayerNumber());
            break;
        default:
            Player_Win(PlayerNumber());
            break;
    }
}

Script 13 (void) // Give achievement for catching the 1up in the Sonic Minigame
{
    Give_Achievement(PlayerNumber(), ACHIEVE_ID_LONGJUMP);
}

Script 14 (void) // Give achievement for destroying an ATST
{
    if (ActivatorTID() >= TID_PLAYER && ActivatorTID() <= TID_PLAYER+MAXPLAYERS)
        Give_Achievement(PlayerNumber(), ACHIEVE_ID_ATST);
}

Script 15 (void) // Flash the screen with the NES Zapper
{
    FadeTo(0, 0, 0, 1.0, 0.01);
    delay(2);
    FadeTo(0, 0, 0, 0.0, 0.01);
}

Script 16 (void) // Teleport players in Chasm 1UP spot
{
    Teleport(858, 0, 0);
}

Script 17 (int door) // Abandon Ship Doors
{
    Ceiling_LowerAndCrushDist(900 + door, 120, 1337, 0, 1);
    Player_Win(PlayerNumber());
}

Script 18 (int door) // Teleporting players when pressing doors with keys
{
	if (round_current[game_roundnum-1] != 13 || minigame_timer == TIMER_OFF)
		terminate;
		
	if (door == minigame_wincondition1)
	{
		thing_move(0, 130+PlayerNumber(), false);
		Player_Win(PlayerNumber());
	}
	else
	{
		thing_move(0, 19, false);
		Player_Lose(PlayerNumber(), false);
		Give_Achievement(PlayerNumber(), ACHIEVE_ID_WRONGDOOR);
	}
}

Script 241 (void) // Lose invulnerability in rocket launcher minigame
{
    Thing_Destroy(TID_PLAYER+PlayerNumber(), 1);
}

Script 242 (int HitCaco) // Cacodemon/Number shot
{
    // Prevent the script from running multiple times in one tick
    if (player_answer1[PlayerNumber()] != 0)
        terminate;

    for (int j=0; j<4; j++)
        if (player_answer2[PlayerNumber()][j] == -1)
        {
            player_answer1[PlayerNumber()] = 3;
            player_answer2[PlayerNumber()][j] = HitCaco;
            break;
        }
}

Script 243 (int Key) // Key Reset
{
    if (game_status == STATUS_MINIGAME)
    {
        if (Key == 0)
            SpawnSpotForced("YellowCard", 497, TID_REMOVE, 0);
        if (Key == 1)
            SpawnSpotForced("BlueCard", 498, TID_REMOVE+1, 0);
        if (Key == 2)
            SpawnSpotForced("RedCard", 499, TID_REMOVE+2, 0);
        Thing_SetSpecial(TID_REMOVE, 226, 243, 0, 0);
        Thing_SetSpecial(TID_REMOVE+1, 226, 243, 0, 1);
        Thing_SetSpecial(TID_REMOVE+2, 226, 243, 0, 2);
    }
}

Script 244 (void) // Basketball points
{
    if (!(ClassifyActor(0) & ACTOR_PLAYER) && GetActorZ(0) > 83.0 && GetActorZ(0) < 103.0)
    {
        if (CheckActorInventory(GetActorProperty(0, APROP_TargetTID), "WonRoundItem") == 0)
        {
            GiveActorInventory(GetActorProperty(0, APROP_TargetTID), "WonRoundItem", 1);
            GiveInventory("WonRoundItem", 1);
            SpawnSpotForced("StarSparkleEmitter", 0, TID_REMOVE, 0);
        }
    }
}

Script 245 (void) // Bean floor destruction
{
    int floor = ((GetActorX(0)-GetActorX(814))/64) >> 16;

    // Play a sound if the floor hasn't been destroyed
    if (GetActorZ(0) > 40.0)
        PlaySound(813,"DoomWare/BeanDie");

    // Remove the floor
    if (GetActorZ(0) == 72.0)
    {
        Floor_LowerInstant(222+floor, 0, 64);
        Sector_SetDamage(222+floor, 666, MOD_FALLING);
    }
}

Script 246 (void) // Manipulate projectile on car dodging
{
    int chance = random(1, 2);

    if (game_speed > 0 && chance == 1)
    {
        int velx = GetActorVelX(TID_REMOVE);
        SetActorVelocity(TID_REMOVE, 0.0, 0.0, 0.0, false, false);
        delay(17);
        SetActorVelocity(TID_REMOVE, velx, 0.0, 0.0, false, false);
    }
    else if (game_speed > 2 && chance == 2)
    {
        ThrustThingZ(TID_REMOVE, 23, 0, 0);
    }

    PlaySound(815, "DoomWare/DriveBy");
}

Script 247 (void) // Slow the bus down
{
    Player_Lose(ActivatorTID()-TID_PLAYER, false);
    Thing_Stop(0);
    SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
    While(GetActorProperty(0, APROP_HEalth) > 0 && minigame_timer != TIMER_OFF)
    {
        SetActorVelocity(0, 0.0, -16.0, 0.0, false, false);
        delay(1);
    }
    SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
}

Script 250 (int CheckpointNum) // Checkpoint in kart racing
{
    // If half-way there, increase the checkpoint counter
    if (CheckpointNum == 0)
        player_answer1[PlayerNumber()] = 1;

    // If at the finish lap, and has passed the checkpoint
    if (CheckpointNum == 1 && player_answer1[PlayerNumber()] == 1 && !player_wonround[PlayerNumber()] && ClassifyActor(0) & ACTOR_ALIVE)
    {
        // If first place, give an achievement
        bool otherwinner = false;
        for (int i=0; i<MAXPLAYERS; i++)
            if (player_wonround[i] == true)
                otherwinner = true;
        if (otherwinner == false)
            Give_Achievement(PlayerNumber(), ACHIEVE_ID_KARTWIN);

        // Make player win round
        Player_Win(PlayerNumber());
    }
}

Script "DoomWare_FalconPunchFreeze" (int freeze) // Falcon Punch Weapon freeze
{
    if (freeze)
        Player_FreezeTotally(0);
    else
        Player_UnFreezeTotally(0);
}

Script 251 (void) // Golden idol room arrows
{
    if (GetActorZ(0)-GetActorFloorZ(0) == 0.0 && ThingCountSector(T_NONE, TID_PLAYER+PlayerNumber(), 699) == 0)
    {
        delay(5);
        Thing_damage(0, 1337, MOD_RAILGUN);
    }
}

Script 252 (void) // Golden idol key pickup
{
    if (game_status == STATUS_MINIGAME)
    {
        SpawnSpotForced("YellowSkull", 701, TID_REMOVE, 0);
        Thing_SetSpecial(TID_REMOVE, 226, 252, 0, 0);
        Player_Win(PlayerNumber());
    }
}

int C71UpState = 0;
Script 253 (void) // Corridor 7 1UP Box
{
    switch (C71UpState)
    {
        case 0:
            SetLineTexture(28, SIDE_FRONT, TEXTURE_MIDDLE, "C71UP2");
            delay(2);
            SetLineTexture(28, SIDE_FRONT, TEXTURE_MIDDLE, "C71UP3");
            delay(2);
            SetLineTexture(28, SIDE_FRONT, TEXTURE_MIDDLE, "C71UP4");
            delay(2);
            AmbientSound("DoomWare/C7Door", 127);
            C71UpState = 1;
            break;
        case 1:
            SetLineTexture(28, SIDE_FRONT, TEXTURE_MIDDLE, "C71UP5");
            GiveInventory("1Up", 1);
            C71UpState = 2;
            break;
    }
}

Script "DoomWare_VoidMapBooks" (void) // Void books Polyobjects
{
	if (game_status != STATUS_MINIGAME)
		terminate;
	
	Polyobj_Move(34, 64, 64, 64);
	Polyobj_Move(35, 64, -64, 64);
	delay(10);
	Polyobj_Move(38, 64, 64, 64);
	Polyobj_Move(39, 64, -64, 64);
	delay(10);
	Polyobj_Move(36, 64, 64, 64);
	Polyobj_Move(37, 64, -64, 64);
	delay(10);
	Polyobj_Move(34, 64, -64, 64);
	Polyobj_Move(35, 64, 64, 64);
	delay(10);
	Polyobj_Move(38, 64, -64, 64);
	Polyobj_Move(39, 64, 64, 64);
	delay(10);
	Polyobj_Move(36, 64, -64, 64);
	Polyobj_Move(37, 64, 64, 64);
	delay(10);
	restart;
}

Script "DoomWare_VoidMapPillars" (void) // Void books Pillars
{
	int i;
	int speed = 32;
	int height = 128;
	
	// Stop if we're not playing a minigame
	if (game_status != STATUS_MINIGAME)
		terminate;
	
	// Lower the pillars, then raise them
	for(i=0; i<4; i++)
	{
		floor_lowerbyvalue(980+i, speed, height);
		delay(15);
	}
	for(i=0; i<4; i++)
	{
		floor_raisebyvalue(980+i, speed, height);
		delay(15);
	}
	restart;
}

Script "DoomWare_VoidMapLights" (void) // Void tunnel lights
{
	if (game_status != STATUS_MINIGAME)
		terminate;
	for (int i=0; i<6; i++)
	{
		light_fade(957+i-1, 112, 5);
		light_fade(956+(i+1)%6, 224, 5);
		delay(5);
	}
	restart;
}

script "DoomWare_VoidMapSky" (void) // Void skybox
{
	int i;
	int r = 255*random(0, 1);
	int g = 255*random(0, 1);
	int b;
	
	// Stop if we're not playing a minigame
	if (game_status != STATUS_MINIGAME)
		terminate;
	
	// If no red and green, then force blue (so we don't get a black sky) 
	if (r == 0 && g == 0)
		b = 255;
	else
		b = 255*random(0, 1);
		
	// Paint the sky
	for (i=0; i<4; i++)
	{
		sector_setcolor(967+i, r, g, b, 255);
		light_fade(967+i, 255, SECOND);	
	}
	delay(SECOND);

	// Change the colors again
	r = 255*random(0,1);
	g = 255*random(0,1);
	
	// If no red and green, then force blue (so we don't get a black sky)
	if (r == 0 && g == 0)
		b = 255;
	else
		b = 255*random(0,1);
		
	// Paint the sky again
	for (i=0; i<4; i++)
	{
		sector_setcolor(967+i, r, g, b, 255);
		light_fade(967+i, 0, SECOND);	
	}
	delay(SECOND);
	restart;
}

script 254 (int num) // Void floor platform popups
{
	int plat = -1;
	
	// Decide which platoform to popup
	if (num == 1 && minigame_wincondition1 == 0)
	{
		plat = random(0, 1);
		minigame_wincondition1 |= 1<<plat;

	}
	else if (num == 2 && (minigame_wincondition1&0x04) == 0)
	{
		plat = 2;
		minigame_wincondition1 |= 0x04;
	}
	
	if (plat != -1)
	{
		// Make the platform popup
		ChangeFloor(971+plat*2, "NFMBGY01");
		ChangeFloor(972+plat*2, "FLAT20_2");
		Floor_RaiseByValue(971+plat*2, 255, 11);
		Floor_RaiseByValue(972+plat*2, 255, 8);
		
		delay(1);
		if (num == 1)
		{
			Floor_Waggle(978, 32, 64, 32, SECOND*10);
			Floor_Waggle(971, 32, 64, 32, SECOND*10);
			Floor_Waggle(972, 32, 64, 32, SECOND*10);
			Floor_Waggle(973, 32, 64, 32, SECOND*10);
			Floor_Waggle(974, 32, 64, 32, SECOND*10);
		}
		else
		{
			Floor_Waggle(975, 32, 64, 64, SECOND*10);
			Floor_Waggle(976, 32, 64, 64, SECOND*10);
			Floor_Waggle(979, 32, 64, 64, SECOND*10);
		}
	}
}